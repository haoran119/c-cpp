# é¢è¯•æ€»ç»“ä¹‹C/C++

* [å­¦ä¹ ç¬”è®°ä¹‹IKM C++ 11 - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/p/8465745.html)
* [å­¦ä¹ ç¬”è®°ä¹‹100 TOP Ikm C++ Online Test Questions - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/p/8533582.html)
* [é¢è¯•æ€»ç»“ä¹‹æŒ‡é’ˆ - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/p/5581823.html)
* [[ZZ]è½¯ä»¶å·¥ç¨‹å¸ˆ C/C++ç¬”è¯•é¢˜ - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/archive/2010/10/05/1842918.html)

## RESOURCES
* [STL Time Complexity (Detailed)](http://www.cplusplus.com/reference/stl/)
* [STL Time Complexity (Summary)](http://john-ahlgren.blogspot.com/2013/10/stl-container-performance.html)
* [Data Structure and Algorithms Cheat Sheet](https://github.com/gibsjose/cpp-cheat-sheet/blob/master/Data%20Structures%20and%20Algorithms.md)
* [C++ é¢è¯•çªå‡» - LeetBook - åŠ›æ‰£ï¼ˆLeetCodeï¼‰å…¨çƒæå®¢æŒšçˆ±çš„æŠ€æœ¯æˆé•¿å¹³å°](https://leetcode-cn.com/leetbook/detail/cpp-interview-highlights/)
* [C è¯­è¨€ä¸ C++ é¢è¯•çŸ¥è¯†æ€»ç»“ (qq.com)](https://mp.weixin.qq.com/s/x6DMkh54NQBOlDMqNxvf7w)
  * [huihut/interview: ğŸ“š C/C++ æŠ€æœ¯é¢è¯•åŸºç¡€çŸ¥è¯†æ€»ç»“](https://github.com/huihut/interview#effective)
    * [Effective C++](https://github.com/huihut/interview#effective-c)
    * [More Effective c++](https://github.com/huihut/interview#more-effective-c)
* [è¿™äº›C++å·¥ç¨‹å¸ˆé¢è¯•é¢˜ä½ éƒ½ä¼šäº†å—ï¼Ÿ](https://mp.weixin.qq.com/s/JA3ZrRwS_KllNdJxVMQRdA)
  * [ä½ ä»¬è¦çš„C++é¢è¯•é¢˜ç­”æ¡ˆæ¥äº†--åŸºç¡€ç¯‡](https://mp.weixin.qq.com/s/YRo5Lm9pbbZnjY1DQfW6yw)
* [2021 å¹´ C++ å²—å°±ä¸šå¦‚ä½•ï¼Ÿé™„å­¦ä¹ è·¯çº¿å›¾ (qq.com)](https://mp.weixin.qq.com/s/g6dHxYN7jhw_bLXqnFdEyA)

## ç¼–è¯‘å†…å­˜ç›¸å…³

* #include â€œfilename.hâ€å’Œ#include <filename.h>çš„åŒºåˆ«
  * #include â€œfilename.hâ€æ˜¯æŒ‡ç¼–è¯‘å™¨å°†ä»å½“å‰å·¥ä½œç›®å½•ä¸Šå¼€å§‹æŸ¥æ‰¾æ­¤æ–‡ä»¶
  * #include <filename.h>æ˜¯æŒ‡ç¼–è¯‘å™¨å°†ä»æ ‡å‡†åº“ç›®å½•ä¸­å¼€å§‹æŸ¥æ‰¾æ­¤æ–‡ä»¶
* C++ å†…å­˜ç®¡ç†
  * C++ å†…å­˜åˆ†åŒºï¼šæ ˆã€å †ã€å…¨å±€/é™æ€å­˜å‚¨åŒºã€å¸¸é‡å­˜å‚¨åŒºã€ä»£ç åŒºã€‚
  * æ ˆï¼šå­˜æ”¾å‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‡½æ•°å‚æ•°ã€è¿”å›åœ°å€ç­‰ï¼Œç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…å’Œé‡Šæ”¾ã€‚
  * å †ï¼šåŠ¨æ€ç”³è¯·çš„å†…å­˜ç©ºé—´ï¼Œå°±æ˜¯ç”± malloc åˆ†é…çš„å†…å­˜å—ï¼Œç”±ç¨‹åºå‘˜æ§åˆ¶å®ƒçš„åˆ†é…å’Œé‡Šæ”¾ï¼Œå¦‚æœç¨‹åºæ‰§è¡Œç»“æŸè¿˜æ²¡æœ‰é‡Šæ”¾ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨å›æ”¶ã€‚
  * å…¨å±€åŒº/é™æ€å­˜å‚¨åŒºï¼ˆ.bss æ®µå’Œ .data æ®µï¼‰ï¼šå­˜æ”¾å…¨å±€å˜é‡å’Œé™æ€å˜é‡ï¼Œç¨‹åºè¿è¡Œç»“æŸæ“ä½œç³»ç»Ÿè‡ªåŠ¨é‡Šæ”¾ï¼Œåœ¨ C è¯­è¨€ä¸­ï¼Œæœªåˆå§‹åŒ–çš„æ”¾åœ¨ .bss æ®µä¸­ï¼Œåˆå§‹åŒ–çš„æ”¾åœ¨ .data æ®µä¸­ï¼ŒC++ ä¸­ä¸å†åŒºåˆ†äº†ã€‚
  * å¸¸é‡å­˜å‚¨åŒºï¼ˆ.rodata æ®µï¼‰ï¼šå­˜æ”¾çš„æ˜¯å¸¸é‡ï¼Œä¸å…è®¸ä¿®æ”¹ï¼Œç¨‹åºè¿è¡Œç»“æŸè‡ªåŠ¨é‡Šæ”¾ã€‚
  * ä»£ç åŒºï¼ˆ.text æ®µï¼‰ï¼šå­˜æ”¾ä»£ç ï¼Œä¸å…è®¸ä¿®æ”¹ï¼Œä½†å¯ä»¥æ‰§è¡Œã€‚ç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶å­˜æ”¾åœ¨è¿™é‡Œã€‚
  * è¯´æ˜ï¼š
    * ä»æ“ä½œç³»ç»Ÿçš„æœ¬èº«æ¥è®²ï¼Œä»¥ä¸Šå­˜å‚¨åŒºåœ¨å†…å­˜ä¸­çš„åˆ†å¸ƒæ˜¯å¦‚ä¸‹å½¢å¼(ä»ä½åœ°å€åˆ°é«˜åœ°å€)ï¼š.text æ®µ --> .data æ®µ --> .bss æ®µ --> å † --> unused --> æ ˆ --> env
* å˜é‡çš„å†…å­˜åˆ†åŒº
  * [C/C++çš„å››å¤§å†…å­˜åˆ†åŒº - CSDNåšå®¢](https://blog.csdn.net/K346K346/article/details/45592329)
* C structureï¼Œæ•°æ®ç»“æ„é‡Œæœ‰inter,char,floatæ—¶ï¼Œæ•°æ®çš„å†…å­˜å¸ƒå±€ä¼šæ˜¯æ€æ ·
  * æ•°æ®ä¼šä»¥4ä½æˆ–æ˜¯8ä½ï¼Œ16ä½ç­‰ç­‰æ–¹å¼å¯¹é½
* ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ç§å¯¹é½
  * è¿™æ˜¯å› ä¸ºæœºå™¨å¯»å€å°±æ˜¯æŒ‰ç…§è¿™ç§æ–¹å¼è¿›è¡Œçš„ï¼Œè¿™æ ·å¯ä»¥ä¸€æ¬¡è€Œä¸æ˜¯å¤šæ¬¡è¯»å–ä¸€å®šæ•°æ®
* [é¢è¯•å¸¸è€ƒï¼Œé¡¹ç›®æ˜“é”™ï¼C/C++ä¸­çš„å­—èŠ‚å¯¹é½ (qq.com)](https://mp.weixin.qq.com/s/F0QIjH-fMe7KP-CtlQVbHA)
* C pointer,æŒ‡å‘æ•°æ®ç»“æ„ä¸æŒ‡å‘charçš„æŒ‡é’ˆæœ‰åŒºåˆ«å—
  * å®ƒä»¬æ­£åš+1è¿ç®—æ—¶äº§ç”Ÿçš„ä½ç§»ä¸åŒ
* deleteæ•°ç»„æŒ‡é’ˆï¼Œåªdeleteç¬¬ä¸€ä¸ªåæœ
  * å†…å­˜æ³„æ¼ 
* æ™ºèƒ½æŒ‡é’ˆ
  * æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸ºäº†è§£å†³åŠ¨æ€å†…å­˜åˆ†é…æ—¶å¸¦æ¥çš„å†…å­˜æ³„æ¼ä»¥åŠå¤šæ¬¡é‡Šæ”¾åŒä¸€å—å†…å­˜ç©ºé—´è€Œæå‡ºçš„ã€‚C++11 ä¸­å°è£…åœ¨äº† <memory> å¤´æ–‡ä»¶ä¸­ã€‚
  * C++11 ä¸­æ™ºèƒ½æŒ‡é’ˆåŒ…æ‹¬ä»¥ä¸‹ä¸‰ç§ï¼š
    * å…±äº«æŒ‡é’ˆï¼ˆshared_ptrï¼‰ï¼šèµ„æºå¯ä»¥è¢«å¤šä¸ªæŒ‡é’ˆå…±äº«ï¼Œä½¿ç”¨è®¡æ•°æœºåˆ¶è¡¨æ˜èµ„æºè¢«å‡ ä¸ªæŒ‡é’ˆå…±äº«ã€‚é€šè¿‡ use_count() æŸ¥çœ‹èµ„æºçš„æ‰€æœ‰è€…çš„ä¸ªæ•°ï¼Œå¯ä»¥é€šè¿‡ unique_ptrã€weak_ptr æ¥æ„é€ ï¼Œè°ƒç”¨ release() é‡Šæ”¾èµ„æºçš„æ‰€æœ‰æƒï¼Œè®¡æ•°å‡ä¸€ï¼Œå½“è®¡æ•°å‡ä¸º 0 æ—¶ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜ç©ºé—´ï¼Œä»è€Œé¿å…äº†å†…å­˜æ³„æ¼ã€‚
    * ç‹¬å æŒ‡é’ˆï¼ˆunique_ptrï¼‰ï¼šç‹¬äº«æ‰€æœ‰æƒçš„æ™ºèƒ½æŒ‡é’ˆï¼Œèµ„æºåªèƒ½è¢«ä¸€ä¸ªæŒ‡é’ˆå æœ‰ï¼Œè¯¥æŒ‡é’ˆä¸èƒ½æ‹·è´æ„é€ å’Œèµ‹å€¼ã€‚ä½†å¯ä»¥è¿›è¡Œç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼æ„é€ ï¼ˆè°ƒç”¨ move() å‡½æ•°ï¼‰ï¼Œå³ä¸€ä¸ª unique_ptr å¯¹è±¡èµ‹å€¼ç»™å¦ä¸€ä¸ª unique_ptr å¯¹è±¡ï¼Œå¯ä»¥é€šè¿‡è¯¥æ–¹æ³•è¿›è¡Œèµ‹å€¼ã€‚
    * å¼±æŒ‡é’ˆï¼ˆweak_ptrï¼‰ï¼šæŒ‡å‘ share_ptr æŒ‡å‘çš„å¯¹è±¡ï¼Œèƒ½å¤Ÿè§£å†³ç”±shared_ptrå¸¦æ¥çš„å¾ªç¯å¼•ç”¨é—®é¢˜ã€‚
  * æ™ºèƒ½æŒ‡é’ˆçš„å®ç°åŸç†ï¼š è®¡æ•°åŸç†ã€‚
  * [æ™ºèƒ½æŒ‡é’ˆ_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=-4Fxt6pJdzfT54y9W-fRgMxlSYiedMOkLOxNlQf67rz_wHTOhIvtESgw6s8sEdgGMy2PxyNj0VUNe_IpaSBnbK)
    * å½“ç±»ä¸­æœ‰æŒ‡é’ˆæˆå‘˜æ—¶ï¼Œä¸€èˆ¬æœ‰ä¸¤ç§æ–¹å¼æ¥ç®¡ç†æŒ‡é’ˆæˆå‘˜ï¼šä¸€æ˜¯é‡‡ç”¨å€¼å‹çš„æ–¹å¼ç®¡ç†ï¼Œæ¯ä¸ªç±»å¯¹è±¡éƒ½ä¿ç•™ä¸€ä»½æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡çš„æ‹·è´ï¼›å¦ä¸€ç§æ›´ä¼˜é›…çš„æ–¹å¼æ˜¯ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œä»è€Œå®ç°æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡çš„å…±äº«ã€‚
    * æ™ºèƒ½æŒ‡é’ˆ(smart pointer)çš„ä¸€ç§é€šç”¨å®ç°æŠ€æœ¯æ˜¯ä½¿ç”¨å¼•ç”¨è®¡æ•°(reference count)ã€‚æ™ºèƒ½æŒ‡é’ˆç±»å°†ä¸€ä¸ªè®¡æ•°å™¨ä¸ç±»æŒ‡å‘çš„å¯¹è±¡ç›¸å…³è”ï¼Œå¼•ç”¨è®¡æ•°è·Ÿè¸ªè¯¥ç±»æœ‰å¤šå°‘ä¸ªå¯¹è±¡çš„æŒ‡é’ˆæŒ‡å‘åŒä¸€å¯¹è±¡ã€‚
    * æ¯æ¬¡åˆ›å»ºç±»çš„æ–°å¯¹è±¡æ—¶ï¼Œåˆå§‹åŒ–æŒ‡é’ˆå¹¶å°†å¼•ç”¨è®¡æ•°ç½®ä¸º1ï¼›å½“å¯¹è±¡ä½œä¸ºå¦ä¸€å¯¹è±¡çš„å‰¯æœ¬è€Œåˆ›å»ºæ—¶ï¼Œæ‹·è´æ„é€ å‡½æ•°æ‹·è´æŒ‡é’ˆå¹¶å¢åŠ ä¸ä¹‹ç›¸åº”çš„å¼•ç”¨è®¡æ•°ï¼›å¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œèµ‹å€¼æ—¶ï¼Œèµ‹å€¼æ“ä½œç¬¦å‡å°‘å·¦æ“ä½œæ•°æ‰€æŒ‡å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼ˆå¦‚æœå¼•ç”¨è®¡æ•°ä¸ºå‡è‡³0ï¼Œåˆ™åˆ é™¤å¯¹è±¡ï¼‰ï¼Œå¹¶å¢åŠ å³æ“ä½œæ•°æ‰€æŒ‡å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼›è°ƒç”¨ææ„å‡½æ•°æ—¶ï¼Œææ„å‡½æ•°å‡å°‘å¼•ç”¨è®¡æ•°ï¼ˆå¦‚æœå¼•ç”¨è®¡æ•°å‡è‡³0ï¼Œåˆ™åˆ é™¤åŸºç¡€å¯¹è±¡ï¼‰ã€‚
    * å®ç°å¼•ç”¨è®¡æ•°æœ‰ä¸¤ç§ç»å…¸ç­–ç•¥ï¼šä¸€æ˜¯å¼•å…¥è¾…åŠ©ç±»ï¼ŒäºŒæ˜¯ä½¿ç”¨å¥æŸ„ç±»ã€‚
    * ä¸ºäº†é¿å…æ–¹æ¡ˆä¸€ä¸­æ¯ä¸ªä½¿ç”¨æŒ‡é’ˆçš„ç±»è‡ªå·±å»æ§åˆ¶å¼•ç”¨è®¡æ•°ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªç±»æŠŠæŒ‡é’ˆå°è£…èµ·æ¥ã€‚å°è£…å¥½åï¼Œè¿™ä¸ªç±»å¯¹è±¡å¯ä»¥å‡ºç°åœ¨ç”¨æˆ·ç±»ä½¿ç”¨æŒ‡é’ˆçš„ä»»ä½•åœ°æ–¹ï¼Œè¡¨ç°ä¸ºä¸€ä¸ªæŒ‡é’ˆçš„è¡Œä¸ºã€‚æˆ‘ä»¬å¯ä»¥åƒæŒ‡é’ˆä¸€æ ·ä½¿ç”¨å®ƒï¼Œè€Œä¸ç”¨æ‹…å¿ƒæ™®é€šæˆå‘˜æŒ‡é’ˆæ‰€å¸¦æ¥çš„é—®é¢˜ï¼Œæˆ‘ä»¬æŠŠè¿™æ ·çš„ç±»å«å¥æŸ„ç±»ã€‚åœ¨å°è£…å¥æŸ„ç±»æ—¶ï¼Œéœ€è¦ç”³è¯·ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„å¼•ç”¨è®¡æ•°ç©ºé—´ï¼ŒæŒ‡é’ˆä¸å¼•ç”¨è®¡æ•°åˆ†å¼€å­˜å‚¨ã€‚
    * æ™ºèƒ½æŒ‡é’ˆæ˜¯å­˜å‚¨æŒ‡å‘åŠ¨æ€åˆ†é…ï¼ˆå †ï¼‰å¯¹è±¡æŒ‡é’ˆçš„ç±»ã€‚é™¤äº†èƒ½å¤Ÿåœ¨é€‚å½“çš„æ—¶é—´è‡ªåŠ¨åˆ é™¤æŒ‡å‘çš„å¯¹è±¡å¤–ï¼Œä»–ä»¬çš„å·¥ä½œæœºåˆ¶å¾ˆåƒC++çš„å†…ç½®æŒ‡é’ˆã€‚æ™ºèƒ½æŒ‡é’ˆåœ¨é¢å¯¹å¼‚å¸¸çš„æ—¶å€™æ ¼å¤–æœ‰ç”¨ï¼Œå› ä¸ºä»–ä»¬èƒ½å¤Ÿç¡®ä¿æ­£ç¡®çš„é”€æ¯åŠ¨æ€åˆ†é…çš„å¯¹è±¡ã€‚ä»–ä»¬ä¹Ÿå¯ä»¥ç”¨äºè·Ÿè¸ªè¢«å¤šç”¨æˆ·å…±äº«çš„åŠ¨æ€åˆ†é…å¯¹è±¡ã€‚
    * äº‹å®ä¸Šï¼Œæ™ºèƒ½æŒ‡é’ˆèƒ½å¤Ÿåšçš„è¿˜æœ‰å¾ˆå¤šäº‹æƒ…ï¼Œä¾‹å¦‚å¤„ç†çº¿ç¨‹å®‰å…¨ï¼Œæä¾›å†™æ—¶å¤åˆ¶ï¼Œç¡®ä¿åè®®ï¼Œå¹¶ä¸”æä¾›è¿œç¨‹äº¤äº’æœåŠ¡ã€‚æœ‰èƒ½å¤Ÿä¸ºè¿™äº›ESP (Extremely Smart Pointers)åˆ›å»ºä¸€èˆ¬æ™ºèƒ½æŒ‡é’ˆçš„æ–¹æ³•ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ¶µç›–è¿›æ¥ã€‚
    * æ™ºèƒ½æŒ‡é’ˆçš„å¤§éƒ¨åˆ†ä½¿ç”¨æ˜¯ç”¨äºç”Ÿå­˜æœŸæ§åˆ¶ï¼Œé˜¶æ®µæ§åˆ¶ã€‚å®ƒä»¬ä½¿ç”¨operator->å’Œoperator*æ¥ç”ŸæˆåŸå§‹æŒ‡é’ˆï¼Œè¿™æ ·æ™ºèƒ½æŒ‡é’ˆçœ‹ä¸Šå»å°±åƒä¸€ä¸ªæ™®é€šæŒ‡é’ˆã€‚
    * è¿™æ ·çš„ä¸€ä¸ªç±»æ¥è‡ªæ ‡å‡†åº“ï¼šstd::auto_ptrã€‚å®ƒæ˜¯ä¸ºè§£å†³èµ„æºæ‰€æœ‰æƒé—®é¢˜è®¾è®¡çš„ï¼Œä½†æ˜¯ç¼ºå°‘å¯¹å¼•ç”¨æ•°å’Œæ•°ç»„çš„æ”¯æŒã€‚å¹¶ä¸”ï¼Œstd::auto_ptråœ¨è¢«å¤åˆ¶çš„æ—¶å€™ä¼šä¼ è¾“æ‰€æœ‰æƒã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ éœ€è¦æ›´å¤šçš„å’Œ/æˆ–è€…æ˜¯ä¸åŒçš„åŠŸèƒ½ã€‚è¿™æ—¶å°±éœ€è¦åŠ å…¥smart_ptrç±»ã€‚
  * [æ™ºèƒ½æŒ‡é’ˆï¼ˆç°ä»£ C++ï¼‰](https://msdn.microsoft.com/zh-cn/library/hh279674.aspx)
    * In modern C++ programming, the Standard Library includes smart pointers, which are used to help ensure that programs are free of memory and resource leaks and are exception-safe.
    * Smart pointers are defined in the std namespace in the \<memory\> header file. They are crucial to the RAII or Resource Acquisition Is Initialization programming idiom. The main goal of this idiom is to ensure that resource acquisition occurs at the same time that the object is initialized, so that all resources for the object are created and made ready in one line of code. In practical terms, the main principle of RAII is to give ownership of any heap-allocated resourceâ€”for example, dynamically-allocated memory or system object handlesâ€”to a stack-allocated object whose destructor contains the code to delete or free the resource and also any associated cleanup code.
    * In most cases, when you initialize a raw pointer or resource handle to point to an actual resource, pass the pointer to a smart pointer immediately. In modern C++, raw pointers are only used in small code blocks of limited scope, loops, or helper functions where performance is critical and there is no chance of confusion about ownership.
    * The C++ smart pointer idiom resembles object creation in languages such as C#: you create the object and then let the system take care of deleting it at the correct time. The difference is that no separate garbage collector runs in the background; memory is managed through the standard C++ scoping rules so that the runtime environment is faster and more efficient.
    * Important : Always create smart pointers on a separate line of code, never in a parameter list, so that a subtle resource leak won't occur due to certain parameter list allocation rules.
    * Use these smart pointers as a first choice for encapsulating pointers to plain old C++ objects (POCO).
    * unique_ptr
      * Allows exactly one owner of the underlying pointer. Use as the default choice for POCO unless you know for certain that you require a shared_ptr. Can be moved to a new owner, but not copied or shared. Replaces auto_ptr, which is deprecated. Compare to boost::scoped_ptr. unique_ptr is small and efficient; the size is one pointer and it supports rvalue references for fast insertion and retrieval from C++ Standard Library collections. Header file: \<memory\>. For more information, see [How to: Create and use unique_ptr instances | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-160) and [unique_ptr Class](https://docs.microsoft.com/en-us/cpp/standard-library/unique-ptr-class?view=msvc-160).
    * shared_ptr
      * Reference-counted smart pointer. Use when you want to assign one raw pointer to multiple owners, for example, when you return a copy of a pointer from a container but want to keep the original. The raw pointer is not deleted until all shared_ptr owners have gone out of scope or have otherwise given up ownership. The size is two pointers; one for the object and one for the shared control block that contains the reference count. Header file: \<memory\>. For more information, see [How to: Create and use shared_ptr instances | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-shared-ptr-instances?view=msvc-160) and [shared_ptr Class](https://docs.microsoft.com/en-us/cpp/standard-library/shared-ptr-class?view=msvc-160).
    * weak_ptr
      * Special-case smart pointer for use in conjunction with shared_ptr. A weak_ptr provides access to an object that is owned by one or more shared_ptr instances, but does not participate in reference counting. Use when you want to observe an object, but do not require it to remain alive. Required in some cases to break circular references between shared_ptr instances. Header file: \<memory\>. For more information, see [How to: Create and use weak_ptr instances | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-weak-ptr-instances?view=msvc-160) and [weak_ptr Class](https://docs.microsoft.com/en-us/cpp/standard-library/weak-ptr-class?view=msvc-160).
  * [Smart pointer - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Smart_pointer)
  * [æ™ºèƒ½æŒ‡é’ˆï¼šä»std::auto_ptråˆ°std::unique_ptr - hanhuiliçš„ä¸“æ  - åšå®¢é¢‘é“ - CSDN.NET](http://blog.csdn.net/hanhuili/article/details/8299912)
  * [æ‹¥æŠ±æ™ºèƒ½æŒ‡é’ˆï¼Œå‘Šåˆ«å†…å­˜æ³„éœ²](https://mp.weixin.qq.com/s/evYOoS4_XfjkPXlDWXTnSg)
  * [æµ…æ C++æ™ºèƒ½æŒ‡é’ˆå’Œ enable_shared_from_this æœºåˆ¶](https://mp.weixin.qq.com/s/a7Nl2jnbOtkfzEAK1TxVyA)

## è¯­è¨€å¯¹æ¯”

* C++å¦‚ä½•å®ç°JAVAæ¥å£
  * [javaæ¥å£_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=hoPdmBnxPUNPpyCRPD80NQVbOPS0qT5IoI1jezWUDT4Dz0MdgaVrPEurjtacqy6rJRZxO0CrQCNqDn5czUriNK)
  * [C++ä¸­çš„æŠ½è±¡ç±»ä»¥åŠæ¥å£çš„åŒºåˆ«è”ç³»_Linuxç¼–ç¨‹_Linuxå…¬ç¤¾-Linuxç³»ç»Ÿé—¨æˆ·ç½‘ç«™](http://www.linuxidc.com/Linux/2012-10/73243.htm)

## å…³é”®å­—åº“å‡½æ•°

* [size_t_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=sh8RRfasW1QG-PhcWPZhfcZ75Uw-KYLKh443jzpNg36hVk1Fu7WeTh4lEPLCuBx_iT0wglX5MRQUqXJMWV-oUK)
* staticå…³é”®å­—è‡³å°‘æœ‰ä¸‹åˆ—nä¸ªä½œç”¨ï¼š
  * å‡½æ•°ä½“å†…staticå˜é‡çš„ä½œç”¨èŒƒå›´ä¸ºè¯¥å‡½æ•°ä½“ï¼Œä¸åŒäºautoå˜é‡ï¼Œè¯¥å˜é‡çš„å†…å­˜åªè¢«åˆ†é…ä¸€æ¬¡ï¼Œå› æ­¤å…¶å€¼åœ¨ä¸‹æ¬¡è°ƒç”¨æ—¶ä»ç»´æŒä¸Šæ¬¡çš„å€¼ï¼›
  * åœ¨æ¨¡å—å†…çš„staticå…¨å±€å˜é‡å¯ä»¥è¢«æ¨¡å—å†…æ‰€ç”¨å‡½æ•°è®¿é—®ï¼Œä½†ä¸èƒ½è¢«æ¨¡å—å¤–å…¶å®ƒå‡½æ•°è®¿é—®ï¼›
  * åœ¨æ¨¡å—å†…çš„staticå‡½æ•°åªå¯è¢«è¿™ä¸€æ¨¡å—å†…çš„å…¶å®ƒå‡½æ•°è°ƒç”¨ï¼Œè¿™ä¸ªå‡½æ•°çš„ä½¿ç”¨èŒƒå›´è¢«é™åˆ¶åœ¨å£°æ˜å®ƒçš„æ¨¡å—å†…ï¼›
  * åœ¨ç±»ä¸­çš„staticæˆå‘˜å˜é‡å±äºæ•´ä¸ªç±»æ‰€æ‹¥æœ‰ï¼Œå¯¹ç±»çš„æ‰€æœ‰å¯¹è±¡åªæœ‰ä¸€ä»½æ‹·è´ï¼›
  * åœ¨ç±»ä¸­çš„staticæˆå‘˜å‡½æ•°å±äºæ•´ä¸ªç±»æ‰€æ‹¥æœ‰ï¼Œè¿™ä¸ªå‡½æ•°ä¸æ¥æ”¶thisæŒ‡é’ˆï¼Œå› è€Œåªèƒ½è®¿é—®ç±»çš„staticæˆå‘˜å˜é‡ã€‚
* constå…³é”®å­—è‡³å°‘æœ‰ä¸‹åˆ—nä¸ªä½œç”¨ï¼š
  * æ¬²é˜»æ­¢ä¸€ä¸ªå˜é‡è¢«æ”¹å˜ï¼Œå¯ä»¥ä½¿ç”¨constå…³é”®å­—ã€‚åœ¨å®šä¹‰è¯¥constå˜é‡æ—¶ï¼Œé€šå¸¸éœ€è¦å¯¹å®ƒè¿›è¡Œåˆå§‹åŒ–ï¼Œå› ä¸ºä»¥åå°±æ²¡æœ‰æœºä¼šå†å»æ”¹å˜å®ƒäº†ï¼›
  * å¯¹æŒ‡é’ˆæ¥è¯´ï¼Œå¯ä»¥æŒ‡å®šæŒ‡é’ˆæœ¬èº«ä¸ºconstï¼Œä¹Ÿå¯ä»¥æŒ‡å®šæŒ‡é’ˆæ‰€æŒ‡çš„æ•°æ®ä¸ºconstï¼Œæˆ–äºŒè€…åŒæ—¶æŒ‡å®šä¸ºconstï¼›
  * åœ¨ä¸€ä¸ªå‡½æ•°å£°æ˜ä¸­ï¼Œconstå¯ä»¥ä¿®é¥°å½¢å‚ï¼Œè¡¨æ˜å®ƒæ˜¯ä¸€ä¸ªè¾“å…¥å‚æ•°ï¼Œåœ¨å‡½æ•°å†…éƒ¨ä¸èƒ½æ”¹å˜å…¶å€¼ï¼›
  * å¯¹äºç±»çš„æˆå‘˜å‡½æ•°ï¼Œè‹¥æŒ‡å®šå…¶ä¸ºconstç±»å‹ï¼Œåˆ™è¡¨æ˜å…¶æ˜¯ä¸€ä¸ªå¸¸å‡½æ•°ï¼Œä¸èƒ½ä¿®æ”¹ç±»çš„æˆå‘˜å˜é‡ï¼›
  * å¯¹äºç±»çš„æˆå‘˜å‡½æ•°ï¼Œæœ‰æ—¶å€™å¿…é¡»æŒ‡å®šå…¶è¿”å›å€¼ä¸ºconstç±»å‹ï¼Œä»¥ä½¿å¾—å…¶è¿”å›å€¼ä¸ä¸ºâ€œå·¦å€¼â€ã€‚
* çŸ­å°è€Œè¢«é¢‘ç¹è°ƒç”¨çš„ç¨‹åºå¦‚ä½•å¤„ç†ï¼Ÿ
  * Cè¯­è¨€ç”¨å®ä»£æ›¿ã€‚
  * C++ç”¨inlineï¼Œå†…è”å‡½æ•°æœºåˆ¶ã€‚
  * å†…è”å‡½æ•°å¯ä»¥å¾—åˆ°å®çš„æ›¿æ¢åŠŸèƒ½ï¼Œæ‰€æœ‰å¯é¢„è§çš„çŠ¶æ€å’Œå¸¸è§„å‡½æ•°çš„ç±»å‹æ£€æŸ¥ã€‚
* [structå’Œunionçš„åŒºåˆ«](http://blog.csdn.net/firefly_2002/article/details/7954458)
  * åœ¨å­˜å‚¨å¤šä¸ªæˆå‘˜ä¿¡æ¯æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç»™structç¬¬ä¸ªæˆå‘˜åˆ†é…å­˜å‚¨ç©ºé—´ï¼Œstructå¯ä»¥å­˜å‚¨å¤šä¸ªæˆå‘˜ä¿¡æ¯ï¼Œè€Œunionæ¯ä¸ªæˆå‘˜ä¼šç”¨åŒä¸€ä¸ªå­˜å‚¨ç©ºé—´ï¼Œåªèƒ½å­˜å‚¨æœ€åä¸€ä¸ªæˆå‘˜çš„ä¿¡æ¯ã€‚
  * éƒ½æ˜¯ç”±å¤šä¸ªä¸åŒçš„æ•°æ®ç±»å‹æˆå‘˜ç»„æˆï¼Œä½†åœ¨ä»»ä½•åŒä¸€æ—¶åˆ»ï¼ŒUnionåªå­˜æ”¾äº†ä¸€ä¸ªè¢«å…ˆé€‰ä¸­çš„æˆå‘˜ï¼Œè€Œç»“æ„ä½“çš„æ‰€æœ‰æˆå‘˜éƒ½å­˜åœ¨ã€‚
  * å¯¹äºUnionçš„ä¸åŒæˆå‘˜èµ‹å€¼ï¼Œå°†ä¼šå¯¹å…¶ä»–æˆå‘˜é‡å†™ï¼ŒåŸæ¥æˆå‘˜çš„å€¼å°±ä¸å­˜åœ¨äº†ï¼Œè€Œå¯¹äºstructçš„ä¸åŒæˆå‘˜èµ‹å€¼æ˜¯äº’ä¸å½±å“çš„ã€‚
* structå’Œclassçš„åŒºåˆ«
  * [Access Control and Constraints of Structures, Classes and Unions](https://msdn.microsoft.com/en-us/library/4a1hcx0y.aspx)

|Structures|Classes|Unions|
| - | - | - |
|class key is struct|class key is class|class key is union|
|Default access is public|	Default access is private|	Default access is public
|No usage constraints|	No usage constraints|	Use only one member at a time
|Default inheritance is public	|Default inheritance is private	|-
|Could not use Template	|Could use Template	|-

* volatile
  * [volatile_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=gPm-SmXKapujjcPjO3COGYDPSvH4VPOMabuV61XG7kM1kMhwX1AnNxF5_VZDiq7fizEaEfpYKLRBVgRt99BxOK)
  * [volatile (C++)](https://msdn.microsoft.com/zh-cn/library/12a04hfd.aspx)

## é¢å‘å¯¹è±¡

* é¢å‘å¯¹è±¡çš„ä¸‰å¤§ç‰¹æ€§ï¼š
  * å°è£…(Encapsulation)ï¼šå°†å…·ä½“çš„å®ç°è¿‡ç¨‹å’Œæ•°æ®å°è£…æˆä¸€ä¸ªå‡½æ•°ï¼Œåªèƒ½é€šè¿‡æ¥å£è¿›è¡Œè®¿é—®ï¼Œé™ä½è€¦åˆæ€§ã€‚
  * ç»§æ‰¿(Inheritance)ï¼šå­ç±»ç»§æ‰¿çˆ¶ç±»çš„ç‰¹å¾å’Œè¡Œä¸ºï¼Œå­ç±»æœ‰çˆ¶ç±»çš„é private æ–¹æ³•æˆ–æˆå‘˜å˜é‡ï¼Œå­ç±»å¯ä»¥å¯¹çˆ¶ç±»çš„æ–¹æ³•è¿›è¡Œé‡å†™ï¼Œå¢å¼ºäº†ç±»ä¹‹é—´çš„è€¦åˆæ€§ï¼Œä½†æ˜¯å½“çˆ¶ç±»ä¸­çš„æˆå‘˜å˜é‡ã€æˆå‘˜å‡½æ•°æˆ–è€…ç±»æœ¬èº«è¢« final å…³é”®å­—ä¿®é¥°æ—¶ï¼Œä¿®é¥°çš„ç±»ä¸èƒ½ç»§æ‰¿ï¼Œä¿®é¥°çš„æˆå‘˜ä¸èƒ½é‡å†™æˆ–ä¿®æ”¹ã€‚
  * å¤šæ€(Polymorphism)ï¼šå¤šæ€å°±æ˜¯ä¸åŒç»§æ‰¿ç±»çš„å¯¹è±¡ï¼Œå¯¹åŒä¸€æ¶ˆæ¯åšå‡ºä¸åŒçš„å“åº”ï¼ŒåŸºç±»çš„æŒ‡é’ˆæŒ‡å‘æˆ–ç»‘å®šåˆ°æ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œä½¿å¾—åŸºç±»æŒ‡é’ˆå‘ˆç°ä¸åŒçš„è¡¨ç°æ–¹å¼ã€‚
* é‡è½½ã€é‡å†™ã€éšè—çš„åŒºåˆ«
  * é‡è½½(Overload)ï¼šæ˜¯æŒ‡åŒä¸€å¯è®¿é—®åŒºå†…è¢«å£°æ˜å‡ ä¸ªå…·æœ‰ä¸åŒå‚æ•°åˆ—ï¼ˆå‚æ•°çš„ç±»å‹ã€ä¸ªæ•°ã€é¡ºåºï¼‰çš„åŒåå‡½æ•°ï¼Œæ ¹æ®å‚æ•°åˆ—è¡¨ç¡®å®šè°ƒç”¨å“ªä¸ªå‡½æ•°ï¼Œé‡è½½ä¸å…³å¿ƒå‡½æ•°è¿”å›ç±»å‹ã€‚
  * éšè—(Overwrite / Hide)ï¼šæ˜¯æŒ‡æ´¾ç”Ÿç±»çš„å‡½æ•°å±è”½äº†ä¸å…¶åŒåçš„åŸºç±»å‡½æ•°ï¼Œä¸»è¦åªè¦åŒåå‡½æ•°ï¼Œä¸ç®¡å‚æ•°åˆ—è¡¨æ˜¯å¦ç›¸åŒï¼ŒåŸºç±»å‡½æ•°éƒ½ä¼šè¢«éšè—ã€‚
  * é‡å†™(è¦†ç›–)(Override)ï¼šæ˜¯æŒ‡æ´¾ç”Ÿç±»ä¸­å­˜åœ¨é‡æ–°å®šä¹‰çš„å‡½æ•°ã€‚å‡½æ•°åã€å‚æ•°åˆ—è¡¨ã€è¿”å›å€¼ç±»å‹éƒ½å¿…é¡»åŒåŸºç±»ä¸­è¢«é‡å†™çš„å‡½æ•°ä¸€è‡´ï¼Œåªæœ‰å‡½æ•°ä½“ä¸åŒã€‚æ´¾ç”Ÿç±»è°ƒç”¨æ—¶ä¼šè°ƒç”¨æ´¾ç”Ÿç±»çš„é‡å†™å‡½æ•°ï¼Œä¸ä¼šè°ƒç”¨è¢«é‡å†™å‡½æ•°ã€‚é‡å†™çš„åŸºç±»ä¸­è¢«é‡å†™çš„å‡½æ•°å¿…é¡»æœ‰ virtual ä¿®é¥°ã€‚
  * é‡å†™å’Œé‡è½½çš„åŒºåˆ«ï¼š
    * èŒƒå›´åŒºåˆ«ï¼šå¯¹äºç±»ä¸­å‡½æ•°çš„é‡è½½æˆ–è€…é‡å†™è€Œè¨€ï¼Œé‡è½½å‘ç”Ÿåœ¨åŒä¸€ä¸ªç±»çš„å†…éƒ¨ï¼Œé‡å†™å‘ç”Ÿåœ¨ä¸åŒçš„ç±»ä¹‹é—´ï¼ˆå­ç±»å’Œçˆ¶ç±»ä¹‹é—´ï¼‰ã€‚
    * å‚æ•°åŒºåˆ«ï¼šé‡è½½çš„å‡½æ•°éœ€è¦ä¸åŸå‡½æ•°æœ‰ç›¸åŒçš„å‡½æ•°åã€ä¸åŒçš„å‚æ•°åˆ—è¡¨ï¼Œä¸å…³æ³¨å‡½æ•°çš„è¿”å›å€¼ç±»å‹ï¼›é‡å†™çš„å‡½æ•°çš„å‡½æ•°åã€å‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼ç±»å‹éƒ½éœ€è¦å’ŒåŸå‡½æ•°ç›¸åŒï¼Œçˆ¶ç±»ä¸­è¢«é‡å†™çš„å‡½æ•°éœ€è¦æœ‰ virtual ä¿®é¥°ã€‚
    * virtual å…³é”®å­—ï¼šé‡å†™çš„å‡½æ•°åŸºç±»ä¸­å¿…é¡»æœ‰ virtualå…³é”®å­—çš„ä¿®é¥°ï¼Œé‡è½½çš„å‡½æ•°å¯ä»¥æœ‰ virtual å…³é”®å­—çš„ä¿®é¥°ä¹Ÿå¯ä»¥æ²¡æœ‰ã€‚
  * éšè—å’Œé‡å†™ï¼Œé‡è½½çš„åŒºåˆ«ï¼š
    * èŒƒå›´åŒºåˆ«ï¼šéšè—ä¸é‡è½½èŒƒå›´ä¸åŒï¼Œéšè—å‘ç”Ÿåœ¨ä¸åŒç±»ä¸­ã€‚
    * å‚æ•°åŒºåˆ«ï¼šéšè—å‡½æ•°å’Œè¢«éšè—å‡½æ•°å‚æ•°åˆ—è¡¨å¯ä»¥ç›¸åŒï¼Œä¹Ÿå¯ä»¥ä¸åŒï¼Œä½†å‡½æ•°åä¸€å®šç›¸åŒï¼›å½“å‚æ•°ä¸åŒæ—¶ï¼Œæ— è®ºåŸºç±»ä¸­çš„å‡½æ•°æ˜¯å¦è¢« virtual ä¿®é¥°ï¼ŒåŸºç±»å‡½æ•°éƒ½æ˜¯è¢«éšè—ï¼Œè€Œä¸æ˜¯é‡å†™ã€‚
* C++è™šæ‹Ÿæœºåˆ¶
  * ç”¨æ¥å®ç°å¤šæ€
* å¤šé‡ç»§æ‰¿
  * å¯ä»¥ä¸ºä¸€ä¸ªæ´¾ç”Ÿç±»æŒ‡å®šå¤šä¸ªåŸºç±»ï¼Œè¿™æ ·çš„ç»§æ‰¿ç»“æ„ç§°ä¸ºå¤šé‡ç»§æ‰¿æˆ–å¤šç»§æ‰¿
  * Java/C#ä¸­æ²¡æœ‰å¤šç»§æ‰¿ï¼ŒC++ä¸­ä¹Ÿåº”é¿å…ä½¿ç”¨
  * å½“ä¸¤ä¸ªçˆ¶ç±»æœ‰åŒæ ·çš„æˆå‘˜æ—¶ä¼šå¸¦æ¥æ¨¡ç³Šæ€§ï¼Œè¿™æ ·å¯¼è‡´äº†åç§°å†²çª(name collision)ï¼Œåœ¨ç¼–è¯‘æ—¶å°†äºˆä»¥æ‹’ç»ï¼Œä¹Ÿç§°ä¹‹ä¸ºè±å½¢ç»§æ‰¿
  * å¯ä»¥åœ¨æ–¹æ³•å‰è¯´æ˜åŸºç±»ï¼Œæˆ–è€…ç”¨è™šç»§æ‰¿æ¥è§£å†³è±å½¢ç»§æ‰¿é—®é¢˜
  * [å¤šé‡ç»§æ‰¿ - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF)
    * å¤šé‡ç»§æ‰¿å¯ä»¥å¯¼è‡´æŸäº›ä»¤äººæ··æ·†çš„æƒ…å†µï¼Œæ‰€ä»¥å…³äºå®ƒçš„å¥½å¤„ä¸é£é™©ä¹‹é—´å­°è½»å­°é‡å¸¸å¸¸å—äººäº‰è®ºã€‚Javaä½¿ç”¨äº†ä¸€ä¸ªæŠ˜è¡·çš„åŠæ³•ï¼šJavaå…è®¸ä¸€ä¸ªç±»åˆ«ç»§æ‰¿è‡ªå¤šäºä¸€ä¸ªçˆ¶æ¥å£ï¼ˆå¯ä»¥æŒ‡å®šæŸä¸€ä¸ªç±»åˆ«ï¼Œå®ƒç»§æ‰¿äº†æ‰€æœ‰çˆ¶ç±»çš„ç±»å‹ï¼Œå¹¶å¿…é¡»æ‹¥æœ‰æ‰€æœ‰çˆ¶ç±»æ¥å£çš„å¤–éƒ¨å¯è§æ–¹æ³•çš„å…·ä½“å®ç°ï¼Œå¹¶å…è®¸ç¼–è¯‘å™¨å¼ºåˆ¶ä»¥ä¸Šè¦æ±‚ï¼‰ï¼Œä½†åªå¯ä»¥ä»ä¸€ä¸ªçˆ¶ç±»ç»§æ‰¿å®ç°ï¼ˆæ–¹æ³•ä¸æ•°æ®ï¼‰ã€‚å¾®è½¯çš„.NETç¼–ç¨‹è¯­è¨€ï¼Œä¾‹å¦‚C#å’ŒVisual Basic .NETä¹Ÿä½¿ç”¨äº†è¿™ç§æ¥å£çš„åšæ³•ã€‚
  * [Multiple inheritance - Wikipedia](https://en.wikipedia.org/wiki/Multiple_inheritance)
    * Multiple inheritance has been a controversial issue for many years, with opponents pointing to its increased complexity and ambiguity in situations such as the "diamond problem", where it may be ambiguous as to which parent class a particular feature is inherited from if more than one parent class implements same feature. This can be addressed in various ways, including using virtual inheritance. Alternate methods of object composition not based on inheritance such as mixins and traits have also been proposed to address the ambiguity.
    * The "diamond problem" (sometimes referred to as the "Deadly Diamond of Death") is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?
    * For example, in the context of GUI software development, a class Button may inherit from both classes Rectangle (for appearance) and Clickable (for functionality/input handling), and classes Rectangle and Clickable both inherit from the Object class. Now if the equals method is called for a Button object and there is no such method in the Button class but there is an overridden equals method in Rectangle or Clickable (or both), which method should be eventually called?
    * It is called the "diamond problem" because of the shape of the class inheritance diagram in this situation. In this case, class A is at the top, both B and C separately beneath it, and D joins the two together at the bottom to form a diamond shape.
    * Languages have different ways of dealing with these problems of repeated inheritance.
      * C++ by default follows each inheritance path separately, so a D object would actually contain two separate A objects, and uses of A's members have to be properly qualified. If the inheritance from A to B and the inheritance from A to C are both marked "virtual" (for example, "class B : virtual public A"), C++ takes special care to only create one A object, and uses of A's members work correctly. If virtual inheritance and nonvirtual inheritance are mixed, there is a single virtual A, and a nonvirtual A for each nonvirtual inheritance path to A. C++ requires stating explicitly which parent class the feature to be used is invoked from i.e. Worker::Human.Age. C++ does not support explicit repeated inheritance since there would be no way to qualify which superclass to use (i.e. having a class appear more than once in a single derivation list [class Dog : public Animal, Animal]). C++ also allows a single instance of the multiple class to be created via the virtual inheritance mechanism (i.e. Worker::Human and Musician::Human will reference the same object).
      * Java 8 introduces default methods on interfaces. If A,B,C are interfaces, B,C can each provide a different implementation to an abstract method of A, causing the diamond problem. Either class D must reimplement the method (the body of which can simply forward the call to one of the super implementations), or the ambiguity will be rejected as a compile error. Prior to Java 8, Java was not subject to the Diamond problem risk, because it did not support multiple inheritance and interface default methods were not available.
      * Python has the same structure as Perl, but, unlike Perl, includes it in the syntax of the language. The order of inheritance affects the class semantics. Python had to deal with this upon the introduction of new-style classes, all of which have a common ancestor, object. Python creates a list of classes using the C3 linearization (or Method Resolution Order (MRO)) algorithm. That algorithm enforces two constraints: children precede their parents and if a class inherits from multiple classes, they are kept in the order specified in the tuple of base classes (however in this case, some classes high in the inheritance graph may precede classes lower in the graph). Thus, the method resolution order is: D, B, C, A.
    * Nevertheless, even when several interfaces declare the same method signature, as soon as that method is implemented (defined) anywhere in the inheritance chain, it overrides any implementation of that method in the chain above it (in its superclasses). Hence, at any given level in the inheritance chain, there can be at most one implementation of any method. Thus, single-inheritance method implementation does not exhibit the Diamond Problem even with multiple-inheritance of interfaces. With the introduction of default implementation for interfaces in Java 8 and C# 8, it is still possible to generate a Diamond Problem, although this will only appear as a compile-time error.
* è™šç»§æ‰¿
  * [è™šç»§æ‰¿ - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E8%99%9A%E7%BB%A7%E6%89%BF)
    * è™šç»§æ‰¿ æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­çš„ä¸€ç§æŠ€æœ¯ï¼Œæ˜¯æŒ‡ä¸€ä¸ªæŒ‡å®šçš„åŸºç±»ï¼Œåœ¨ç»§æ‰¿ä½“ç³»ç»“æ„ä¸­ï¼Œå°†å…¶æˆå‘˜æ•°æ®å®ä¾‹å…±äº«ç»™ä¹Ÿä»è¿™ä¸ªåŸºç±»å‹ç›´æ¥æˆ–é—´æ¥æ´¾ç”Ÿçš„å…¶å®ƒç±»ã€‚
    * ä¸¾ä¾‹æ¥è¯´ï¼šå‡å¦‚ç±»Aå’Œç±»Bå„è‡ªä»ç±»Xæ´¾ç”Ÿï¼ˆéè™šç»§æ‰¿ä¸”å‡è®¾ç±»XåŒ…å«ä¸€äº›æ•°æ®æˆå‘˜ï¼‰ï¼Œä¸”ç±»CåŒæ—¶å¤šç»§æ‰¿è‡ªç±»Aå’ŒBï¼Œé‚£ä¹ˆCçš„å¯¹è±¡å°±ä¼šæ‹¥æœ‰ä¸¤å¥—Xçš„å®ä¾‹æ•°æ®ï¼ˆå¯åˆ†åˆ«ç‹¬ç«‹è®¿é—®ï¼Œä¸€èˆ¬è¦ç”¨é€‚å½“çš„æ¶ˆæ­§ä¹‰é™å®šç¬¦ï¼‰ã€‚ä½†æ˜¯å¦‚æœç±»Aä¸Bå„è‡ªè™šç»§æ‰¿äº†ç±»Xï¼Œé‚£ä¹ˆCçš„å¯¹è±¡å°±åªåŒ…å«ä¸€å¥—ç±»Xçš„å®ä¾‹æ•°æ®ã€‚å¯¹äºè¿™ä¸€æ¦‚å¿µå…¸å‹å®ç°çš„ç¼–ç¨‹è¯­è¨€æ˜¯C++ã€‚
    * è¿™ä¸€ç‰¹æ€§åœ¨å¤šé‡ç»§æ‰¿åº”ç”¨ä¸­éå¸¸æœ‰ç”¨ï¼Œå¯ä»¥ä½¿å¾—è™šåŸºç±»å¯¹äºç”±å®ƒç›´æ¥æˆ–é—´æ¥æ´¾ç”Ÿçš„ç±»æ¥è¯´ï¼Œæ‹¥æœ‰ä¸€ä¸ªå…±åŒçš„åŸºç±»å¯¹è±¡å®ä¾‹ã€‚é¿å…ç”±äºå¸¦æœ‰æ­§ä¹‰çš„ç»„åˆè€Œäº§ç”Ÿçš„é—®é¢˜ï¼ˆå¦‚â€œè±å½¢ç»§æ‰¿é—®é¢˜â€ï¼‰ã€‚å…¶åŸç†æ˜¯ï¼Œé—´æ¥æ´¾ç”Ÿç±»ï¼ˆCï¼‰ç©¿é€äº†å…¶çˆ¶ç±»ï¼ˆä¸Šé¢ä¾‹å­ä¸­çš„Aä¸Bï¼‰ï¼Œå®è´¨ä¸Šç›´æ¥ç»§æ‰¿äº†è™šåŸºç±»Xã€‚
    * è¿™ä¸€æ¦‚å¿µä¸€èˆ¬ç”¨äºâ€œç»§æ‰¿â€åœ¨è¡¨ç°ä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè€Œéå‡ ä¸ªéƒ¨åˆ†çš„ç»„åˆæ—¶ã€‚åœ¨C++ä¸­ï¼ŒåŸºç±»å¯ä»¥é€šè¿‡ä½¿ç”¨å…³é”®å­—virtualæ¥å£°æ˜è™šç»§æ‰¿å…³ç³»ã€‚
    * è™šåŸºç±»çš„åˆå§‹åŒ–
      * ç”±äºè™šåŸºç±»æ˜¯å¤šä¸ªæ´¾ç”Ÿç±»å…±äº«çš„åŸºç±»ï¼Œå› æ­¤ç”±è°æ¥åˆå§‹åŒ–è™šåŸºç±»å¿…é¡»æ˜ç¡®ã€‚C++æ ‡å‡†è§„å®šï¼Œç”±æœ€æ´¾ç”Ÿç±»ç›´æ¥åˆå§‹åŒ–è™šåŸºç±»ã€‚å› æ­¤ï¼Œå¯¹é—´æ¥ç»§æ‰¿äº†è™šåŸºç±»çš„ç±»ï¼Œä¹Ÿå¿…é¡»èƒ½ç›´æ¥è®¿é—®å…¶è™šç»§æ‰¿æ¥çš„ç¥–å…ˆç±»ï¼Œä¹Ÿå³åº”çŸ¥é“å…¶è™šç»§æ‰¿æ¥çš„ç¥–å…ˆç±»çš„åœ°å€åç§»å€¼ã€‚
      * ä¾‹å¦‚ï¼Œå¸¸è§çš„â€œè±å½¢â€è™šç»§æ‰¿ä¾‹å­ä¸­ï¼Œä¸¤ä¸ªæ´¾ç”Ÿç±»ã€ä¸€ä¸ªæœ€æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°çš„åˆå§‹åŒ–åˆ—è¡¨ä¸­éƒ½å¯ä»¥ç»™å‡ºè™šåŸºç±»çš„åˆå§‹åŒ–ï¼›ä½†åªç”±æœ€æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°å®é™…æ‰§è¡Œè™šåŸºç±»çš„åˆå§‹åŒ–ã€‚
    * è™šç»§æ‰¿çš„åº”ç”¨ï¼šä¸å¯æ´¾ç”Ÿçš„finallyç±»
      * ä¸€ä¸ªç±»å¦‚æœä¸å¸Œæœ›è¢«ç»§æ‰¿ï¼Œç±»ä¼¼äºJavaä¸­çš„å…·æœ‰finallyæ€§è´¨çš„ç±»ï¼Œè¿™åœ¨C++ä¸­å¯ä»¥ç”¨è™šç»§æ‰¿æ¥å®ç°ï¼š
      ```c++
      template<typename T> class MakeFinally{
         private:
             MakeFinally(){};//åªæœ‰MakeFinallyçš„å‹ç±»æ‰å¯ä»¥æ„é€ MakeFinally
             ~MakeFinally(){};
         friend T;
      };

      class MyClass:public virtual  MakeFinally<MyClass>{};//MyClassæ˜¯ä¸å¯æ´¾ç”Ÿç±»

      //ç”±äºè™šç»§æ‰¿ï¼Œæ‰€ä»¥Dè¦ç›´æ¥è´Ÿè´£æ„é€ MakeFinallyç±»ï¼Œä»è€Œå¯¼è‡´ç¼–è¯‘æŠ¥é”™ï¼Œæ‰€ä»¥Dä½œä¸ºæ´¾ç”Ÿç±»æ˜¯ä¸åˆæ³•çš„ã€‚
      class D: public MyClass{};
      //å¦å¤–ï¼Œå¦‚æœDç±»æ²¡æœ‰å®ä¾‹åŒ–å¯¹è±¡ï¼Œå³æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œå®é™…ä¸ŠDç±»æ˜¯è¢«ç¼–è¯‘å™¨å¿½ç•¥æ‰è€Œä¸æŠ¥é”™


      int main()
      {
      MyClass var1;
      // D var2;  //è¿™ä¸€è¡Œç¼–è¯‘å°†å¯¼è‡´é”™è¯¯ï¼Œå› ä¸ºDç±»çš„é»˜è®¤æ„é€ å‡½æ•°ä¸åˆæ³•
      }
      ```
  * [Virtual inheritance - Wikipedia](https://en.wikipedia.org/wiki/Virtual_inheritance)
    * This example to illustrates a case where base class A has a constructor variable msg and an additional ancestor E is derived from grandchild class D.
    * Here, A must be constructed in both D and E. Further, inspection of the variable msg illustrates the how class A becomes a direct base class of its deriving class, as opposed to a base class of any intermediate deriving classed between A and the final deriving class.
    ```c++
    #include <string>
    #include <iostream>

    class A                     {
        private:
            std::string _msg;
        public:
            A(std::string x): _msg(x) {}
            void test(){ std::cout<<"hello from A: "<<_msg <<"\n"; }
    };

    // B,C inherit A virtually
    class B: virtual public A   { public: B(std::string x):A("b"){}  };
    class C: virtual public A   { public: C(std::string x):A("c"){}  };

    // since B,C inherit A virtually, A must be constructed in each child
    class D: public         B,C { public: D(std::string x):A("d_a"),B("d_b"),C("d_c"){}  };
    class E: public         D   { public: E(std::string x):A("e_a"),D("e_d"){}  };

    // breaks without constructing A
    // class D: public         B,C { public: D(std::string x):B(x),C(x){}  };

    // breaks without constructing A
    //class E: public         D   { public: E(std::string x):D(x){}  };


    int main(int argc, char ** argv){
        D d("d");
        d.test(); // hello from A: d_a

        E e("e");
        e.test(); // hello from A: e_a
    }    
    ```
  * è™šç»§æ‰¿ç”¨äºè§£å†³å¤šç»§æ‰¿æ¡ä»¶ä¸‹çš„è±å½¢ç»§æ‰¿é—®é¢˜ï¼ˆæµªè´¹å­˜å‚¨ç©ºé—´ã€å­˜åœ¨äºŒä¹‰æ€§ï¼‰ã€‚
  * åº•å±‚å®ç°åŸç†ä¸ç¼–è¯‘å™¨ç›¸å…³ï¼Œä¸€èˆ¬é€šè¿‡è™šåŸºç±»æŒ‡é’ˆå’Œè™šåŸºç±»è¡¨å®ç°ï¼Œæ¯ä¸ªè™šç»§æ‰¿çš„å­ç±»éƒ½æœ‰ä¸€ä¸ªè™šåŸºç±»æŒ‡é’ˆï¼ˆå ç”¨ä¸€ä¸ªæŒ‡é’ˆçš„å­˜å‚¨ç©ºé—´ï¼Œ4å­—èŠ‚ï¼‰å’Œè™šåŸºç±»è¡¨ï¼ˆä¸å ç”¨ç±»å¯¹è±¡çš„å­˜å‚¨ç©ºé—´ï¼‰ï¼ˆéœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œè™šåŸºç±»ä¾æ—§ä¼šåœ¨å­ç±»é‡Œé¢å­˜åœ¨æ‹·è´ï¼Œåªæ˜¯ä»…ä»…æœ€å¤šå­˜åœ¨ä¸€ä»½è€Œå·²ï¼Œå¹¶ä¸æ˜¯ä¸åœ¨å­ç±»é‡Œé¢äº†ï¼‰ï¼›å½“è™šç»§æ‰¿çš„å­ç±»è¢«å½“åšçˆ¶ç±»ç»§æ‰¿æ—¶ï¼Œè™šåŸºç±»æŒ‡é’ˆä¹Ÿä¼šè¢«ç»§æ‰¿ã€‚
  * å®é™…ä¸Šï¼Œvbptr æŒ‡çš„æ˜¯è™šåŸºç±»è¡¨æŒ‡é’ˆï¼ˆvirtual base table pointerï¼‰ï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘äº†ä¸€ä¸ªè™šåŸºç±»è¡¨ï¼ˆvirtual tableï¼‰ï¼Œè™šè¡¨ä¸­è®°å½•äº†è™šåŸºç±»ä¸æœ¬ç±»çš„åç§»åœ°å€ï¼›é€šè¿‡åç§»åœ°å€ï¼Œè¿™æ ·å°±æ‰¾åˆ°äº†è™šåŸºç±»æˆå‘˜ï¼Œè€Œè™šç»§æ‰¿ä¹Ÿä¸ç”¨åƒæ™®é€šå¤šç»§æ‰¿é‚£æ ·ç»´æŒç€å…¬å…±åŸºç±»ï¼ˆè™šåŸºç±»ï¼‰çš„ä¸¤ä»½åŒæ ·çš„æ‹·è´ï¼ŒèŠ‚çœäº†å­˜å‚¨ç©ºé—´ã€‚
* è±å½¢ç»§æ‰¿
  * The "diamond problem" (sometimes referred to as the "Deadly Diamond of Death") is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?
```c++
#include <iostream>
using namespace std;

class A
{
public:
    virtual void fun() { cout << "A::fun()" << endl; }
};

class B : public A
{
public:
    virtual void fun() { cout << "B::fun()" << endl; }
};

class C : public A
{
public:
    virtual void fun() { cout << "C::fun()" << endl; }
};

// Two classes virtually inheriting A
class BB : virtual public A
{
public:
    virtual void fun() { cout << "BB::fun()" << endl; }
};

class CC : virtual public A
{
public:
    virtual void fun() { cout << "CC::fun()" << endl; }
};

class D : public B, public C
{
public:
    void fun() { cout << "D::fun()" << endl; }
};

// class DD : public BB, public CC // Compile error : virtual function 'A::fun' has more than one final overrider in 'DD'
// {
// };

class DDD : public BB, public CC
{
public:
    void fun() { cout << "DDD::fun()" << endl; }
};

int main()
{
    // A *p1 = new D(); // Compile error : ambiguous conversion from derived class 'D' to base class 'A'

    // A *pDD = new DD(); // Compile error : cannot initialize a variable of type 'A *' with an rvalue of type 'DD *'

    A *pDDD = new DDD();
    pDDD->fun();  // DDD::fun() è°ƒç”¨æ´¾ç”Ÿç±»ä¸­çš„è™šå‡½æ•°

    DDD ddd;
    A &a = ddd;
    a.fun();    // DDD::fun() è°ƒç”¨æ´¾ç”Ÿç±»ä¸­çš„è™šå‡½æ•°

    return 0;
}
```
* å¤šæ€
  * [å¤šæ€ (è®¡ç®—æœºç§‘å­¦) - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%80%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))
  * [Polymorphism (computer science) - Wikipedia](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
    * åœ¨ç¼–ç¨‹è¯­è¨€å’Œç±»å‹è®ºä¸­ï¼Œå¤šæ€ï¼ˆè‹±è¯­ï¼špolymorphismï¼‰æŒ‡ä¸ºä¸åŒæ•°æ®ç±»å‹çš„å®ä½“æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œæˆ–ä½¿ç”¨ä¸€ä¸ªå•ä¸€çš„ç¬¦å·æ¥è¡¨ç¤ºå¤šä¸ªä¸åŒçš„ç±»å‹ã€‚
    * å¤šæ€çš„æœ€å¸¸è§ä¸»è¦ç±»åˆ«æœ‰ï¼š
      * ç‰¹è®¾å¤šæ€(Ad hoc polymorphism)ï¼šä¸ºä¸ªä½“çš„ç‰¹å®šç±»å‹çš„ä»»æ„é›†åˆå®šä¹‰ä¸€ä¸ªå…±åŒæ¥å£ã€‚
      * å‚æ•°å¤šæ€(Parametric polymorphism)ï¼šæŒ‡å®šä¸€ä¸ªæˆ–å¤šä¸ªç±»å‹ä¸é åå­—è€Œæ˜¯é å¯ä»¥æ ‡è¯†ä»»ä½•ç±»å‹çš„æŠ½è±¡ç¬¦å·ã€‚
      * å­ç±»å‹(Subtyping)ï¼ˆä¹Ÿå«åšå­ç±»å‹å¤šæ€æˆ–åŒ…å«å¤šæ€ï¼‰ï¼šä¸€ä¸ªåå­—æŒ‡ç§°å¾ˆå¤šä¸åŒçš„ç±»çš„å®ä¾‹ï¼Œè¿™äº›ç±»æœ‰æŸä¸ªå…±åŒçš„è¶…ç±»ã€‚
    * â€œç‰¹è®¾å¤šæ€â€æ¥æŒ‡ç§°ä¸€ä¸ªå¤šæ€å‡½æ•°å¯ä»¥åº”ç”¨äºæœ‰ä¸åŒç±»å‹çš„å®é™…å‚æ•°ä¸Šï¼Œä½†æ˜¯ä»¥æ¥å®ƒä»¬æ‰€åº”ç”¨åˆ°çš„å®é™…å‚æ•°ç±»å‹è€Œæœ‰ä¸åŒçš„è¡¨ç°ï¼ˆä¹Ÿå«åšä¸ºå‡½æ•°é‡è½½æˆ–è¿ç®—ç¬¦é‡è½½ï¼‰
    * å‚æ•°å¤šæ€å…è®¸å‡½æ•°æˆ–æ•°æ®ç±»å‹è¢«ä¸€èˆ¬æ€§çš„ä¹¦å†™ï¼Œä»è€Œå®ƒå¯ä»¥â€œç»Ÿä¸€â€çš„å¤„ç†å€¼è€Œä¸ç”¨ä¾èµ–äºå®ƒä»¬çš„ç±»å‹ã€‚å‚æ•°å¤šæ€æ˜¯ä½¿è¯­è¨€æ›´åŠ æœ‰è¡¨ç°åŠ›è€Œä»ç»´æŒå®Œå…¨çš„é™æ€ç±»å‹å®‰å…¨çš„ä¸€ç§æ–¹å¼ã€‚è¿™ç§å‡½æ•°å’Œæ•°æ®ç±»å‹è¢«åˆ†åˆ«ç§°ä¸ºâ€œæ³›åŒ–å‡½æ•°â€å’Œâ€œæ³›åŒ–æ•°æ®ç±»å‹â€ä»è€Œå½¢æˆäº†æ³›å‹ç¼–ç¨‹çš„åŸºç¡€ã€‚
    * å­ç±»å‹
      * åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼Œè®¡ç®—æœºç¨‹åºè¿è¡Œæ—¶ï¼Œç›¸åŒçš„æ¶ˆæ¯å¯èƒ½ä¼šé€ç»™å¤šä¸ªä¸åŒçš„ç±»åˆ«ä¹‹å¯¹è±¡ï¼Œè€Œç³»ç»Ÿå¯ä¾æ®å¯¹è±¡æ‰€å±ç±»åˆ«ï¼Œå¼•å‘å¯¹åº”ç±»åˆ«çš„æ–¹æ³•ï¼Œè€Œæœ‰ä¸åŒçš„è¡Œä¸ºã€‚ç®€å•æ¥è¯´ï¼Œæ‰€è°“å¤šæ€æ„æŒ‡ç›¸åŒçš„æ¶ˆæ¯ç»™äºˆä¸åŒçš„å¯¹è±¡ä¼šå¼•å‘ä¸åŒçš„åŠ¨ä½œã€‚æ¯”å¦‚æœ‰åŠ¨ç‰©ä¹‹ç±»åˆ«ï¼Œè€Œä¸”ç”±åŠ¨ç‰©ç»§æ‰¿å‡ºç±»åˆ«çŒ«å’Œç±»åˆ«ç‹—ï¼Œå¹¶å¯¹åŒä¸€æºè‡ªç±»åˆ«åŠ¨ç‰©ï¼ˆçˆ¶ç±»ï¼‰ä¹‹ä¸€æ¶ˆæ¯æœ‰ä¸åŒçš„å“åº”ï¼Œå¦‚ç±»åˆ«åŠ¨ç‰©æœ‰â€œå«â€ä¹‹åŠ¨ä½œï¼Œè€Œç±»åˆ«çŒ«ä¼šâ€œå–µå–µâ€ï¼Œç±»åˆ«ç‹—åˆ™ä¼šâ€œæ±ªæ±ªâ€ï¼Œåˆ™ç§°ä¹‹ä¸ºå¤šæ€ã€‚
      * å¤šæ€å¯åˆ†ä¸ºå˜é‡å¤šæ€ä¸å‡½æ•°å¤šæ€ã€‚å˜é‡å¤šæ€æ˜¯æŒ‡ï¼šåŸºç±»å‹çš„å˜é‡ï¼ˆå¯¹äºC++æ˜¯å¼•ç”¨æˆ–æŒ‡é’ˆï¼‰å¯ä»¥è¢«èµ‹å€¼åŸºç±»å‹å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥è¢«èµ‹å€¼æ´¾ç”Ÿç±»å‹çš„å¯¹è±¡ã€‚å‡½æ•°å¤šæ€æ˜¯æŒ‡ï¼Œç›¸åŒçš„å‡½æ•°è°ƒç”¨ç•Œé¢ï¼ˆå‡½æ•°åä¸å®å‚è¡¨ï¼‰ï¼Œä¼ é€ç»™ä¸€ä¸ªå¯¹è±¡å˜é‡ï¼Œå¯ä»¥æœ‰ä¸åŒçš„è¡Œä¸ºï¼Œè¿™è§†è¯¥å¯¹è±¡å˜é‡æ‰€æŒ‡å‘çš„å¯¹è±¡ç±»å‹è€Œå®šã€‚å¤šæ€ä¹Ÿå¯å®šä¹‰ä¸ºâ€œä¸€ç§å°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”çš„èƒ½åŠ›â€ï¼Œå˜é‡å¤šæ€æ˜¯å‡½æ•°å¤šæ€çš„åŸºç¡€ã€‚
    * ä¾æ®å®ç°æ—¶åšå‡ºçš„é€‰æ‹©ï¼Œå¤šæ€å¯åˆ†ä¸ºï¼š
      * åŠ¨æ€å¤šæ€ï¼ˆdynamic polymorphismï¼‰:ç”Ÿæ•ˆäºè¿è¡ŒæœŸã€‚
      * é™æ€å¤šæ€ï¼ˆstatic polymorphismï¼‰ï¼šå°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”ï¼Œç”±äºè¿™ç§å…³è”å¤„ç†äºç¼–è¯‘æœŸè€Œéè¿è¡ŒæœŸï¼Œå› æ­¤è¢«ç§°ä¸ºâ€œé™æ€â€ã€‚å¯ä»¥ç”¨æ¥å®ç°ç±»å‹å®‰å…¨ã€è¿è¡Œé«˜æ•ˆçš„åŒè´¨å¯¹è±¡é›†åˆæ“ä½œã€‚C++ STLä¸é‡‡ç”¨åŠ¨æ€å¤šæ€æ¥å®ç°å°±æ˜¯ä¸ªä¾‹å­ã€‚
    * å¯¹äºC++è¯­è¨€ï¼Œå¸¦å˜é‡çš„å®å’Œå‡½æ•°é‡è½½æœºåˆ¶ä¹Ÿå…è®¸å°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”ã€‚ç„¶è€Œï¼Œä¹ æƒ¯ä¸Šå¹¶ä¸å°†è¿™ç§å‡½æ•°å¤šæ€ã€å®å¤šæ€å±•ç°å‡ºæ¥çš„è¡Œä¸ºç§°ä¸ºå¤šæ€ï¼ˆæˆ–é™æ€å¤šæ€ï¼‰ï¼Œå¦åˆ™å°±è¿Cè¯­è¨€ä¹Ÿå…·æœ‰å®å¤šæ€äº†ã€‚è°ˆåŠå¤šæ€æ—¶ï¼Œé»˜è®¤å°±æ˜¯æŒ‡åŠ¨æ€å¤šæ€ï¼Œè€Œé™æ€å¤šæ€åˆ™æ˜¯æŒ‡åŸºäºæ¨¡æ¿çš„å¤šæ€ã€‚
  * ä»€ä¹ˆæ˜¯å¤šæ€ï¼Ÿå¤šæ€å¦‚ä½•å®ç°ï¼Ÿ
    * å¤šæ€ï¼šå¤šæ€å°±æ˜¯ä¸åŒç»§æ‰¿ç±»çš„å¯¹è±¡ï¼Œå¯¹åŒä¸€æ¶ˆæ¯åšå‡ºä¸åŒçš„å“åº”ï¼ŒåŸºç±»çš„æŒ‡é’ˆæŒ‡å‘æˆ–ç»‘å®šåˆ°æ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œä½¿å¾—åŸºç±»æŒ‡é’ˆå‘ˆç°ä¸åŒçš„è¡¨ç°æ–¹å¼ã€‚åœ¨åŸºç±»çš„å‡½æ•°å‰åŠ ä¸Š virtual å…³é”®å­—ï¼Œåœ¨æ´¾ç”Ÿç±»ä¸­é‡å†™è¯¥å‡½æ•°ï¼Œè¿è¡Œæ—¶å°†ä¼šæ ¹æ®å¯¹è±¡çš„å®é™…ç±»å‹æ¥è°ƒç”¨ç›¸åº”çš„å‡½æ•°ã€‚å¦‚æœå¯¹è±¡ç±»å‹æ˜¯æ´¾ç”Ÿç±»ï¼Œå°±è°ƒç”¨æ´¾ç”Ÿç±»çš„å‡½æ•°ï¼›å¦‚æœå¯¹è±¡ç±»å‹æ˜¯åŸºç±»ï¼Œå°±è°ƒç”¨åŸºç±»çš„å‡½æ•°ã€‚
    * å®ç°æ–¹æ³•ï¼šå¤šæ€æ˜¯é€šè¿‡è™šå‡½æ•°å®ç°çš„ï¼Œè™šå‡½æ•°çš„åœ°å€ä¿å­˜åœ¨è™šå‡½æ•°è¡¨ä¸­ï¼Œè™šå‡½æ•°è¡¨çš„åœ°å€ä¿å­˜åœ¨å«æœ‰è™šå‡½æ•°çš„ç±»çš„å®ä¾‹å¯¹è±¡çš„å†…å­˜ç©ºé—´ä¸­ã€‚
    * å®ç°è¿‡ç¨‹ï¼š
      * åœ¨ç±»ä¸­ç”¨ virtual å…³é”®å­—å£°æ˜çš„å‡½æ•°å«åšè™šå‡½æ•°ï¼›
      * å­˜åœ¨è™šå‡½æ•°çš„ç±»éƒ½æœ‰ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œå½“åˆ›å»ºä¸€ä¸ªè¯¥ç±»çš„å¯¹è±¡æ—¶ï¼Œè¯¥å¯¹è±¡æœ‰ä¸€ä¸ªæŒ‡å‘è™šå‡½æ•°è¡¨çš„è™šè¡¨æŒ‡é’ˆï¼ˆè™šå‡½æ•°è¡¨å’Œç±»å¯¹åº”çš„ï¼Œè™šè¡¨æŒ‡é’ˆæ˜¯å’Œå¯¹è±¡å¯¹åº”ï¼‰ï¼›
      * å½“åŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ï¼ŒåŸºç±»æŒ‡é’ˆè°ƒç”¨è™šå‡½æ•°æ—¶ï¼ŒåŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»çš„è™šè¡¨æŒ‡é’ˆï¼Œç”±äºè¯¥è™šè¡¨æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»è™šå‡½æ•°è¡¨ï¼Œé€šè¿‡éå†è™šè¡¨ï¼Œå¯»æ‰¾ç›¸åº”çš„è™šå‡½æ•°ã€‚

## ç±»ç›¸å…³

* è™šå‡½æ•°
  * [è™šå‡½æ•° - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E8%99%9A%E5%87%BD%E6%95%B0)
  * åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡é¢†åŸŸï¼ŒC++ã€Object Pascal ç­‰è¯­è¨€ä¸­æœ‰è™šå‡½æ•°ï¼ˆè‹±è¯­ï¼švirtual functionï¼‰æˆ–è™šæ–¹æ³•ï¼ˆè‹±è¯­ï¼švirtual methodï¼‰çš„æ¦‚å¿µã€‚è¿™ç§å‡½æ•°æˆ–æ–¹æ³•å¯ä»¥è¢«å­ç±»ç»§æ‰¿å’Œè¦†ç›–ï¼Œé€šå¸¸ä½¿ç”¨åŠ¨æ€åˆ†æ´¾å®ç°ã€‚è¿™ä¸€æ¦‚å¿µæ˜¯é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼ˆè¿è¡Œæ—¶ï¼‰å¤šæ€çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚ç®€è¨€ä¹‹ï¼Œè™šå‡½æ•°å¯ä»¥ç»™å‡ºç›®æ ‡å‡½æ•°çš„å®šä¹‰ï¼Œä½†è¯¥ç›®æ ‡çš„å…·ä½“æŒ‡å‘åœ¨ç¼–è¯‘æœŸå¯èƒ½æ— æ³•ç¡®å®šã€‚
  * è™šå‡½æ•°åœ¨è®¾è®¡æ¨¡å¼æ–¹é¢æ‰®æ¼”é‡è¦è§’è‰²ã€‚ä¾‹å¦‚ï¼Œã€Šè®¾è®¡æ¨¡å¼ã€‹ä¸€ä¹¦ä¸­æåˆ°çš„23ç§è®¾è®¡æ¨¡å¼ä¸­ï¼Œä»…5ä¸ªå¯¹è±¡åˆ›å»ºæ¨¡å¼å°±æœ‰4ä¸ªç”¨åˆ°äº†è™šå‡½æ•°ï¼ˆæŠ½è±¡å·¥å‚ã€å·¥å‚æ–¹æ³•ã€ç”Ÿæˆå™¨ã€åŸå‹ï¼‰ï¼Œåªæœ‰å•ä¾‹æ²¡æœ‰ç”¨åˆ°ã€‚
  * è™šå‡½æ•°æ¦‚å¿µçš„å¼•å…¥å¯ä»¥è§£å†³è¿™æ ·çš„é—®é¢˜ï¼š
    * åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼Œæ´¾ç”Ÿç±»ç»§æ‰¿è‡ªåŸºç±»ã€‚ä½¿ç”¨æŒ‡é’ˆæˆ–å¼•ç”¨è®¿é—®æ´¾ç”Ÿç±»å¯¹è±¡æ—¶ï¼ŒæŒ‡é’ˆæˆ–å¼•ç”¨æœ¬èº«æ‰€æŒ‡å‘çš„ç±»å‹æ˜¯åŸºç±»è€Œä¸æ˜¯æ´¾ç”Ÿç±»ã€‚å¦‚æœæ´¾ç”Ÿç±»è¦†ç›–äº†åŸºç±»ä¸­çš„æ–¹æ³•ï¼Œé€šè¿‡ä¸Šè¿°æŒ‡é’ˆæˆ–å¼•ç”¨è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œå¯ä»¥æœ‰ä¸¤ç§ç»“æœï¼š
      * è°ƒç”¨åˆ°åŸºç±»çš„æ–¹æ³•ï¼šç¼–è¯‘å™¨æ ¹æ®æŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹å†³å®šï¼Œç§°ä½œâ€œæ—©ç»‘å®šâ€ï¼›
      * è°ƒç”¨åˆ°æ´¾ç”Ÿç±»çš„æ–¹æ³•ï¼šè¯­è¨€çš„è¿è¡Œæ—¶ç³»ç»Ÿæ ¹æ®å¯¹è±¡çš„å®é™…ç±»å‹å†³å®šï¼Œç§°ä½œâ€œè¿Ÿç»‘å®šâ€ã€‚
    * è™šå‡½æ•°çš„æ•ˆæœå±äºåè€…ã€‚å¦‚æœé—®é¢˜ä¸­åŸºç±»çš„å‡½æ•°æ˜¯â€œè™šâ€çš„ï¼Œåˆ™è°ƒç”¨åˆ°çš„éƒ½æ˜¯æœ€ç»ˆæ´¾ç”Ÿç±»ï¼ˆè‹±è¯­ï¼šmost-derived classï¼‰ä¸­çš„å‡½æ•°å®ç°ï¼Œä¸æŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹æ— å…³ã€‚åä¹‹ï¼Œå¦‚æœå‡½æ•°éâ€œè™šâ€ï¼Œè°ƒç”¨åˆ°çš„å‡½æ•°å°±åœ¨ç¼–è¯‘æœŸæ ¹æ®æŒ‡é’ˆæˆ–è€…å¼•ç”¨æ‰€æŒ‡å‘çš„ç±»å‹å†³å®šã€‚
    * æœ‰äº†è™šå‡½æ•°ï¼Œç¨‹åºç”šè‡³èƒ½å¤Ÿè°ƒç”¨ç¼–è¯‘æœŸè¿˜ä¸å­˜åœ¨çš„å‡½æ•°ã€‚
    * åœ¨ C++ ä¸­ï¼Œåœ¨åŸºç±»çš„æˆå‘˜å‡½æ•°å£°æ˜å‰åŠ ä¸Šå…³é”®å­— virtual å³å¯è®©è¯¥å‡½æ•°æˆä¸º è™šå‡½æ•°ï¼Œæ´¾ç”Ÿç±»ä¸­å¯¹æ­¤å‡½æ•°çš„ä¸åŒå®ç°éƒ½ä¼šç»§æ‰¿è¿™ä¸€ä¿®é¥°ç¬¦ï¼Œå…è®¸åç»­æ´¾ç”Ÿç±»è¦†ç›–ï¼Œè¾¾åˆ°è¿Ÿç»‘å®šçš„æ•ˆæœã€‚å³ä¾¿æ˜¯åŸºç±»ä¸­çš„æˆå‘˜å‡½æ•°è°ƒç”¨è™šå‡½æ•°ï¼Œä¹Ÿä¼šè°ƒç”¨åˆ°æ´¾ç”Ÿç±»ä¸­çš„ç‰ˆæœ¬ã€‚
  ```c++
  # include <iostream>
  # include <vector>

  using namespace std;
  class Animal
  {
  public:
      // void eat() const { cout << "I eat like a generic Animal." << endl; }
      // ~Animal() {}
      virtual void eat() const { cout << "I eat like a generic Animal." << endl; }
      virtual ~Animal() {}
  };

  class Wolf : public Animal
  {
  public:
      void eat() const { cout << "I eat like a wolf!" << endl; }
  };

  class Fish : public Animal
  {
  public:
      void eat() const { cout << "I eat like a fish!" << endl; }
  };

  class GoldFish : public Fish
  {
  public:
      void eat() const { cout << "I eat like a goldfish!" << endl; }
  };


  class OtherAnimal : public Animal
  {
  };

  int main()
  {
      std::vector<Animal*> animals;
      animals.push_back( new Animal() );
      animals.push_back( new Wolf() );
      animals.push_back( new Fish() );
      animals.push_back( new GoldFish() );
      animals.push_back( new OtherAnimal() );

      /*
      ä»¥ä¸‹æ˜¯è™šå‡½æ•° Animal::eat() çš„è¾“å‡ºï¼š
      I eat like a generic Animal.
      I eat like a wolf!
      I eat like a fish!
      I eat like a goldfish!
      I eat like a generic Animal.

      å½“ Animal::eat() ä¸æ˜¯è¢«å®£å‘Šä¸ºè™šå‡½æ•°æ—¶ï¼Œè¾“å‡ºå¦‚ä¸‹æ‰€ç¤ºï¼š
      I eat like a generic Animal.
      I eat like a generic Animal.
      I eat like a generic Animal.
      I eat like a generic Animal.
      I eat like a generic Animal.
      */
      for( std::vector<Animal*>::const_iterator it = animals.begin();
         it != animals.end(); ++it)
      {
          (*it)->eat();
          delete *it;
      }

     return 0;
  }   
  ```
  * åœ¨Javaè¯­è¨€ä¸­, æ‰€æœ‰çš„æ–¹æ³•é»˜è®¤éƒ½æ˜¯"è™šå‡½æ•°". åªæœ‰ä»¥å…³é”®å­— final æ ‡è®°çš„æ–¹æ³•æ‰æ˜¯éè™šå‡½æ•°.
  * åœ¨ C# è¯­è¨€ä¸­, å¯¹åŸºç±»ä¸­çš„ä»»ä½•è™šæ–¹æ³•å¿…é¡»ç”¨ virtual ä¿®é¥°, è€Œæ´¾ç”Ÿç±»ä¸­ç”±åŸºç±»ç»§æ‰¿è€Œæ¥çš„é‡è½½æ–¹æ³•å¿…é¡»ç”¨ override ä¿®é¥°.
  * æŠ½è±¡ç±»å’Œçº¯è™šå‡½æ•°
    * çº¯è™šå‡½æ•°æˆ–çº¯è™šæ–¹æ³•æ˜¯ä¸€ä¸ªéœ€è¦è¢«éæŠ½è±¡çš„æ´¾ç”Ÿç±»è¦†ç›–ï¼ˆoverrideï¼‰çš„è™šå‡½æ•°. åŒ…å«çº¯è™šæ–¹æ³•çš„ç±»è¢«ç§°ä½œæŠ½è±¡ç±»; æŠ½è±¡ç±»ä¸èƒ½è¢«ç›´æ¥å®ä¾‹åŒ–ã€‚ ä¸€ä¸ªæŠ½è±¡åŸºç±»çš„ä¸€ä¸ªå­ç±»åªæœ‰åœ¨æ‰€æœ‰çš„çº¯è™šå‡½æ•°åœ¨è¯¥ç±»(æˆ–å…¶çˆ¶ç±»)å†…ç»™å‡ºå®ç°æ—¶, æ‰èƒ½ç›´æ¥å®ä¾‹åŒ–. çº¯è™šæ–¹æ³•é€šå¸¸åªæœ‰å£°æ˜(ç­¾å)è€Œæ²¡æœ‰å®šä¹‰(å®ç°)ï¼Œä½†æœ‰ç‰¹ä¾‹æƒ…å½¢è¦æ±‚çº¯è™šå‡½æ•°å¿…é¡»ç»™å‡ºå‡½æ•°ä½“å®šä¹‰.
    * è™½ç„¶çº¯è™šæ–¹æ³•é€šå¸¸åœ¨å®šä¹‰å®ƒçš„ç±»ä¸­æ²¡æœ‰å®ç°, åœ¨ C++ è¯­è¨€ä¸­, å…è®¸çº¯è™šå‡½æ•°åœ¨å®šä¹‰å®ƒçš„ç±»ä¸­åŒ…å«å…¶å®ç°, è¿™ä¸ºæ´¾ç”Ÿç±»æä¾›äº†å¤‡ç”¨æˆ–é»˜è®¤çš„è¡Œä¸º. C++çš„è™šåŸºç±»çš„è™šææ„å‡½æ•°å¿…é¡»æä¾›å‡½æ•°ä½“å®šä¹‰ï¼Œå¦åˆ™é“¾æ¥æ—¶ï¼ˆlinkingï¼‰åœ¨ææ„è¯¥æŠ½è±¡ç±»çš„æ´¾ç”Ÿå®ä¾‹å¯¹è±¡çš„è¯­å¥å¤„ä¼šæŠ¥é”™ã€‚
    * åœ¨C++è¯­è¨€ä¸­, çº¯è™šå‡½æ•°ç”¨ä¸€ç§ç‰¹åˆ«çš„è¯­æ³•[=0]å®šä¹‰ï¼ˆä½† VS ä¹Ÿæ”¯æŒ abstract å…³é”®å­—ï¼švirtual ReturnType Function()abstract;ï¼‰
    * çº¯è™šå‡½æ•°çš„å®šä¹‰ä»…æä¾›æ–¹æ³•çš„åŸå‹. è™½ç„¶åœ¨æŠ½è±¡ç±»ä¸­é€šå¸¸ä¸æä¾›çº¯è™šå‡½æ•°çš„å®ç°, ä½†æ˜¯æŠ½è±¡ç±»ä¸­å¯ä»¥åŒ…å«å…¶å®ç°, è€Œä¸”å¯ä»¥ä¸åœ¨å£°æ˜çš„åŒæ—¶ç»™å‡ºå®šä¹‰[2]. æ¯ä¸ªéæŠ½è±¡å­ç±»ä»ç„¶éœ€è¦é‡è½½è¯¥æ–¹æ³•, æŠ½è±¡ç±»ä¸­å®ç°çš„è°ƒç”¨å¯ä»¥é‡‡ç”¨ä»¥ä¸‹è¿™ç§å½¢å¼:
  ```c++
  class Abstract {
  public:
     virtual void pure_virtual() = 0;
  };

  void Abstract::pure_virtual() {
     // do something
   }

   class Child : public Abstract {
     virtual void pure_virtual(); // no longer abstract, this class may be
                                  // instantiated.
   };

   void Child::pure_virtual() {
     Abstract::pure_virtual(); // the implementation in the abstract class
                               // is executed
   }   
  ```
  * [Virtual function - Wikipedia](https://en.wikipedia.org/wiki/Virtual_function)
    * Behavior during construction and destruction
      * Languages differ in their behavior while the constructor or destructor of an object is running. For this reason, calling virtual functions in constructors is generally discouraged.
      * In C++, the "base" function is called. Specifically, the most derived function that is not more derived than the current constructor's class is called. If that function is a pure virtual function, then undefined behavior occurs. This is true even if the class contains an implementation for that pure virtual function. A conforming C++ implementation is not required (and generally not able) to detect indirect calls to pure virtual functions at compile time or link time. Some runtime systems will issue a pure virtual function call error when encountering a call to a pure virtual function at run time.
      * In Java and C#, the derived implementation is called, but some fields are not yet initialized by the derived constructor (although they are initialized to their default zero values). Some design patterns, such as the Abstract Factory Pattern, actively promote this usage in languages supporting this ability.
    * Virtual destructors
      * Object-oriented languages typically manage memory allocation and de-allocation automatically when objects are created and destroyed. However, some object-oriented languages allow a custom destructor method to be implemented, if desired. If the language in question uses automatic memory management, the custom destructor (generally called a finalizer in this context) that is called is certain to be the appropriate one for the object in question. For example, if an object of type Wolf that inherits Animal is created, and both have custom destructors, the one called will be the one declared in Wolf.
      * In manual memory management contexts, the situation can be more complex, particularly in relation to static dispatch. If an object of type Wolf is created but pointed to by an Animal pointer, and it is this Animal pointer type that is deleted, the destructor called may actually be the one defined for Animal and not the one for Wolf, unless the destructor is virtual. This is particularly the case with C++, where the behavior is a common source of programming errors if destructors are not virtual.
  * å¦‚æœä½¿ç”¨è™šå‡½æ•°ï¼Œçˆ¶ç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡å¹¶è°ƒç”¨å¯¹è±¡æ–¹æ³•æ—¶ï¼Œä½¿ç”¨çš„æ˜¯å­ç±»çš„æ–¹æ³•;
  * å¦‚æœæœªä½¿ç”¨è™šå‡½æ•°ï¼Œåˆ™æ˜¯æ™®é€šçš„é‡å†™ï¼Œåˆ™çˆ¶ç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡æ—¶ï¼Œä½¿ç”¨çš„æ˜¯çˆ¶ç±»çš„æ–¹æ³•ï¼ˆä¸æŒ‡é’ˆç±»å‹çœ‹é½ï¼‰
  * å¯ä»¥å°†æ´¾ç”Ÿç±»çš„å¯¹è±¡èµ‹å€¼ç»™åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œåä¹‹ä¸å¯
  * æ™®é€šå‡½æ•°ï¼ˆéç±»æˆå‘˜å‡½æ•°ï¼‰ä¸èƒ½æ˜¯è™šå‡½æ•°
  * é™æ€å‡½æ•°ï¼ˆstaticï¼‰ä¸èƒ½æ˜¯è™šå‡½æ•°
  * æ„é€ å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°ï¼ˆå› ä¸ºåœ¨è°ƒç”¨æ„é€ å‡½æ•°æ—¶ï¼Œè™šè¡¨æŒ‡é’ˆå¹¶æ²¡æœ‰åœ¨å¯¹è±¡çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå¿…é¡»è¦æ„é€ å‡½æ•°è°ƒç”¨å®Œæˆåæ‰ä¼šå½¢æˆè™šè¡¨æŒ‡é’ˆï¼‰
  * å†…è”å‡½æ•°ä¸èƒ½æ˜¯è¡¨ç°å¤šæ€æ€§æ—¶çš„è™šå‡½æ•°ï¼Œè§£é‡Šè§ï¼š[è™šå‡½æ•°ï¼ˆvirtualï¼‰å¯ä»¥æ˜¯å†…è”å‡½æ•°ï¼ˆinlineï¼‰å—ï¼Ÿ](https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97)
* Virtualï¼š
  * è™šå‡½æ•°ï¼šæ´¾ç”Ÿç±»å¯ä»¥è¦†ç›–æ‰çš„å‡½æ•°ï¼Œ
  * çº¯è™šå‡½æ•°ï¼šåªæ˜¯ä¸ªç©ºå‡½æ•°ï¼Œæ²¡æœ‰å‡½æ•°å®ç°ä½“ã€‚
* æŠ½è±¡ç±»ï¼šå«æœ‰çº¯è™šå‡½æ•°çš„ç±»
* æŠ½è±¡ç±»èƒ½è¢«å®ä¾‹åŒ–å—
  * ä¸èƒ½ï¼Œåªèƒ½ç»§æ‰¿æŠ½è±¡ç±»ï¼Œå®ç°æŠ½è±¡ç±»çš„å‡½æ•°
* æ¥å£ç±»ï¼šä»…å«æœ‰çº¯è™šå‡½æ•°çš„æŠ½è±¡ç±»
* è™šææ„å‡½æ•°
  * [è™šææ„å‡½æ•°_ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/è™šææ„å‡½æ•°)
    * è™šææ„å‡½æ•°æ˜¯ä¸ºäº†è§£å†³åŸºç±»çš„æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ï¼Œå¹¶ç”¨åŸºç±»çš„æŒ‡é’ˆåˆ é™¤æ´¾ç”Ÿç±»å¯¹è±¡ã€‚
    * å¦‚æœæŸä¸ªç±»ä¸åŒ…å«è™šå‡½æ•°ï¼Œé‚£ä¸€èˆ¬æ˜¯è¡¨ç¤ºå®ƒå°†ä¸ä½œä¸ºä¸€ä¸ªåŸºç±»æ¥ä½¿ç”¨ã€‚å½“ä¸€ä¸ªç±»ä¸å‡†å¤‡ä½œä¸ºåŸºç±»ä½¿ç”¨æ—¶ï¼Œä½¿ææ„å‡½æ•°ä¸ºè™šä¸€èˆ¬æ˜¯ä¸ªåä¸»æ„ã€‚å› ä¸ºå®ƒä¼šä¸ºç±»å¢åŠ ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œä½¿å¾—å¯¹è±¡çš„ä½“ç§¯ç¿»å€ï¼Œè¿˜æœ‰å¯èƒ½é™ä½å…¶å¯ç§»æ¤æ€§
    * æ‰€ä»¥åŸºæœ¬çš„ä¸€æ¡æ˜¯ï¼šæ— æ•…çš„å£°æ˜è™šææ„å‡½æ•°å’Œæ°¸è¿œä¸å»å£°æ˜ä¸€æ ·æ˜¯é”™è¯¯çš„ã€‚å®é™…ä¸Šï¼Œå¾ˆå¤šäººè¿™æ ·æ€»ç»“ï¼šå½“ä¸”ä»…å½“ç±»é‡ŒåŒ…å«è‡³å°‘ä¸€ä¸ªè™šå‡½æ•°çš„æ—¶å€™æ‰å»å£°æ˜è™šææ„å‡½æ•°ã€‚æŠ½è±¡ç±»æ˜¯å‡†å¤‡è¢«ç”¨åšåŸºç±»çš„ï¼ŒåŸºç±»å¿…é¡»è¦æœ‰ä¸€ä¸ªè™šææ„å‡½æ•°ï¼Œçº¯è™šå‡½æ•°ä¼šäº§ç”ŸæŠ½è±¡ç±»ï¼Œæ‰€ä»¥æ–¹æ³•å¾ˆç®€å•ï¼šåœ¨æƒ³è¦æˆä¸ºæŠ½è±¡ç±»çš„ç±»é‡Œå£°æ˜ä¸€ä¸ªçº¯è™šææ„å‡½æ•°ã€‚
  * ææ„å‡½æ•°å®šä¹‰æˆè™šå‡½æ•°æ˜¯ä¸ºäº†é˜²æ­¢å†…å­˜æ³„æ¼ï¼Œå› ä¸ºå½“åŸºç±»çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨æŒ‡å‘æˆ–ç»‘å®šåˆ°æ´¾ç”Ÿç±»çš„å¯¹è±¡æ—¶ï¼Œå¦‚æœæœªå°†åŸºç±»çš„ææ„å‡½æ•°å®šä¹‰æˆè™šå‡½æ•°ï¼Œä¼šè°ƒç”¨åŸºç±»çš„ææ„å‡½æ•°ï¼Œé‚£ä¹ˆåªèƒ½å°†åŸºç±»çš„æˆå‘˜æ‰€å çš„ç©ºé—´é‡Šæ”¾æ‰ï¼Œæ´¾ç”Ÿç±»ä¸­ç‰¹æœ‰çš„å°±ä¼šæ— æ³•é‡Šæ”¾å†…å­˜ç©ºé—´å¯¼è‡´å†…å­˜æ³„æ¼ã€‚
* ä»€ä¹ˆæ˜¯æ‹·è´æ„é€ å‡½æ•°?
  * å®ƒæ˜¯å•ä¸ªå‚æ•°çš„æ„é€ å‡½æ•°ï¼Œå…¶å‚æ•°æ˜¯ä¸å®ƒåŒå±ä¸€ç±»çš„å¯¹è±¡çš„(å¸¸)å¼•ç”¨ï¼›ç±»å®šä¹‰ä¸­ï¼Œå¦‚æœæœªæä¾›è‡ªå·±çš„æ‹·è´æ„é€ å‡½æ•°ï¼ŒC++æä¾›ä¸€ä¸ªé»˜è®¤æ‹·è´æ„é€ å‡½æ•°ï¼Œè¯¥é»˜è®¤æ‹·è´æ„é€ å‡½æ•°å®Œæˆä¸€ä¸ªæˆå‘˜åˆ°ä¸€ä¸ªæˆå‘˜çš„æ‹·è´
* è¦åœ¨C++é˜²æ­¢å¯¹è±¡è¢«å¤åˆ¶ï¼Œæœ‰ä»€ä¹ˆæ–¹æ³•
  * [Explicitly Defaulted and Deleted Functions | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160)
  * Pre-C++11 å®šä¹‰ä¸€ä¸ªåŸºç±»ï¼Œå°†å…¶ä¸­çš„æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ„é€ å‡½æ•°å£°æ˜ä¸ºç§æœ‰private
  * C++11åˆ™å¯ä»¥å¯¹æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ„é€ å‡½æ•°å£°æ˜ä¸ºdelete
  * æ´¾ç”Ÿç±»ä»¥ç§æœ‰privateçš„æ–¹å¼ç»§æ‰¿åŸºç±»
* ä»€ä¹ˆæ˜¯æ·±æµ…æ‹·è´?
  * æµ…æ‹·è´æ˜¯åˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡ç”¨ä¸€ä¸ªç°æˆçš„å¯¹è±¡åˆå§‹åŒ–å®ƒçš„æ—¶å€™åªæ˜¯å¤åˆ¶äº†æˆå‘˜(ç®€å•èµ‹å€¼)è€Œæ²¡æœ‰æ‹·è´åˆ†é…ç»™æˆå‘˜çš„èµ„æº(å¦‚ç»™å…¶æŒ‡é’ˆå˜é‡æˆå‘˜åˆ†é…äº†åŠ¨æ€å†…å­˜); æ·±æ‹·è´æ˜¯å½“ä¸€ä¸ªå¯¹è±¡åˆ›å»ºæ—¶ï¼Œå¦‚æœåˆ†é…äº†èµ„æºï¼Œå°±éœ€è¦å®šä¹‰è‡ªå·±çš„æ‹·è´æ„é€ å‡½æ•°ï¼Œä½¿ä¹‹ä¸ä½†æ‹·è´æˆå‘˜ä¹Ÿæ‹·è´åˆ†é…ç»™å®ƒçš„èµ„æº

## è¯­è¨€ç‰¹æ€§ç›¸å…³
* [namespace in C++ | Set 2 (Extending namespace and Unnamed namespace) - GeeksforGeeks](https://www.geeksforgeeks.org/namespace-in-c-set-2-extending-namespace-and-unnamed-namespace/)
  * Unnamed Namespaces
    * They are directly usable in the same program and are used for declaring unique identifiers.
    * In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
    * The name of the namespace is uniquely generated by the compiler.
    * The unnamed namespaces you have created will only be accessible within the file you created it in.
    * Unnamed namespaces are the replacement for the static declaration of variables.
  * [Namespaces - cppreference.com](https://en.cppreference.com/w/cpp/language/namespace)
* å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ï¼Ÿå·¦å€¼å¼•ç”¨å’Œå³å€¼å¼•ç”¨çš„åŒºåˆ«ï¼Œå¦‚ä½•å°†å·¦å€¼è½¬æ¢æˆå³å€¼ï¼Ÿ
  * å·¦å€¼ï¼šæŒ‡è¡¨è¾¾å¼ç»“æŸåä¾ç„¶å­˜åœ¨çš„æŒä¹…å¯¹è±¡ã€‚
  * å³å€¼ï¼šè¡¨è¾¾å¼ç»“æŸå°±ä¸å†å­˜åœ¨çš„ä¸´æ—¶å¯¹è±¡ã€‚
  * å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ï¼šå·¦å€¼æŒä¹…ï¼Œå³å€¼çŸ­æš‚
  * å³å€¼å¼•ç”¨å’Œå·¦å€¼å¼•ç”¨çš„åŒºåˆ«ï¼š
  * å·¦å€¼å¼•ç”¨ä¸èƒ½ç»‘å®šåˆ°è¦è½¬æ¢çš„è¡¨è¾¾å¼ã€å­—é¢å¸¸é‡æˆ–è¿”å›å³å€¼çš„è¡¨è¾¾å¼ã€‚å³å€¼å¼•ç”¨æ°å¥½ç›¸åï¼Œå¯ä»¥ç»‘å®šåˆ°è¿™ç±»è¡¨è¾¾å¼ï¼Œä½†ä¸èƒ½ç»‘å®šåˆ°ä¸€ä¸ªå·¦å€¼ä¸Šã€‚
  * å³å€¼å¼•ç”¨å¿…é¡»ç»‘å®šåˆ°å³å€¼çš„å¼•ç”¨ï¼Œé€šè¿‡ && è·å¾—ã€‚å³å€¼å¼•ç”¨åªèƒ½ç»‘å®šåˆ°ä¸€ä¸ªå°†è¦é”€æ¯çš„å¯¹è±¡ä¸Šï¼Œå› æ­¤å¯ä»¥è‡ªç”±åœ°ç§»åŠ¨å…¶èµ„æºã€‚
  * std::move å¯ä»¥å°†ä¸€ä¸ªå·¦å€¼å¼ºåˆ¶è½¬åŒ–ä¸ºå³å€¼ï¼Œç»§è€Œå¯ä»¥é€šè¿‡å³å€¼å¼•ç”¨ä½¿ç”¨è¯¥å€¼ï¼Œä»¥ç”¨äºç§»åŠ¨è¯­ä¹‰ã€‚
* std::move()
  * [move - C++ Reference](https://www.cplusplus.com/reference/algorithm/move/)
  * [std::move - cppreference.com](https://en.cppreference.com/w/cpp/utility/move)
    * std::move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object.
    * In particular, std::move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.
  * [c++ - What is std::move(), and when should it be used? - Stack Overflow](https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used)
    * In C++11, in addition to copy constructors, objects can have move constructors.(And in addition to copy assignment operators, they have move assignment operators.)
    * The move constructor is used instead of the copy constructor, if the object has type "rvalue-reference" (Type &&).
    * std::move() is a cast that produces an rvalue-reference to an object, to enable moving from it.
    * It's a new C++ way to avoid copies. For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an moved from state, therefore not copying all the data.  
    * [Rvalue Reference Quick Look](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics)
      * Rvalue references is a small technical extension to the C++ language. Rvalue references allow programmers to avoid logically unnecessary copying and to provide perfect forwarding functions. They are primarily meant to aid in the design of higer performance and more robust libraries.
      * The rvalue reference      
        * An rvalue reference is a compound type very similar to C++'s traditional reference. To better distinguish these two types, we refer to a traditional C++ reference as an lvalue reference. When the term reference is used, it refers to both kinds of reference: lvalue reference and rvalue reference.
        * It turns out that the combination of rvalue references and lvalue references is just what is needed to easily code move semantics. The rvalue reference can also be used to achieve perfect forwarding, a heretofore unsolved problem in C++. From a casual programmer's perspective, what we get from rvalue references is more general and better performing libraries.
      * Move Semantics
        * Eliminating spurious copies
          * Copying can be expensive. 
          * The first task of rvalue references is to allow us to implement move() without verbosity, or rutime overhead.
          * move
            * The move function really does very little work. All move does is accept either an lvalue or rvalue argument, and return it as an rvalue without triggering a copy construction:
  * std::move() å®ç°åŸç†ï¼š
    * åˆ©ç”¨å¼•ç”¨æŠ˜å åŸç†å°†å³å€¼ç»è¿‡ T&& ä¼ é€’ç±»å‹ä¿æŒä¸å˜è¿˜æ˜¯å³å€¼ï¼Œè€Œå·¦å€¼ç»è¿‡ T&& å˜ä¸ºæ™®é€šçš„å·¦å€¼å¼•ç”¨ï¼Œä»¥ä¿è¯æ¨¡æ¿å¯ä»¥ä¼ é€’ä»»æ„å®å‚ï¼Œä¸”ä¿æŒç±»å‹ä¸å˜ï¼›
    * ç„¶åé€šè¿‡ remove_refrence ç§»é™¤å¼•ç”¨ï¼Œå¾—åˆ°å…·ä½“çš„ç±»å‹ Tï¼›
    * æœ€åé€šè¿‡ static_cast<> è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œè¿”å› T&& å³å€¼å¼•ç”¨ã€‚
* æŒ‡é’ˆå’Œå¼•ç”¨çš„åˆå§‹åŒ–åŒºåˆ«
  * å¼•ç”¨è¢«åˆ›å»ºçš„åŒæ—¶å¿…é¡»è¢«åˆå§‹åŒ–ï¼ˆæŒ‡é’ˆåˆ™å¯ä»¥åœ¨ä»»ä½•æ—¶å€™è¢«åˆå§‹åŒ–ï¼‰ã€‚
  * ä¸èƒ½æœ‰NULL å¼•ç”¨ï¼Œå¼•ç”¨å¿…é¡»ä¸åˆæ³•çš„å­˜å‚¨å•å…ƒå…³è”ï¼ˆæŒ‡é’ˆåˆ™å¯ä»¥æ˜¯NULLï¼‰ã€‚
  * ä¸€æ—¦å¼•ç”¨è¢«åˆå§‹åŒ–ï¼Œå°±ä¸èƒ½æ”¹å˜å¼•ç”¨çš„å…³ç³»ï¼ˆæŒ‡é’ˆåˆ™å¯ä»¥éšæ—¶æ”¹å˜æ‰€æŒ‡çš„å¯¹è±¡ï¼‰ã€‚
* å‡½æ•°æŒ‡é’ˆ,ä»€ä¹ˆæ˜¯å‡½æ•°æŒ‡é’ˆï¼Œæœ‰ä»€ä¹ˆç”¨å¤„
  * å‡½æ•°æŒ‡é’ˆæ˜¯æŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆï¼Œæœ€å¤§çš„ç”¨å¤„æ˜¯åšå›è°ƒå‡½æ•°ï¼Œå¯ä»¥åšæ¥å£å‡½æ•°ï¼Œå°±åƒç³»ç»Ÿä¸­æ–­ä¸­çš„ä¸­æ–­å¤„ç†å‡½æ•°
* è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°ä¸­æœ‰ä¸€æ®µåŠŸèƒ½æ˜¯å¯¹ç›¸å…³æ•°æ®çš„ç»“ç†ï¼Œä½†å…·ä½“çš„å¤„ç†æ–¹å¼æ˜¯ä¸å®šçš„ã€‚
  * å°†ä¸å®šçš„å¤„ç†æ–¹å¼è®¾å®šæˆä¸€ä¸ªå¤–éƒ¨ä¼ æ¥å‡½æ•°æŒ‡é’ˆã€‚(å¯ä»¥è®¾è®¡æˆè¿™æ · func(int a,int bï¼ŒæŸç§å‡½æ•°æŒ‡é’ˆ) )
* å¦‚ä½•å¯¹æ¶ˆæ¯å®ç°åŒæ­¥å“åº”
  * ä½¿ç”¨CALLBACKï¼Œå›è°ƒå‡½æ•°
  * [CALLBACK_ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/CALLBACK/813549?fr=aladdin)
* å‡½æ•°å¯¹è±¡åŠŸèƒ½
  * å¯ä»¥ç”¨ä½œç±»ä¼¼Cé‡Œçš„å›è°ƒå‡½æ•°ï¼Œä¹Ÿå¯ä»¥ç”¨ä½œå‡½æ•°åŠŸèƒ½çš„ç»„åˆ
* C++æ¨¡æ¿
  * ç®€åŒ–å¯¹ç±»ä¼¼å‡½æ•°çš„è®¾è®¡ï¼Œæ¯”å¦‚è¦è®¾è®¡ä¸¤ä¸ªå‡½æ•° abs(int a), abs(float a),å°±å¯ä»¥ç”¨æ¨¡æ¿å»è®¾è®¡ä¸€ä¸ªå‡½æ•°å°±å¯ä»¥äº†
* [STL](https://github.com/huihut/interview#-stl)
* STL containerså†…éƒ¨å®ç°çš„æ•°æ®ç»“æ„
  * Sequence containers
    * [array](https://github.com/huihut/interview/tree/master/STL#array) / [vector](https://github.com/huihut/interview/tree/master/STL#vector) ï¼šæ•°ç»„
    * [deque](https://github.com/huihut/interview/tree/master/STL#deque) : åŒç«¯é˜Ÿåˆ—
    * [forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list) : å•å‘é“¾è¡¨
    * [list](https://github.com/huihut/interview/tree/master/STL#list) ï¼šåŒå‘é“¾è¡¨
  * Container adaptors
    * [stack](https://github.com/huihut/interview/tree/master/STL#stack) / [queue](https://github.com/huihut/interview/tree/master/STL#queue) : deque / list
    * [priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue) : vector + max-heap
  * Associative containers
    * [set](https://github.com/huihut/interview/tree/master/STL#set) / [multiset](https://github.com/huihut/interview/tree/master/STL#multiset) / [map](https://github.com/huihut/interview/tree/master/STL#map)  / [multimap](https://github.com/huihut/interview/tree/master/STL#multimap) ï¼šçº¢é»‘æ ‘([Redâ€“black tree - Wikipedia](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree))
  * Unordered associative containers
    * [unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set) / [unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset) / [unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map) / [unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap) ï¼šHashè¡¨
  * [Containers - C++ Reference](http://www.cplusplus.com/reference/stl/)
  * [STLå®ç°çš„åº•å±‚æ•°æ®ç»“æ„ç®€ä»‹ - CSDNåšå®¢](http://blog.csdn.net/huangkq1989/article/details/7277282)
* list v.s. vector
* class std::string
  * [string - C++ Reference](https://www.cplusplus.com/reference/string/string/)
  * [C++ä¹‹æ—…-string](https://mp.weixin.qq.com/s/P2nd-9fmhpn20bB45hBioQ)
* [C++ä¹‹æ—…-vector](https://mp.weixin.qq.com/s/Pizq2-UcJi7rJLTwwxtRlw)
* Object Slicing
  * [Object slicing - Wikipedia](https://en.wikipedia.org/wiki/Object_slicing)
  * In C++ programming, object slicing occurs when an object of a subclass type is copied to an object of superclass type: the superclass copy will not have any of the member variables defined in the subclass. These variables have, in effect, been "sliced off".) More subtly, object slicing can also occur when an object of a subclass type is copied to an object of the same type by the superclass's assignment operator, in which case some of the target object's member variables will retain their original values instead of being copied from the source object.
  * This issue is not inherently unique to C++, but it does not occur naturally in most other object-oriented languages â€” even C++'s relatives such as D, Java, and C# â€” because copying of objects is not a basic operation in those languages. (Instead, those languages prefer to manipulate objects via implicit references, such that only copying the reference is a basic operation.) In C++, by contrast, objects are copied automatically whenever a function takes an object argument by value or returns an object by value. Additionally, due to the lack of garbage collection in C++, programs will frequently copy an object whenever the ownership and lifetime of a single shared object would be unclear; for example, inserting an object into a standard-library collection, such as a std::vector, actually involves inserting a copy into the collection.
  * [c++å¯¹è±¡åˆ‡å‰² - CSDNåšå®¢](https://blog.csdn.net/weiwangchao_/article/details/4702241)
* å¼‚å¸¸,å¼‚å¸¸çš„åŠŸèƒ½
  * ä¿è¯å¼‚å¸¸çš„å¥å£®æ€§ï¼Œç»“æ„åŒ–å¤„ç†å‡ºé”™ä¿¡æ¯
* RAII
  * [RAII - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/RAII)
    * RAIIå…¨ç§°ä¸ºResource Acquisition Is Initializationï¼Œå®ƒæ˜¯åœ¨ä¸€äº›é¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„ä¸€ç§æƒ¯ç”¨æ³•ã€‚RAIIæºäºC++ï¼Œåœ¨Javaï¼ŒC#ï¼ŒDï¼ŒAdaï¼ŒValaå’ŒRustä¸­ä¹Ÿæœ‰åº”ç”¨ã€‚1984-1989å¹´æœŸé—´ï¼Œæ¯”é›…å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹é²æ™®å’Œå®‰å¾·é²Â·æŸ¯å°¼å¸Œåœ¨è®¾è®¡C++å¼‚å¸¸æ—¶ï¼Œä¸ºè§£å†³èµ„æºç®¡ç†æ—¶çš„å¼‚å¸¸å®‰å…¨æ€§è€Œä½¿ç”¨äº†è¯¥ç”¨æ³•ï¼Œåæ¥æ¯”é›…å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹é²æ™®å°†å…¶ç§°ä¸ºRAIIã€‚
    * RAIIè¦æ±‚ï¼Œèµ„æºçš„æœ‰æ•ˆæœŸä¸æŒæœ‰èµ„æºçš„å¯¹è±¡çš„ç”Ÿå‘½æœŸä¸¥æ ¼ç»‘å®šï¼Œå³ç”±å¯¹è±¡çš„æ„é€ å‡½æ•°å®Œæˆèµ„æºçš„åˆ†é…(è·å–)ï¼ŒåŒæ—¶ç”±ææ„å‡½æ•°å®Œæˆèµ„æºçš„é‡Šæ”¾ã€‚åœ¨è¿™ç§è¦æ±‚ä¸‹ï¼Œåªè¦å¯¹è±¡èƒ½æ­£ç¡®åœ°ææ„ï¼Œå°±ä¸ä¼šå‡ºç°èµ„æºæ³„éœ²é—®é¢˜ã€‚
  * [RAII_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=cZ_EqWVrbxk9AIOFJ-9IrYDMRVaeEtubQlI-JKvquwrTkm9clZshXDLN9WM1Kth0W98ADgTckgMMEAwmQ3gZDq)
    * RAIIï¼Œä¹Ÿç§°ä¸ºâ€œèµ„æºè·å–å°±æ˜¯åˆå§‹åŒ–â€ï¼Œæ˜¯c++ç­‰ç¼–ç¨‹è¯­è¨€å¸¸ç”¨çš„ç®¡ç†èµ„æºã€é¿å…å†…å­˜æ³„éœ²çš„æ–¹æ³•ã€‚å®ƒä¿è¯åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œä½¿ç”¨å¯¹è±¡æ—¶å…ˆæ„é€ å¯¹è±¡ï¼Œæœ€åææ„å¯¹è±¡ã€‚
    * [å¯¹è±¡æ‰€æœ‰èµ„æº (RAII)](https://msdn.microsoft.com/zh-cn/library/hh438480.aspx)
* RTTI
  * RTTIäº‹æŒ‡è¿è¡Œæ—¶ç±»å‹è¯†åˆ«ï¼ˆRun-time type identificationï¼‰åœ¨åªæœ‰ä¸€ä¸ªæŒ‡å‘åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨æ—¶ç¡®å®šä¸€ä¸ªå¯¹è±¡çš„å‡†ç¡®ç±»å‹ã€‚

## CODE

* [c-cpp/é¢è¯•æ€»ç»“ä¹‹C-C++ at main Â· haoran119/c-cpp](https://github.com/haoran119/c-cpp/tree/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8BC-C%2B%2B)
* ç”¨Cè¯­è¨€ï¼Œå°†ä¸€ä¸ªæ•°å­—ä¹˜ä»¥7å€çš„æ•ˆç‡æœ€å¿«çš„æ–¹æ³•æ˜¯ä»€ä¹ˆï¼Ÿ 
  * å…ˆå·¦ç§»ä¸‰ä½ï¼ˆ*8ï¼‰ç„¶åå†å‡å»åŸå€¼ï¼šX << 3 â€“ X
