# é¢è¯•æ€»ç»“ä¹‹C / C++

* [c-cpp/å­¦ä¹ ç¬”è®°ä¹‹C-C++ at main Â· haoran119/c-cpp](https://github.com/haoran119/c-cpp/tree/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BC-C%2B%2B)
* [å­¦ä¹ ç¬”è®°ä¹‹IKM C++ 11 - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/p/8465745.html)
* [å­¦ä¹ ç¬”è®°ä¹‹100 TOP Ikm C++ Online Test Questions - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/p/8533582.html)
* [é¢è¯•æ€»ç»“ä¹‹æŒ‡é’ˆ - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/p/5581823.html)
* [[ZZ]è½¯ä»¶å·¥ç¨‹å¸ˆ C/C++ç¬”è¯•é¢˜ - æµ©ç„¶119 - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/pegasus923/archive/2010/10/05/1842918.html)

## RESOURCES
* [Solve C++ | HackerRank](https://www.hackerrank.com/domains/cpp)
* [STL Containers - C++ Reference](http://www.cplusplus.com/reference/stl/)
* [C++ Data Structures and Algorithms Cheat Sheet](https://github.com/gibsjose/cpp-cheat-sheet/blob/master/Data%20Structures%20and%20Algorithms.md)
* [C è¯­è¨€ä¸ C++ é¢è¯•çŸ¥è¯†æ€»ç»“ (qq.com)](https://mp.weixin.qq.com/s/x6DMkh54NQBOlDMqNxvf7w)
  * [huihut/interview: ğŸ“š C/C++ æŠ€æœ¯é¢è¯•åŸºç¡€çŸ¥è¯†æ€»ç»“](https://github.com/huihut/interview)
    * [STL](https://github.com/huihut/interview#-stl)
    * [Effective C++](https://github.com/huihut/interview#effective-c)
    	* ä¸ºå¤šæ€åŸºç±»å£°æ˜ virtual ææ„å‡½æ•°ï¼ˆå¦‚æœ class å¸¦æœ‰ä»»ä½• virtual å‡½æ•°ï¼Œå®ƒå°±åº”è¯¥æ‹¥æœ‰ä¸€ä¸ª virtual ææ„å‡½æ•°ï¼‰
    	* åˆ«è®©å¼‚å¸¸é€ƒç¦»ææ„å‡½æ•°ï¼ˆææ„å‡½æ•°åº”è¯¥åä¸‹ä¸ä¼ æ’­å¼‚å¸¸ï¼Œæˆ–è€…ç»“æŸç¨‹åºï¼Œè€Œä¸æ˜¯åå‡ºå¼‚å¸¸ï¼›å¦‚æœè¦å¤„ç†å¼‚å¸¸åº”è¯¥åœ¨éææ„çš„æ™®é€šå‡½æ•°å¤„ç†ï¼‰
    	* ç»ä¸åœ¨æ„é€ å’Œææ„è¿‡ç¨‹ä¸­è°ƒç”¨ virtual å‡½æ•°ï¼ˆå› ä¸ºè¿™ç±»è°ƒç”¨ä»ä¸ä¸‹é™è‡³ derived classï¼‰
    	* ä»¤ operator= è¿”å›ä¸€ä¸ª reference to *this ï¼ˆç”¨äºè¿é”èµ‹å€¼ï¼‰
    	* åœ¨ operator= ä¸­å¤„ç† â€œè‡ªæˆ‘èµ‹å€¼â€
    	* èµ‹å€¼å¯¹è±¡æ—¶åº”ç¡®ä¿å¤åˆ¶ â€œå¯¹è±¡å†…çš„æ‰€æœ‰æˆå‘˜å˜é‡â€ åŠ â€œæ‰€æœ‰ base class æˆåˆ†â€ï¼ˆè°ƒç”¨åŸºç±»å¤åˆ¶æ„é€ å‡½æ•°ï¼‰
    	* åœ¨èµ„æºç®¡ç†ç±»ä¸­å°å¿ƒ copying è¡Œä¸ºï¼ˆæ™®éçš„ RAII class copying è¡Œä¸ºæ˜¯ï¼šæŠ‘åˆ¶ copyingã€å¼•ç”¨è®¡æ•°ã€æ·±åº¦æ‹·è´ã€è½¬ç§»åº•éƒ¨èµ„æºæ‹¥æœ‰æƒï¼ˆç±»ä¼¼ auto_ptrï¼‰ï¼‰
    	* ä»¥ç‹¬ç«‹è¯­å¥å°† newed å¯¹è±¡å­˜å‚¨äºï¼ˆç½®å…¥ï¼‰æ™ºèƒ½æŒ‡é’ˆï¼ˆå¦‚æœä¸è¿™æ ·åšï¼Œå¯èƒ½ä¼šå› ä¸ºç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œå¯¼è‡´éš¾ä»¥å¯Ÿè§‰çš„èµ„æºæ³„æ¼ï¼‰
    	* å®ä»¥ pass-by-reference-to-const æ›¿æ¢ pass-by-value ï¼ˆå‰è€…é€šå¸¸æ›´é«˜æ•ˆã€é¿å…åˆ‡å‰²é—®é¢˜ï¼ˆslicing problemï¼‰ï¼Œä½†ä¸é€‚ç”¨äºå†…ç½®ç±»å‹ã€STLè¿­ä»£å™¨ã€å‡½æ•°å¯¹è±¡ï¼‰
    	* å¿…é¡»è¿”å›å¯¹è±¡æ—¶ï¼Œåˆ«å¦„æƒ³è¿”å›å…¶ referenceï¼ˆç»ä¸è¿”å› pointer æˆ– reference æŒ‡å‘ä¸€ä¸ª local stack å¯¹è±¡ï¼Œæˆ–è¿”å› reference æŒ‡å‘ä¸€ä¸ª heap-allocated å¯¹è±¡ï¼Œæˆ–è¿”å› pointer æˆ– reference æŒ‡å‘ä¸€ä¸ª local static å¯¹è±¡è€Œæœ‰å¯èƒ½åŒæ—¶éœ€è¦å¤šä¸ªè¿™æ ·çš„å¯¹è±¡ã€‚ï¼‰
    	* é¿å…ä½¿ç”¨ handlesï¼ˆåŒ…æ‹¬ å¼•ç”¨ã€æŒ‡é’ˆã€è¿­ä»£å™¨ï¼‰æŒ‡å‘å¯¹è±¡å†…éƒ¨ï¼ˆä»¥å¢åŠ å°è£…æ€§ã€ä½¿ const æˆå‘˜å‡½æ•°çš„è¡Œä¸ºæ›´åƒ constã€é™ä½ â€œè™šåŠå·ç ç‰Œâ€ï¼ˆdangling handlesï¼Œå¦‚æ‚¬ç©ºæŒ‡é’ˆç­‰ï¼‰çš„å¯èƒ½æ€§ï¼‰
    	* å°†æ–‡ä»¶é—´çš„ç¼–è¯‘ä¾å­˜å…³ç³»é™è‡³æœ€ä½ï¼ˆå¦‚æœä½¿ç”¨ object references æˆ– object pointers å¯ä»¥å®Œæˆä»»åŠ¡ï¼Œå°±ä¸è¦ä½¿ç”¨ objectsï¼›å¦‚æœèƒ½å¤Ÿï¼Œå°½é‡ä»¥ class å£°æ˜å¼æ›¿æ¢ class å®šä¹‰å¼ï¼›ä¸ºå£°æ˜å¼å’Œå®šä¹‰å¼æä¾›ä¸åŒçš„å¤´æ–‡ä»¶ï¼‰
    	* ç»ä¸é‡æ–°å®šä¹‰ç»§æ‰¿è€Œæ¥çš„ non-virtual å‡½æ•°
    	* ç»ä¸é‡æ–°å®šä¹‰ç»§æ‰¿è€Œæ¥çš„ç¼ºçœå‚æ•°å€¼ï¼Œå› ä¸ºç¼ºçœå‚æ•°å€¼æ˜¯é™æ€ç»‘å®šï¼ˆstatically boundï¼‰ï¼Œè€Œ virtual å‡½æ•°å´æ˜¯åŠ¨æ€ç»‘å®šï¼ˆdynamically boundï¼‰
    	* æ˜æ™ºè€Œå®¡æ…åœ°ä½¿ç”¨å¤šé‡ç»§æ‰¿ï¼ˆå¤šç»§æ‰¿æ¯”å•ä¸€ç»§æ‰¿å¤æ‚ï¼Œå¯èƒ½å¯¼è‡´æ–°çš„æ­§ä¹‰æ€§ï¼Œä»¥åŠå¯¹ virtual ç»§æ‰¿çš„éœ€è¦ï¼Œä½†ç¡®æœ‰æ­£å½“ç”¨é€”ï¼Œå¦‚ â€œpublic ç»§æ‰¿æŸä¸ª interface classâ€ å’Œ â€œprivate ç»§æ‰¿æŸä¸ªååŠ©å®ç°çš„ classâ€ï¼›virtual ç»§æ‰¿å¯è§£å†³å¤šç»§æ‰¿ä¸‹è±å½¢ç»§æ‰¿çš„äºŒä¹‰æ€§é—®é¢˜ï¼Œä½†ä¼šå¢åŠ å¤§å°ã€é€Ÿåº¦ã€åˆå§‹åŒ–åŠèµ‹å€¼çš„å¤æ‚åº¦ç­‰ç­‰æˆæœ¬ï¼‰
    	* äº†è§£éšå¼æ¥å£å’Œç¼–è¯‘æœŸå¤šæ€ï¼ˆclass å’Œ templates éƒ½æ”¯æŒæ¥å£ï¼ˆinterfacesï¼‰å’Œå¤šæ€ï¼ˆpolymorphismï¼‰ï¼›class çš„æ¥å£æ˜¯ä»¥ç­¾åä¸ºä¸­å¿ƒçš„æ˜¾å¼çš„ï¼ˆexplicitï¼‰ï¼Œå¤šæ€åˆ™æ˜¯é€šè¿‡ virtual å‡½æ•°å‘ç”Ÿäºè¿è¡ŒæœŸï¼›template çš„æ¥å£æ˜¯å¥ åŸºäºæœ‰æ•ˆè¡¨è¾¾å¼çš„éšå¼çš„ï¼ˆimplicitï¼‰ï¼Œå¤šæ€åˆ™æ˜¯é€šè¿‡ template å…·ç°åŒ–å’Œå‡½æ•°é‡è½½è§£æï¼ˆfunction overloading resolutionï¼‰å‘ç”Ÿäºç¼–è¯‘æœŸï¼‰
    * [More Effective c++](https://github.com/huihut/interview#more-effective-c)
    	* ä»”ç»†åŒºåˆ« pointers å’Œ referencesï¼ˆå½“ä½ çŸ¥é“ä½ éœ€è¦æŒ‡å‘æŸä¸ªä¸œè¥¿ï¼Œè€Œä¸”ç»ä¸ä¼šæ”¹å˜æŒ‡å‘å…¶ä»–ä¸œè¥¿ï¼Œæˆ–æ˜¯å½“ä½ å®ç°ä¸€ä¸ªæ“ä½œç¬¦è€Œå…¶è¯­æ³•éœ€æ±‚æ— æ³•ç”± pointers è¾¾æˆï¼Œä½ å°±åº”è¯¥é€‰æ‹© referencesï¼›ä»»ä½•å…¶ä»–æ—¶å€™ï¼Œè¯·é‡‡ç”¨ pointersï¼‰
    	* åŒºåˆ« increment/decrement æ“ä½œç¬¦çš„å‰ç½®ï¼ˆprefixï¼‰å’Œåç½®ï¼ˆpostfixï¼‰å½¢å¼ï¼ˆå‰ç½®å¼ç´¯åŠ åå–å‡ºï¼Œè¿”å›ä¸€ä¸ª referenceï¼›åç½®å¼å–å‡ºåç´¯åŠ ï¼Œè¿”å›ä¸€ä¸ª const å¯¹è±¡ï¼›å¤„ç†ç”¨æˆ·å®šåˆ¶ç±»å‹æ—¶ï¼Œåº”è¯¥å°½å¯èƒ½ä½¿ç”¨å‰ç½®å¼ incrementï¼›åç½®å¼çš„å®ç°åº”ä»¥å…¶å‰ç½®å¼å…„å¼Ÿä¸ºåŸºç¡€ï¼‰
    	* åƒä¸‡ä¸è¦é‡è½½ &&ï¼Œ|| å’Œ , æ“ä½œç¬¦ï¼ˆ&& ä¸ || çš„é‡è½½ä¼šç”¨ â€œå‡½æ•°è°ƒç”¨è¯­ä¹‰â€ å–ä»£ â€œéª¤æ­»å¼è¯­ä¹‰â€ï¼›, çš„é‡è½½å¯¼è‡´ä¸èƒ½ä¿è¯å·¦ä¾§è¡¨è¾¾å¼ä¸€å®šæ¯”å³ä¾§è¡¨è¾¾å¼æ›´æ—©è¢«è¯„ä¼°ï¼‰
    	* åœ¨ constructors å†…é˜»æ­¢èµ„æºæ³„æ¼ï¼ˆç”±äº C++ åªä¼šææ„å·²æ„é€ å®Œæˆçš„å¯¹è±¡ï¼Œå› æ­¤åœ¨æ„é€ å‡½æ•°å¯ä»¥ä½¿ç”¨ try...catch æˆ–è€… auto_ptrï¼ˆä»¥åŠä¸ä¹‹ç›¸ä¼¼çš„ classesï¼‰ å¤„ç†å¼‚å¸¸æ—¶èµ„æºæ³„éœ²é—®é¢˜ï¼‰
    	* ç¦æ­¢å¼‚å¸¸æµå‡º destructors ä¹‹å¤–ï¼ˆåŸå› ï¼šä¸€ã€é¿å… terminate å‡½æ•°åœ¨ exception ä¼ æ’­è¿‡ç¨‹çš„æ ˆå±•å¼€ï¼ˆstack-unwindingï¼‰æœºåˆ¶ç§è¢«è°ƒç”¨ï¼›äºŒã€ååŠ©ç¡®ä¿ destructors å®Œæˆå…¶åº”è¯¥å®Œæˆçš„æ‰€æœ‰äº‹æƒ…ï¼‰
    	* äº†è§£ â€œæŠ›å‡ºä¸€ä¸ª exceptionâ€ ä¸ â€œä¼ é€’ä¸€ä¸ªå‚æ•°â€ æˆ– â€œè°ƒç”¨ä¸€ä¸ªè™šå‡½æ•°â€ ä¹‹é—´çš„å·®å¼‚ï¼ˆç¬¬ä¸€ï¼Œexception objects æ€»æ˜¯ä¼šè¢«å¤åˆ¶ï¼ˆby pointer é™¤å¤–ï¼‰ï¼Œå¦‚æœä»¥ by value æ–¹å¼æ•æ‰ç”šè‡³è¢«å¤åˆ¶ä¸¤æ¬¡ï¼Œè€Œä¼ é€’ç»™å‡½æ•°å‚æ•°çš„å¯¹è±¡åˆ™ä¸ä¸€å®šå¾—å¤åˆ¶ï¼›ç¬¬äºŒï¼Œâ€œè¢«æŠ›å‡ºæˆä¸º exceptionsâ€ çš„å¯¹è±¡ï¼Œå…¶è¢«å…è®¸çš„ç±»å‹è½¬æ¢åŠ¨ä½œæ¯” â€œè¢«ä¼ é€’åˆ°å‡½æ•°å»â€ çš„å¯¹è±¡å°‘ï¼›ç¬¬ä¸‰ï¼Œcatch å­å¥ä»¥å…¶ â€œå‡ºç°äºæºä»£ç çš„é¡ºåºâ€ è¢«ç¼–è¯‘å™¨æ£€éªŒå¯¹æ¯”ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…æˆåŠŸè€…ä¾¿æ‰§è¡Œï¼Œè€Œè°ƒç”¨ä¸€ä¸ªè™šå‡½æ•°ï¼Œè¢«é€‰ä¸­æ‰§è¡Œçš„æ˜¯é‚£ä¸ª â€œä¸å¯¹è±¡ç±»å‹æœ€ä½³å»åˆâ€ çš„å‡½æ•°ï¼‰
    	* ä»¥ by reference æ–¹å¼æ•è· exceptionsï¼ˆå¯é¿å…å¯¹è±¡åˆ é™¤é—®é¢˜ã€exception objects çš„åˆ‡å‰²é—®é¢˜ï¼Œå¯ä¿ç•™æ•æ‰æ ‡å‡† exceptions çš„èƒ½åŠ›ï¼Œå¯çº¦æŸ exception object éœ€è¦å¤åˆ¶çš„æ¬¡æ•°ï¼‰
    	* äº†è§£å¼‚å¸¸å¤„ç†çš„æˆæœ¬ï¼ˆç²—ç•¥ä¼°è®¡ï¼Œå¦‚æœä½¿ç”¨ try è¯­å¥å—ï¼Œä»£ç å¤§çº¦æ•´ä½“è†¨èƒ€ 5%-10%ï¼Œæ‰§è¡Œé€Ÿåº¦äº¦å¤§çº¦ä¸‹é™è¿™ä¸ªæ•°ï¼›å› æ­¤è¯·å°†ä½ å¯¹ try è¯­å¥å—å’Œ exception specifications çš„ä½¿ç”¨é™åˆ¶äºéç”¨ä¸å¯çš„åœ°ç‚¹ï¼Œå¹¶ä¸”åœ¨çœŸæ­£å¼‚å¸¸çš„æƒ…å†µä¸‹æ‰æŠ›å‡º exceptionsï¼‰
    * è‹±æ–‡ï¼š[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)
    * ä¸­æ–‡ï¼š[C++ é£æ ¼æŒ‡å—](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)
    * [Bjarne Stroustrup çš„å¸¸è§é—®é¢˜](http://www.stroustrup.com/bs_faq.html)
    * [Bjarne Stroustrup çš„ C++ é£æ ¼å’ŒæŠ€å·§å¸¸è§é—®é¢˜](http://www.stroustrup.com/bs_faq2.html)
* [C++ é¢è¯•çªå‡» - LeetBook - åŠ›æ‰£ï¼ˆLeetCodeï¼‰å…¨çƒæå®¢æŒšçˆ±çš„æŠ€æœ¯æˆé•¿å¹³å°](https://leetcode-cn.com/leetbook/detail/cpp-interview-highlights/)
  * [2021 ç§‹æ‹› 100 é“ C++ é¢è¯•é«˜é¢‘é¢˜æ±‡æ€»](https://mp.weixin.qq.com/s/wPq-fJFua0xt5zfJf0fLJA)
  * ç¼–è¯‘å†…å­˜ç›¸å…³
    1. C++ ç¨‹åºç¼–è¯‘è¿‡ç¨‹
    2. C++ å†…å­˜ç®¡ç†
    3. æ ˆå’Œå †çš„åŒºåˆ«
    4. å˜é‡çš„åŒºåˆ«
    5. å…¨å±€å˜é‡å®šä¹‰åœ¨å¤´æ–‡ä»¶ä¸­æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
    6. å¯¹è±¡åˆ›å»ºé™åˆ¶åœ¨å †æˆ–æ ˆ
    7. å†…å­˜å¯¹é½
    8. ç±»çš„å¤§å°
    9. ä»€ä¹ˆæ˜¯å†…å­˜æ³„éœ²
    10. æ€ä¹ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼Ÿå†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·çš„åŸç†ï¼Ÿ
    11. æ™ºèƒ½æŒ‡é’ˆæœ‰å“ªå‡ ç§ï¼Ÿæ™ºèƒ½æŒ‡é’ˆçš„å®ç°åŸç†ï¼Ÿ
    12. ä¸€ä¸ª unique_ptr æ€ä¹ˆèµ‹å€¼ç»™å¦ä¸€ä¸ª unique_ptr å¯¹è±¡ï¼Ÿ
    13. ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜ï¼Ÿæ€ä¹ˆè§£å†³ï¼Ÿ
  * è¯­è¨€å¯¹æ¯”
    1. C++ 11 æ–°ç‰¹æ€§
    2. C å’Œ C++ çš„åŒºåˆ«
    3. Java å’Œ C++ çš„åŒºåˆ«
    4. Python å’Œ C++ çš„åŒºåˆ«
  * é¢å‘å¯¹è±¡
    1. ä»€ä¹ˆæ˜¯é¢å‘å¯¹è±¡ï¼Ÿé¢å‘å¯¹è±¡çš„ä¸‰å¤§ç‰¹æ€§
    2. é‡è½½ã€é‡å†™ã€éšè—çš„åŒºåˆ«
    3. å¦‚ä½•ç†è§£ C++ æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹
    4. ä»€ä¹ˆæ˜¯å¤šæ€ï¼Ÿå¤šæ€å¦‚ä½•å®ç°ï¼Ÿ
  * å…³é”®å­—åº“å‡½æ•°
    1. sizeof å’Œ strlen çš„åŒºåˆ«
    2. lambda è¡¨è¾¾å¼ï¼ˆåŒ¿åå‡½æ•°ï¼‰çš„å…·ä½“åº”ç”¨å’Œä½¿ç”¨åœºæ™¯
    3. explicit çš„ä½œç”¨ï¼ˆå¦‚ä½•é¿å…ç¼–è¯‘å™¨è¿›è¡Œéšå¼ç±»å‹è½¬æ¢ï¼‰
    4. C å’Œ C++ static çš„åŒºåˆ«
    5. static çš„ä½œç”¨
    6. static åœ¨ç±»ä¸­ä½¿ç”¨çš„æ³¨æ„äº‹é¡¹ï¼ˆå®šä¹‰ã€åˆå§‹åŒ–å’Œä½¿ç”¨ï¼‰
    7. static å…¨å±€å˜é‡å’Œæ™®é€šå…¨å±€å˜é‡çš„å¼‚åŒ
    8. const ä½œç”¨åŠç”¨æ³•
    9. define å’Œ const çš„åŒºåˆ«
    10. define å’Œ typedef çš„åŒºåˆ«
    11. ç”¨å®å®ç°æ¯”è¾ƒå¤§å°ï¼Œä»¥åŠä¸¤ä¸ªæ•°ä¸­çš„æœ€å°å€¼
    12. inline ä½œç”¨åŠä½¿ç”¨æ–¹æ³•
    13. inline å‡½æ•°å·¥ä½œåŸç†
    14. å®å®šä¹‰ï¼ˆdefineï¼‰å’Œå†…è”å‡½æ•°ï¼ˆinlineï¼‰çš„åŒºåˆ«
    15. new çš„ä½œç”¨ï¼Ÿ
    16. new å’Œ malloc å¦‚ä½•åˆ¤æ–­æ˜¯å¦ç”³è¯·åˆ°å†…å­˜ï¼Ÿ
    17. delete å®ç°åŸç†ï¼Ÿdelete å’Œ delete[] çš„åŒºåˆ«ï¼Ÿ
    18. new å’Œ malloc çš„åŒºåˆ«ï¼Œdelete å’Œ free çš„åŒºåˆ«
    19. malloc çš„åŸç†ï¼Ÿmalloc çš„åº•å±‚å®ç°ï¼Ÿ
    20. C å’Œ C++ struct çš„åŒºåˆ«ï¼Ÿ
    21. ä¸ºä»€ä¹ˆæœ‰äº† class è¿˜ä¿ç•™ structï¼Ÿ
    22. struct å’Œ union çš„åŒºåˆ«
    23. class å’Œ struct çš„å¼‚åŒ
    24. volatile çš„ä½œç”¨ï¼Ÿæ˜¯å¦å…·æœ‰åŸå­æ€§ï¼Œå¯¹ç¼–è¯‘å™¨æœ‰ä»€ä¹ˆå½±å“ï¼Ÿ
    25. ä»€ä¹ˆæƒ…å†µä¸‹ä¸€å®šè¦ç”¨ volatileï¼Œ èƒ½å¦å’Œ const ä¸€èµ·ä½¿ç”¨ï¼Ÿ
    26. è¿”å›å‡½æ•°ä¸­é™æ€å˜é‡çš„åœ°å€ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
    27. extern C çš„ä½œç”¨ï¼Ÿ
    28. sizeof(1==1) åœ¨ C å’Œ C++ ä¸­åˆ†åˆ«æ˜¯ä»€ä¹ˆç»“æœï¼Ÿ
    29. memcpy å‡½æ•°çš„åº•å±‚åŸç†ï¼Ÿ
    30. strcpy å‡½æ•°æœ‰ä»€ä¹ˆç¼ºé™·ï¼Ÿ
    31. auto ç±»å‹æ¨å¯¼çš„åŸç†
  * ç±»ç›¸å…³
    1. ä»€ä¹ˆæ˜¯è™šå‡½æ•°ï¼Ÿä»€ä¹ˆæ˜¯çº¯è™šå‡½æ•°ï¼Ÿ
    2. è™šå‡½æ•°å’Œçº¯è™šå‡½æ•°çš„åŒºåˆ«ï¼Ÿ
    3. è™šå‡½æ•°çš„å®ç°æœºåˆ¶
    4. å•ç»§æ‰¿å’Œå¤šç»§æ‰¿çš„è™šå‡½æ•°è¡¨ç»“æ„
    5. å¦‚ä½•ç¦æ­¢æ„é€ å‡½æ•°çš„ä½¿ç”¨ï¼Ÿ
    6. ä»€ä¹ˆæ˜¯ç±»çš„é»˜è®¤æ„é€ å‡½æ•°ï¼Ÿ
    7. æ„é€ å‡½æ•°ã€ææ„å‡½æ•°æ˜¯å¦éœ€è¦å®šä¹‰æˆè™šå‡½æ•°ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
    8. å¦‚ä½•é¿å…æ‹·è´ï¼Ÿ
    9. å¦‚ä½•å‡å°‘æ„é€ å‡½æ•°å¼€é”€ï¼Ÿ
    10. å¤šé‡ç»§æ‰¿æ—¶ä¼šå‡ºç°ä»€ä¹ˆçŠ¶å†µï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿ
    11. ç©ºç±»å å¤šå°‘å­—èŠ‚ï¼ŸC++ ç¼–è¯‘å™¨ä¼šç»™ä¸€ä¸ªç©ºç±»è‡ªåŠ¨ç”Ÿæˆå“ªäº›å‡½æ•°ï¼Ÿ
    12. ä¸ºä»€ä¹ˆæ‹·è´æ„é€ å‡½æ•°å¿…é¡»ä¸ºå¼•ç”¨ï¼Ÿ
    13. C++ ç±»å¯¹è±¡çš„åˆå§‹åŒ–é¡ºåº
    14. å¦‚ä½•ç¦æ­¢ä¸€ä¸ªç±»è¢«å®ä¾‹åŒ–ï¼Ÿ
    15. ä¸ºä»€ä¹ˆç”¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨ä¼šå¿«ä¸€äº›ï¼Ÿ
    16. å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡éœ€è¦å“ªå‡ ä¸ªé˜¶æ®µ
    17. å‹å…ƒå‡½æ•°çš„ä½œç”¨åŠä½¿ç”¨åœºæ™¯
    18. é™æ€ç»‘å®šå’ŒåŠ¨æ€ç»‘å®šæ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ
    19. æ·±æ‹·è´å’Œæµ…æ‹·è´çš„åŒºåˆ«
    20. ç¼–è¯‘æ—¶å¤šæ€å’Œè¿è¡Œæ—¶å¤šæ€çš„åŒºåˆ«
    21. å®ç°ä¸€ä¸ªç±»æˆå‘˜å‡½æ•°ï¼Œè¦æ±‚ä¸å…è®¸ä¿®æ”¹ç±»çš„æˆå‘˜å˜é‡ï¼Ÿ
    22. å¦‚ä½•è®©ç±»ä¸èƒ½è¢«ç»§æ‰¿ï¼Ÿ
  * è¯­è¨€ç‰¹æ€§ç›¸å…³
    1. å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ï¼Ÿå·¦å€¼å¼•ç”¨å’Œå³å€¼å¼•ç”¨çš„åŒºåˆ«ï¼Œå¦‚ä½•å°†å·¦å€¼è½¬æ¢æˆå³å€¼ï¼Ÿ
    2. std::move() å‡½æ•°çš„å®ç°åŸç†
    3. ä»€ä¹ˆæ˜¯æŒ‡é’ˆï¼ŸæŒ‡é’ˆçš„å¤§å°åŠç”¨æ³•ï¼Ÿ
    4. ä»€ä¹ˆæ˜¯é‡æŒ‡é’ˆå’Œæ‚¬ç©ºæŒ‡é’ˆï¼Ÿ
    5. C++ 11 nullptr æ¯” NULL ä¼˜åŠ¿
    6. æŒ‡é’ˆå’Œå¼•ç”¨çš„åŒºåˆ«ï¼Ÿ
    7. å¸¸é‡æŒ‡é’ˆå’ŒæŒ‡é’ˆå¸¸é‡çš„åŒºåˆ«
    8. å‡½æ•°æŒ‡é’ˆå’ŒæŒ‡é’ˆå‡½æ•°çš„åŒºåˆ«
    9. å¼ºåˆ¶ç±»å‹è½¬æ¢æœ‰å“ªå‡ ç§ï¼Ÿ
    10. å¦‚ä½•åˆ¤æ–­ç»“æ„ä½“æ˜¯å¦ç›¸ç­‰ï¼Ÿèƒ½å¦ç”¨ memcmp å‡½æ•°åˆ¤æ–­ç»“æ„ä½“ç›¸ç­‰ï¼Ÿ
    11. å‚æ•°ä¼ é€’æ—¶ï¼Œå€¼ä¼ é€’ã€å¼•ç”¨ä¼ é€’ã€æŒ‡é’ˆä¼ é€’çš„åŒºåˆ«ï¼Ÿ
    12. ä»€ä¹ˆæ˜¯æ¨¡æ¿ï¼Ÿå¦‚ä½•å®ç°ï¼Ÿ
    13. å‡½æ•°æ¨¡æ¿å’Œç±»æ¨¡æ¿çš„åŒºåˆ«ï¼Ÿ
    14. ä»€ä¹ˆæ˜¯å¯å˜å‚æ•°æ¨¡æ¿ï¼Ÿ
    15. ä»€ä¹ˆæ˜¯æ¨¡æ¿ç‰¹åŒ–ï¼Ÿä¸ºä»€ä¹ˆç‰¹åŒ–ï¼Ÿ
    16. include " " å’Œ <> çš„åŒºåˆ«
    17. switch çš„ case é‡Œä¸ºä½•ä¸èƒ½å®šä¹‰å˜é‡
    18. è¿­ä»£å™¨çš„ä½œç”¨ï¼Ÿ
    19. æ³›å‹ç¼–ç¨‹å¦‚ä½•å®ç°ï¼Ÿ
    20. ä»€ä¹ˆæ˜¯ç±»å‹èƒå–ï¼Ÿ
  * è®¾è®¡æ¨¡å¼
    1. äº†è§£å“ªäº›è®¾è®¡æ¨¡å¼ï¼Ÿ
    2. ä»€ä¹ˆæ˜¯å•ä¾‹æ¨¡å¼ï¼Ÿå¦‚ä½•å®ç°ï¼Ÿåº”ç”¨åœºæ™¯ï¼Ÿ
    3. ä»€ä¹ˆæ˜¯å·¥å‚æ¨¡å¼ï¼Ÿå¦‚ä½•å®ç°ï¼Ÿåº”ç”¨åœºæ™¯ï¼Ÿ
    4. ä»€ä¹ˆæ˜¯è§‚å¯Ÿè€…æ¨¡å¼ï¼Ÿå¦‚ä½•å®ç°ï¼Ÿåº”ç”¨åœºæ™¯ï¼Ÿ
* [è¿™äº›C++å·¥ç¨‹å¸ˆé¢è¯•é¢˜ä½ éƒ½ä¼šäº†å—ï¼Ÿ](https://mp.weixin.qq.com/s/JA3ZrRwS_KllNdJxVMQRdA)
  * [ä½ ä»¬è¦çš„C++é¢è¯•é¢˜ç­”æ¡ˆæ¥äº†--åŸºç¡€ç¯‡](https://mp.weixin.qq.com/s/YRo5Lm9pbbZnjY1DQfW6yw)
* [2021 å¹´ C++ å²—å°±ä¸šå¦‚ä½•ï¼Ÿé™„å­¦ä¹ è·¯çº¿å›¾ (qq.com)](https://mp.weixin.qq.com/s/g6dHxYN7jhw_bLXqnFdEyA)
* [C++ å…«è‚¡æ–‡ï¼ˆä¸€ï¼‰](https://mp.weixin.qq.com/s/qVSdP0hXbC7le5DC3vJHKw)
* [C/C++ å…«è‚¡æ–‡ï¼ˆäºŒï¼‰](https://mp.weixin.qq.com/s?__biz=MzA4MjI3NzQ1Nw==&mid=2247497197&idx=1&sn=eda5b49d1abaa48cdfa948744efba95a&chksm=9f8a90d3a8fd19c51ad9071de207ade8929d45071c7b9191acfea3d65cd3ff01b009aec303dd&scene=178&cur_album_id=1511180677537464321#rd)
* [C++æ¥äº†ï¼Œè¯¦ç»†çŸ¥è¯†ç‚¹æ€ç»´å¯¼å›¾ï¼](https://mp.weixin.qq.com/s/0x_mWC7M0WhqJ03y1w6w2Q)
* [è…¾è®¯C++åå°å¼€å‘é¢è¯•ç¬”è¯•çŸ¥è¯†ç‚¹å‚è€ƒç¬”è®°](https://mp.weixin.qq.com/s/kdZVU4W7mEVGQKQgP64elw)
* [è…¾è®¯ C++ ç¬”è¯•/é¢è¯•é¢˜åŠç­”æ¡ˆ](https://mp.weixin.qq.com/s/lX9mmmRecu2gw84xkInsww)
* [é¢è¯•å¿…å¤‡ | å¸¸è§C++ç¬”è¯•é¢è¯•é¢˜æ•´ç†](https://mp.weixin.qq.com/s/tpQTBlwAJTqxMe6krw9C_Q)
* [é¢è¯•å¸¸é—®çš„ C/C++ é—®é¢˜ï¼Œä½ èƒ½ç­”ä¸Šæ¥å‡ ä¸ªï¼Ÿ](https://mp.weixin.qq.com/s/7hcT6HV7vx58PWHVO9Zmqw)
	* https://www.cnblogs.com/hjhgogo/p/9953506.html
* [é‡ç£…å¹²è´§ | äº”ä¸‡å­—é•¿æ–‡æ€»ç»“ C/C++ çŸ¥è¯†ï¼ˆä¸Šï¼‰](https://mp.weixin.qq.com/s?__biz=MzA4MjI3NzQ1Nw==&mid=2247492098&idx=1&sn=e250dd4483b7d784ca91975b93fb25f3&chksm=9f8a873ca8fd0e2a53cc6b3f90f81198af01d4b8481b449f36387b7e798bef75e22d23608dce&scene=178&cur_album_id=1511180677537464321#rd)
* [é‡ç£…å¹²è´§ | äº”ä¸‡å­—é•¿æ–‡æ€»ç»“ C/C++ çŸ¥è¯†ï¼ˆä¸‹ï¼‰](https://mp.weixin.qq.com/s?__biz=MzA4MjI3NzQ1Nw==&mid=2247492170&idx=1&sn=c03b00547fbaee0da0217d8c4ec9a71d&chksm=9f8a8774a8fd0e62a4382eba643f8f60c6062b29a0f3add36f782e71177120ffac84e3b40337&scene=178&cur_album_id=1511180677537464321#rd)
* [C/C++ æ˜“é”™ç‚¹ 56 æ¡ï¼Œå¹²è´§æ”¶è—ï¼](https://mp.weixin.qq.com/s/gO2fk25_TK4YDcNdcl676g)

## ç¼–è¯‘å†…å­˜ç›¸å…³

* #include â€œfilename.hâ€å’Œ#include <filename.h>çš„åŒºåˆ«
  * #include â€œfilename.hâ€æ˜¯æŒ‡ç¼–è¯‘å™¨å°†ä»å½“å‰å·¥ä½œç›®å½•ä¸Šå¼€å§‹æŸ¥æ‰¾æ­¤æ–‡ä»¶
  * #include <filename.h>æ˜¯æŒ‡ç¼–è¯‘å™¨å°†ä»æ ‡å‡†åº“ç›®å½•ä¸­å¼€å§‹æŸ¥æ‰¾æ­¤æ–‡ä»¶
* C++ å†…å­˜ç®¡ç†
  * C++ å†…å­˜åˆ†åŒºï¼šæ ˆã€å †ã€å…¨å±€/é™æ€å­˜å‚¨åŒºã€å¸¸é‡å­˜å‚¨åŒºã€ä»£ç åŒºã€‚
  * æ ˆï¼šå­˜æ”¾å‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‡½æ•°å‚æ•°ã€è¿”å›åœ°å€ç­‰ï¼Œç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…å’Œé‡Šæ”¾ã€‚
  * å †ï¼šåŠ¨æ€ç”³è¯·çš„å†…å­˜ç©ºé—´ï¼Œå°±æ˜¯ç”± malloc åˆ†é…çš„å†…å­˜å—ï¼Œç”±ç¨‹åºå‘˜æ§åˆ¶å®ƒçš„åˆ†é…å’Œé‡Šæ”¾ï¼Œå¦‚æœç¨‹åºæ‰§è¡Œç»“æŸè¿˜æ²¡æœ‰é‡Šæ”¾ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨å›æ”¶ã€‚
  * å…¨å±€åŒº/é™æ€å­˜å‚¨åŒºï¼ˆ.bss æ®µå’Œ .data æ®µï¼‰ï¼šå­˜æ”¾å…¨å±€å˜é‡å’Œé™æ€å˜é‡ï¼Œç¨‹åºè¿è¡Œç»“æŸæ“ä½œç³»ç»Ÿè‡ªåŠ¨é‡Šæ”¾ï¼Œåœ¨ C è¯­è¨€ä¸­ï¼Œæœªåˆå§‹åŒ–çš„æ”¾åœ¨ .bss æ®µä¸­ï¼Œåˆå§‹åŒ–çš„æ”¾åœ¨ .data æ®µä¸­ï¼ŒC++ ä¸­ä¸å†åŒºåˆ†äº†ã€‚
  * å¸¸é‡å­˜å‚¨åŒºï¼ˆ.rodata æ®µï¼‰ï¼šå­˜æ”¾çš„æ˜¯å¸¸é‡ï¼Œä¸å…è®¸ä¿®æ”¹ï¼Œç¨‹åºè¿è¡Œç»“æŸè‡ªåŠ¨é‡Šæ”¾ã€‚
  * ä»£ç åŒºï¼ˆ.text æ®µï¼‰ï¼šå­˜æ”¾ä»£ç ï¼Œä¸å…è®¸ä¿®æ”¹ï¼Œä½†å¯ä»¥æ‰§è¡Œã€‚ç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶å­˜æ”¾åœ¨è¿™é‡Œã€‚
  * è¯´æ˜ï¼š
    * ä»æ“ä½œç³»ç»Ÿçš„æœ¬èº«æ¥è®²ï¼Œä»¥ä¸Šå­˜å‚¨åŒºåœ¨å†…å­˜ä¸­çš„åˆ†å¸ƒæ˜¯å¦‚ä¸‹å½¢å¼(ä»ä½åœ°å€åˆ°é«˜åœ°å€)ï¼š.text æ®µ --> .data æ®µ --> .bss æ®µ --> å † --> unused --> æ ˆ --> env
* å˜é‡çš„å†…å­˜åˆ†åŒº
  * [C/C++çš„å››å¤§å†…å­˜åˆ†åŒº - CSDNåšå®¢](https://blog.csdn.net/K346K346/article/details/45592329)
* å¯¹è±¡åˆ›å»ºé™åˆ¶åœ¨å †æˆ–æ ˆ
	* [å¦‚ä½•å®šä¹‰ä¸€ä¸ªåªèƒ½åœ¨å †ä¸Šï¼ˆæ ˆä¸Šï¼‰ç”Ÿæˆå¯¹è±¡çš„ç±»ï¼Ÿ](https://github.com/huihut/interview#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%A0%88%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB)
	* åªèƒ½åœ¨å †ä¸Š
		* æ–¹æ³•ï¼šå°†ææ„å‡½æ•°è®¾ç½®ä¸ºç§æœ‰
		* åŸå› ï¼šC++ æ˜¯é™æ€ç»‘å®šè¯­è¨€ï¼Œç¼–è¯‘å™¨ç®¡ç†æ ˆä¸Šå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œç¼–è¯‘å™¨åœ¨ä¸ºç±»å¯¹è±¡åˆ†é…æ ˆç©ºé—´æ—¶ï¼Œä¼šå…ˆæ£€æŸ¥ç±»çš„ææ„å‡½æ•°çš„è®¿é—®æ€§ã€‚è‹¥ææ„å‡½æ•°ä¸å¯è®¿é—®ï¼Œåˆ™ä¸èƒ½åœ¨æ ˆä¸Šåˆ›å»ºå¯¹è±¡ã€‚
	* åªèƒ½åœ¨æ ˆä¸Š
		* æ–¹æ³•ï¼šå°† new å’Œ delete é‡è½½ä¸ºç§æœ‰
		* åŸå› ï¼šåœ¨å †ä¸Šç”Ÿæˆå¯¹è±¡ï¼Œä½¿ç”¨ new å…³é”®è¯æ“ä½œï¼Œå…¶è¿‡ç¨‹åˆ†ä¸ºä¸¤é˜¶æ®µï¼šç¬¬ä¸€é˜¶æ®µï¼Œä½¿ç”¨ new åœ¨å †ä¸Šå¯»æ‰¾å¯ç”¨å†…å­˜ï¼Œåˆ†é…ç»™å¯¹è±¡ï¼›ç¬¬äºŒé˜¶æ®µï¼Œè°ƒç”¨æ„é€ å‡½æ•°ç”Ÿæˆå¯¹è±¡ã€‚å°† new æ“ä½œè®¾ç½®ä¸ºç§æœ‰ï¼Œé‚£ä¹ˆç¬¬ä¸€é˜¶æ®µå°±æ— æ³•å®Œæˆï¼Œå°±ä¸èƒ½å¤Ÿåœ¨å †ä¸Šç”Ÿæˆå¯¹è±¡ã€‚
* C structureï¼Œæ•°æ®ç»“æ„é‡Œæœ‰inter,char,floatæ—¶ï¼Œæ•°æ®çš„å†…å­˜å¸ƒå±€ä¼šæ˜¯æ€æ ·
  * æ•°æ®ä¼šä»¥4ä½æˆ–æ˜¯8ä½ï¼Œ16ä½ç­‰ç­‰æ–¹å¼å¯¹é½
* ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ç§å¯¹é½
  * è¿™æ˜¯å› ä¸ºæœºå™¨å¯»å€å°±æ˜¯æŒ‰ç…§è¿™ç§æ–¹å¼è¿›è¡Œçš„ï¼Œè¿™æ ·å¯ä»¥ä¸€æ¬¡è€Œä¸æ˜¯å¤šæ¬¡è¯»å–ä¸€å®šæ•°æ®
* [é¢è¯•å¸¸è€ƒï¼Œé¡¹ç›®æ˜“é”™ï¼C/C++ä¸­çš„å­—èŠ‚å¯¹é½ (qq.com)](https://mp.weixin.qq.com/s/F0QIjH-fMe7KP-CtlQVbHA)
* C pointer,æŒ‡å‘æ•°æ®ç»“æ„ä¸æŒ‡å‘charçš„æŒ‡é’ˆæœ‰åŒºåˆ«å—
  * å®ƒä»¬æ­£åš+1è¿ç®—æ—¶äº§ç”Ÿçš„ä½ç§»ä¸åŒ
* deleteæ•°ç»„æŒ‡é’ˆï¼Œåªdeleteç¬¬ä¸€ä¸ªåæœ
  * å†…å­˜æ³„æ¼ 

### [æ™ºèƒ½æŒ‡é’ˆ](https://github.com/haoran119/c-cpp/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BC-C++/README.md#smart-pointers)

* [Move Semantics and Smart Pointers](https://www.learncpp.com/)
	* [M.1 â€” Intro to smart pointers and move semantics â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/intro-to-smart-pointers-move-semantics/)
	* [M.6 â€” std::unique_ptr â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/stdunique_ptr/)
	* [M.7 â€” std::shared_ptr â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/stdshared_ptr/)
	* [M.8 â€” Circular dependency issues with std::shared_ptr, and std::weak_ptr â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/)
	* [M.x â€” Chapter M comprehensive review â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/chapter-m-comprehensive-review/)
* æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸ºäº†è§£å†³åŠ¨æ€å†…å­˜åˆ†é…æ—¶å¸¦æ¥çš„å†…å­˜æ³„æ¼ä»¥åŠå¤šæ¬¡é‡Šæ”¾åŒä¸€å—å†…å­˜ç©ºé—´è€Œæå‡ºçš„ã€‚C++11 ä¸­å°è£…åœ¨äº† \<memory\> å¤´æ–‡ä»¶ä¸­ã€‚
* C++11 ä¸­æ™ºèƒ½æŒ‡é’ˆåŒ…æ‹¬ä»¥ä¸‹ä¸‰ç§ï¼š
	* å…±äº«æŒ‡é’ˆï¼ˆshared_ptrï¼‰ï¼šèµ„æºå¯ä»¥è¢«å¤šä¸ªæŒ‡é’ˆå…±äº«ï¼Œä½¿ç”¨è®¡æ•°æœºåˆ¶è¡¨æ˜èµ„æºè¢«å‡ ä¸ªæŒ‡é’ˆå…±äº«ã€‚é€šè¿‡ use_count() æŸ¥çœ‹èµ„æºçš„æ‰€æœ‰è€…çš„ä¸ªæ•°ï¼Œå¯ä»¥é€šè¿‡ unique_ptrã€weak_ptr æ¥æ„é€ ï¼Œè°ƒç”¨ release() é‡Šæ”¾èµ„æºçš„æ‰€æœ‰æƒï¼Œè®¡æ•°å‡ä¸€ï¼Œå½“è®¡æ•°å‡ä¸º 0 æ—¶ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜ç©ºé—´ï¼Œä»è€Œé¿å…äº†å†…å­˜æ³„æ¼ã€‚
	* ç‹¬å æŒ‡é’ˆï¼ˆunique_ptrï¼‰ï¼šç‹¬äº«æ‰€æœ‰æƒçš„æ™ºèƒ½æŒ‡é’ˆï¼Œèµ„æºåªèƒ½è¢«ä¸€ä¸ªæŒ‡é’ˆå æœ‰ï¼Œè¯¥æŒ‡é’ˆä¸èƒ½æ‹·è´æ„é€ å’Œèµ‹å€¼ã€‚ä½†å¯ä»¥è¿›è¡Œç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼æ„é€ ï¼ˆè°ƒç”¨ move() å‡½æ•°ï¼‰ï¼Œå³ä¸€ä¸ª unique_ptr å¯¹è±¡èµ‹å€¼ç»™å¦ä¸€ä¸ª unique_ptr å¯¹è±¡ï¼Œå¯ä»¥é€šè¿‡è¯¥æ–¹æ³•è¿›è¡Œèµ‹å€¼ã€‚
	* å¼±æŒ‡é’ˆï¼ˆweak_ptrï¼‰ï¼šæŒ‡å‘ share_ptr æŒ‡å‘çš„å¯¹è±¡ï¼Œèƒ½å¤Ÿè§£å†³ç”±shared_ptrå¸¦æ¥çš„å¾ªç¯å¼•ç”¨é—®é¢˜ã€‚
* æ™ºèƒ½æŒ‡é’ˆçš„å®ç°åŸç†ï¼š è®¡æ•°åŸç†ã€‚
* [æ™ºèƒ½æŒ‡é’ˆ_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=-4Fxt6pJdzfT54y9W-fRgMxlSYiedMOkLOxNlQf67rz_wHTOhIvtESgw6s8sEdgGMy2PxyNj0VUNe_IpaSBnbK)
	* å½“ç±»ä¸­æœ‰æŒ‡é’ˆæˆå‘˜æ—¶ï¼Œä¸€èˆ¬æœ‰ä¸¤ç§æ–¹å¼æ¥ç®¡ç†æŒ‡é’ˆæˆå‘˜ï¼šä¸€æ˜¯é‡‡ç”¨å€¼å‹çš„æ–¹å¼ç®¡ç†ï¼Œæ¯ä¸ªç±»å¯¹è±¡éƒ½ä¿ç•™ä¸€ä»½æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡çš„æ‹·è´ï¼›å¦ä¸€ç§æ›´ä¼˜é›…çš„æ–¹å¼æ˜¯ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œä»è€Œå®ç°æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡çš„å…±äº«ã€‚
	* æ™ºèƒ½æŒ‡é’ˆ(smart pointer)çš„ä¸€ç§é€šç”¨å®ç°æŠ€æœ¯æ˜¯ä½¿ç”¨å¼•ç”¨è®¡æ•°(reference count)ã€‚æ™ºèƒ½æŒ‡é’ˆç±»å°†ä¸€ä¸ªè®¡æ•°å™¨ä¸ç±»æŒ‡å‘çš„å¯¹è±¡ç›¸å…³è”ï¼Œå¼•ç”¨è®¡æ•°è·Ÿè¸ªè¯¥ç±»æœ‰å¤šå°‘ä¸ªå¯¹è±¡çš„æŒ‡é’ˆæŒ‡å‘åŒä¸€å¯¹è±¡ã€‚
	* æ¯æ¬¡åˆ›å»ºç±»çš„æ–°å¯¹è±¡æ—¶ï¼Œåˆå§‹åŒ–æŒ‡é’ˆå¹¶å°†å¼•ç”¨è®¡æ•°ç½®ä¸º1ï¼›å½“å¯¹è±¡ä½œä¸ºå¦ä¸€å¯¹è±¡çš„å‰¯æœ¬è€Œåˆ›å»ºæ—¶ï¼Œæ‹·è´æ„é€ å‡½æ•°æ‹·è´æŒ‡é’ˆå¹¶å¢åŠ ä¸ä¹‹ç›¸åº”çš„å¼•ç”¨è®¡æ•°ï¼›å¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œèµ‹å€¼æ—¶ï¼Œèµ‹å€¼æ“ä½œç¬¦å‡å°‘å·¦æ“ä½œæ•°æ‰€æŒ‡å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼ˆå¦‚æœå¼•ç”¨è®¡æ•°ä¸ºå‡è‡³0ï¼Œåˆ™åˆ é™¤å¯¹è±¡ï¼‰ï¼Œå¹¶å¢åŠ å³æ“ä½œæ•°æ‰€æŒ‡å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼›è°ƒç”¨ææ„å‡½æ•°æ—¶ï¼Œææ„å‡½æ•°å‡å°‘å¼•ç”¨è®¡æ•°ï¼ˆå¦‚æœå¼•ç”¨è®¡æ•°å‡è‡³0ï¼Œåˆ™åˆ é™¤åŸºç¡€å¯¹è±¡ï¼‰ã€‚
	* å®ç°å¼•ç”¨è®¡æ•°æœ‰ä¸¤ç§ç»å…¸ç­–ç•¥ï¼šä¸€æ˜¯å¼•å…¥è¾…åŠ©ç±»ï¼ŒäºŒæ˜¯ä½¿ç”¨å¥æŸ„ç±»ã€‚
	* ä¸ºäº†é¿å…æ–¹æ¡ˆä¸€ä¸­æ¯ä¸ªä½¿ç”¨æŒ‡é’ˆçš„ç±»è‡ªå·±å»æ§åˆ¶å¼•ç”¨è®¡æ•°ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªç±»æŠŠæŒ‡é’ˆå°è£…èµ·æ¥ã€‚å°è£…å¥½åï¼Œè¿™ä¸ªç±»å¯¹è±¡å¯ä»¥å‡ºç°åœ¨ç”¨æˆ·ç±»ä½¿ç”¨æŒ‡é’ˆçš„ä»»ä½•åœ°æ–¹ï¼Œè¡¨ç°ä¸ºä¸€ä¸ªæŒ‡é’ˆçš„è¡Œä¸ºã€‚æˆ‘ä»¬å¯ä»¥åƒæŒ‡é’ˆä¸€æ ·ä½¿ç”¨å®ƒï¼Œè€Œä¸ç”¨æ‹…å¿ƒæ™®é€šæˆå‘˜æŒ‡é’ˆæ‰€å¸¦æ¥çš„é—®é¢˜ï¼Œæˆ‘ä»¬æŠŠè¿™æ ·çš„ç±»å«å¥æŸ„ç±»ã€‚åœ¨å°è£…å¥æŸ„ç±»æ—¶ï¼Œéœ€è¦ç”³è¯·ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„å¼•ç”¨è®¡æ•°ç©ºé—´ï¼ŒæŒ‡é’ˆä¸å¼•ç”¨è®¡æ•°åˆ†å¼€å­˜å‚¨ã€‚
	* æ™ºèƒ½æŒ‡é’ˆæ˜¯å­˜å‚¨æŒ‡å‘åŠ¨æ€åˆ†é…ï¼ˆå †ï¼‰å¯¹è±¡æŒ‡é’ˆçš„ç±»ã€‚é™¤äº†èƒ½å¤Ÿåœ¨é€‚å½“çš„æ—¶é—´è‡ªåŠ¨åˆ é™¤æŒ‡å‘çš„å¯¹è±¡å¤–ï¼Œä»–ä»¬çš„å·¥ä½œæœºåˆ¶å¾ˆåƒC++çš„å†…ç½®æŒ‡é’ˆã€‚æ™ºèƒ½æŒ‡é’ˆåœ¨é¢å¯¹å¼‚å¸¸çš„æ—¶å€™æ ¼å¤–æœ‰ç”¨ï¼Œå› ä¸ºä»–ä»¬èƒ½å¤Ÿç¡®ä¿æ­£ç¡®çš„é”€æ¯åŠ¨æ€åˆ†é…çš„å¯¹è±¡ã€‚ä»–ä»¬ä¹Ÿå¯ä»¥ç”¨äºè·Ÿè¸ªè¢«å¤šç”¨æˆ·å…±äº«çš„åŠ¨æ€åˆ†é…å¯¹è±¡ã€‚
	* äº‹å®ä¸Šï¼Œæ™ºèƒ½æŒ‡é’ˆèƒ½å¤Ÿåšçš„è¿˜æœ‰å¾ˆå¤šäº‹æƒ…ï¼Œä¾‹å¦‚å¤„ç†çº¿ç¨‹å®‰å…¨ï¼Œæä¾›å†™æ—¶å¤åˆ¶ï¼Œç¡®ä¿åè®®ï¼Œå¹¶ä¸”æä¾›è¿œç¨‹äº¤äº’æœåŠ¡ã€‚æœ‰èƒ½å¤Ÿä¸ºè¿™äº›ESP (Extremely Smart Pointers)åˆ›å»ºä¸€èˆ¬æ™ºèƒ½æŒ‡é’ˆçš„æ–¹æ³•ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ¶µç›–è¿›æ¥ã€‚
	* æ™ºèƒ½æŒ‡é’ˆçš„å¤§éƒ¨åˆ†ä½¿ç”¨æ˜¯ç”¨äºç”Ÿå­˜æœŸæ§åˆ¶ï¼Œé˜¶æ®µæ§åˆ¶ã€‚å®ƒä»¬ä½¿ç”¨operator->å’Œoperator*æ¥ç”ŸæˆåŸå§‹æŒ‡é’ˆï¼Œè¿™æ ·æ™ºèƒ½æŒ‡é’ˆçœ‹ä¸Šå»å°±åƒä¸€ä¸ªæ™®é€šæŒ‡é’ˆã€‚
	* è¿™æ ·çš„ä¸€ä¸ªç±»æ¥è‡ªæ ‡å‡†åº“ï¼šstd::auto_ptrã€‚å®ƒæ˜¯ä¸ºè§£å†³èµ„æºæ‰€æœ‰æƒé—®é¢˜è®¾è®¡çš„ï¼Œä½†æ˜¯ç¼ºå°‘å¯¹å¼•ç”¨æ•°å’Œæ•°ç»„çš„æ”¯æŒã€‚å¹¶ä¸”ï¼Œstd::auto_ptråœ¨è¢«å¤åˆ¶çš„æ—¶å€™ä¼šä¼ è¾“æ‰€æœ‰æƒã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ éœ€è¦æ›´å¤šçš„å’Œ/æˆ–è€…æ˜¯ä¸åŒçš„åŠŸèƒ½ã€‚è¿™æ—¶å°±éœ€è¦åŠ å…¥smart_ptrç±»ã€‚
* [æ™ºèƒ½æŒ‡é’ˆï¼ˆç°ä»£ C++ï¼‰](https://msdn.microsoft.com/zh-cn/library/hh279674.aspx)
	* In modern C++ programming, the Standard Library includes smart pointers, which are used to help ensure that programs are free of memory and resource leaks and are exception-safe.
	* Smart pointers are defined in the std namespace in the \<memory\> header file. They are crucial to the RAII or Resource Acquisition Is Initialization programming idiom. The main goal of this idiom is to ensure that resource acquisition occurs at the same time that the object is initialized, so that all resources for the object are created and made ready in one line of code. In practical terms, the main principle of RAII is to give ownership of any heap-allocated resourceâ€”for example, dynamically-allocated memory or system object handlesâ€”to a stack-allocated object whose destructor contains the code to delete or free the resource and also any associated cleanup code.
	* In most cases, when you initialize a raw pointer or resource handle to point to an actual resource, pass the pointer to a smart pointer immediately. In modern C++, raw pointers are only used in small code blocks of limited scope, loops, or helper functions where performance is critical and there is no chance of confusion about ownership.
	* The C++ smart pointer idiom resembles object creation in languages such as C#: you create the object and then let the system take care of deleting it at the correct time. The difference is that no separate garbage collector runs in the background; memory is managed through the standard C++ scoping rules so that the runtime environment is faster and more efficient.
	* Important : Always create smart pointers on a separate line of code, never in a parameter list, so that a subtle resource leak won't occur due to certain parameter list allocation rules.
	* Use these smart pointers as a first choice for encapsulating pointers to plain old C++ objects (POCO).
	* unique_ptr
		* Allows exactly one owner of the underlying pointer. Use as the default choice for POCO unless you know for certain that you require a shared_ptr. Can be moved to a new owner, but not copied or shared. Replaces auto_ptr, which is deprecated. Compare to boost::scoped_ptr. unique_ptr is small and efficient; the size is one pointer and it supports rvalue references for fast insertion and retrieval from C++ Standard Library collections. Header file: \<memory\>. For more information, see [How to: Create and use unique_ptr instances | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=msvc-160) and [unique_ptr Class](https://docs.microsoft.com/en-us/cpp/standard-library/unique-ptr-class?view=msvc-160).
		* A unique_ptr does not share its pointer. It cannot be copied to another unique_ptr, passed by value to a function, or used in any C++ Standard Library algorithm that requires copies to be made. A unique_ptr can only be moved. This means that the ownership of the memory resource is transferred to another unique_ptr and the original unique_ptr no longer owns it. We recommend that you restrict an object to one owner, because multiple ownership adds complexity to the program logic. Therefore, when you need a smart pointer for a plain C++ object, use unique_ptr, and when you construct a unique_ptr, use the [make_unique](https://docs.microsoft.com/en-us/cpp/standard-library/memory-functions?view=msvc-160#make_unique) helper function.
	* shared_ptr
		* Reference-counted smart pointer. Use when you want to assign one raw pointer to multiple owners, for example, when you return a copy of a pointer from a container but want to keep the original. The raw pointer is not deleted until all shared_ptr owners have gone out of scope or have otherwise given up ownership. The size is two pointers; one for the object and one for the shared control block that contains the reference count. Header file: \<memory\>. For more information, see [How to: Create and use shared_ptr instances | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-shared-ptr-instances?view=msvc-160) and [shared_ptr Class](https://docs.microsoft.com/en-us/cpp/standard-library/shared-ptr-class?view=msvc-160).
			* Whenever possible, use the [make_shared](https://docs.microsoft.com/en-us/cpp/standard-library/memory-functions?view=msvc-160#make_shared) function to create a shared_ptr when the memory resource is created for the first time.
		* The shared_ptr type is a smart pointer in the C++ standard library that is designed for scenarios in which more than one owner might have to manage the lifetime of the object in memory. After you initialize a shared_ptr you can copy it, pass it by value in function arguments, and assign it to other shared_ptr instances. All the instances point to the same object, and share access to one "control block" that increments and decrements the reference count whenever a new shared_ptr is added, goes out of scope, or is reset. When the reference count reaches zero, the control block deletes the memory resource and itself.
	* weak_ptr
		* Special-case smart pointer for use in conjunction with shared_ptr. A weak_ptr provides access to an object that is owned by one or more shared_ptr instances, but does not participate in reference counting. Use when you want to observe an object, but do not require it to remain alive. Required in some cases to break circular references between shared_ptr instances. Header file: \<memory\>. For more information, see [How to: Create and use weak_ptr instances | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-weak-ptr-instances?view=msvc-160) and [weak_ptr Class](https://docs.microsoft.com/en-us/cpp/standard-library/weak-ptr-class?view=msvc-160).
		* Sometimes an object must store a way to access the underlying object of a shared_ptr without causing the reference count to be incremented. Typically, this situation occurs when you have cyclic references between shared_ptr instances.
		* The best design is to avoid shared ownership of pointers whenever you can. However, if you must have shared ownership of shared_ptr instances, avoid cyclic references between them. When cyclic references are unavoidable, or even preferable for some reason, use weak_ptr to give one or more of the owners a weak reference to another shared_ptr. By using a weak_ptr, you can create a shared_ptr that joins to an existing set of related instances, but only if the underlying memory resource is still valid. A weak_ptr itself does not participate in the reference counting, and therefore, it cannot prevent the reference count from going to zero. However, you can use a weak_ptr to try to obtain a new copy of the shared_ptr with which it was initialized. If the memory has already been deleted, the weak_ptr's bool operator returns false. If the memory is still valid, the new shared pointer increments the reference count and guarantees that the memory will be valid as long as the shared_ptr variable stays in scope.
* [Smart pointer - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Smart_pointer)
* [æ™ºèƒ½æŒ‡é’ˆï¼šä»std::auto_ptråˆ°std::unique_ptr - hanhuiliçš„ä¸“æ  - åšå®¢é¢‘é“ - CSDN.NET](http://blog.csdn.net/hanhuili/article/details/8299912)
* [æ‹¥æŠ±æ™ºèƒ½æŒ‡é’ˆï¼Œå‘Šåˆ«å†…å­˜æ³„éœ²](https://mp.weixin.qq.com/s/evYOoS4_XfjkPXlDWXTnSg)
* [æµ…æ C++æ™ºèƒ½æŒ‡é’ˆå’Œ enable_shared_from_this æœºåˆ¶](https://mp.weixin.qq.com/s/a7Nl2jnbOtkfzEAK1TxVyA)

## è¯­è¨€å¯¹æ¯”

* C++å¦‚ä½•å®ç°JAVAæ¥å£
  * [javaæ¥å£_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=hoPdmBnxPUNPpyCRPD80NQVbOPS0qT5IoI1jezWUDT4Dz0MdgaVrPEurjtacqy6rJRZxO0CrQCNqDn5czUriNK)
  * [C++ä¸­çš„æŠ½è±¡ç±»ä»¥åŠæ¥å£çš„åŒºåˆ«è”ç³»_Linuxç¼–ç¨‹_Linuxå…¬ç¤¾-Linuxç³»ç»Ÿé—¨æˆ·ç½‘ç«™](http://www.linuxidc.com/Linux/2012-10/73243.htm)

## å…³é”®å­—åº“å‡½æ•°

* [size_t_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=sh8RRfasW1QG-PhcWPZhfcZ75Uw-KYLKh443jzpNg36hVk1Fu7WeTh4lEPLCuBx_iT0wglX5MRQUqXJMWV-oUK)
* staticå…³é”®å­—è‡³å°‘æœ‰ä¸‹åˆ—nä¸ªä½œç”¨ï¼š
  * å‡½æ•°ä½“å†…staticå˜é‡çš„ä½œç”¨èŒƒå›´ä¸ºè¯¥å‡½æ•°ä½“ï¼Œä¸åŒäºautoå˜é‡ï¼Œè¯¥å˜é‡çš„å†…å­˜åªè¢«åˆ†é…ä¸€æ¬¡ï¼Œå› æ­¤å…¶å€¼åœ¨ä¸‹æ¬¡è°ƒç”¨æ—¶ä»ç»´æŒä¸Šæ¬¡çš„å€¼ï¼›
  * åœ¨æ¨¡å—å†…çš„staticå…¨å±€å˜é‡å¯ä»¥è¢«æ¨¡å—å†…æ‰€ç”¨å‡½æ•°è®¿é—®ï¼Œä½†ä¸èƒ½è¢«æ¨¡å—å¤–å…¶å®ƒå‡½æ•°è®¿é—®ï¼›
  * åœ¨æ¨¡å—å†…çš„staticå‡½æ•°åªå¯è¢«è¿™ä¸€æ¨¡å—å†…çš„å…¶å®ƒå‡½æ•°è°ƒç”¨ï¼Œè¿™ä¸ªå‡½æ•°çš„ä½¿ç”¨èŒƒå›´è¢«é™åˆ¶åœ¨å£°æ˜å®ƒçš„æ¨¡å—å†…ï¼›
  * åœ¨ç±»ä¸­çš„staticæˆå‘˜å˜é‡å±äºæ•´ä¸ªç±»æ‰€æ‹¥æœ‰ï¼Œå¯¹ç±»çš„æ‰€æœ‰å¯¹è±¡åªæœ‰ä¸€ä»½æ‹·è´ï¼›
  * åœ¨ç±»ä¸­çš„staticæˆå‘˜å‡½æ•°å±äºæ•´ä¸ªç±»æ‰€æ‹¥æœ‰ï¼Œè¿™ä¸ªå‡½æ•°ä¸æ¥æ”¶thisæŒ‡é’ˆï¼Œå› è€Œåªèƒ½è®¿é—®ç±»çš„staticæˆå‘˜å˜é‡ã€‚
* constå…³é”®å­—è‡³å°‘æœ‰ä¸‹åˆ—nä¸ªä½œç”¨ï¼š
  * æ¬²é˜»æ­¢ä¸€ä¸ªå˜é‡è¢«æ”¹å˜ï¼Œå¯ä»¥ä½¿ç”¨constå…³é”®å­—ã€‚åœ¨å®šä¹‰è¯¥constå˜é‡æ—¶ï¼Œé€šå¸¸éœ€è¦å¯¹å®ƒè¿›è¡Œåˆå§‹åŒ–ï¼Œå› ä¸ºä»¥åå°±æ²¡æœ‰æœºä¼šå†å»æ”¹å˜å®ƒäº†ï¼›
  * å¯¹æŒ‡é’ˆæ¥è¯´ï¼Œå¯ä»¥æŒ‡å®šæŒ‡é’ˆæœ¬èº«ä¸ºconstï¼Œä¹Ÿå¯ä»¥æŒ‡å®šæŒ‡é’ˆæ‰€æŒ‡çš„æ•°æ®ä¸ºconstï¼Œæˆ–äºŒè€…åŒæ—¶æŒ‡å®šä¸ºconstï¼›
  * åœ¨ä¸€ä¸ªå‡½æ•°å£°æ˜ä¸­ï¼Œconstå¯ä»¥ä¿®é¥°å½¢å‚ï¼Œè¡¨æ˜å®ƒæ˜¯ä¸€ä¸ªè¾“å…¥å‚æ•°ï¼Œåœ¨å‡½æ•°å†…éƒ¨ä¸èƒ½æ”¹å˜å…¶å€¼ï¼›
  * å¯¹äºç±»çš„æˆå‘˜å‡½æ•°ï¼Œè‹¥æŒ‡å®šå…¶ä¸ºconstç±»å‹ï¼Œåˆ™è¡¨æ˜å…¶æ˜¯ä¸€ä¸ªå¸¸å‡½æ•°ï¼Œä¸èƒ½ä¿®æ”¹ç±»çš„æˆå‘˜å˜é‡ï¼›
  * å¯¹äºç±»çš„æˆå‘˜å‡½æ•°ï¼Œæœ‰æ—¶å€™å¿…é¡»æŒ‡å®šå…¶è¿”å›å€¼ä¸ºconstç±»å‹ï¼Œä»¥ä½¿å¾—å…¶è¿”å›å€¼ä¸ä¸ºâ€œå·¦å€¼â€ã€‚
* çŸ­å°è€Œè¢«é¢‘ç¹è°ƒç”¨çš„ç¨‹åºå¦‚ä½•å¤„ç†ï¼Ÿ
  * Cè¯­è¨€ç”¨å®ä»£æ›¿ã€‚
  * C++ç”¨inlineï¼Œå†…è”å‡½æ•°æœºåˆ¶ã€‚
  * å†…è”å‡½æ•°å¯ä»¥å¾—åˆ°å®çš„æ›¿æ¢åŠŸèƒ½ï¼Œæ‰€æœ‰å¯é¢„è§çš„çŠ¶æ€å’Œå¸¸è§„å‡½æ•°çš„ç±»å‹æ£€æŸ¥ã€‚
* malloc / new operator / operator newçš„åŒºåˆ«ï¼Ÿ
	* [malloc() vs new - GeeksforGeeks](https://www.geeksforgeeks.org/malloc-vs-new/)
	* [new vs operator new in C++ - GeeksforGeeks](https://www.geeksforgeeks.org/new-vs-operator-new-in-cpp/)
	* [Difference between "new operator" and "operator new" in C++?](https://www.tutorialspoint.com/difference-between-new-operator-and-operator-new-in-cplusplus)

Item | malloc | new operator | operator new
-|-|-|-
Type|C function|operator and C++ keyword|C++ function to overload the new operator
Call constructor?|No|Yes|No but after returning the pointer from this overloaded method, the compiler calls the constructor
Return type|void*|exact data type|exact data type
Exception handling on failure|return NULL|throws bad_alloc exception|throws bad_alloc exception
Required size of memory|calculated manually|caculated by compiler|caculated by compiler

* [structå’Œunionçš„åŒºåˆ«](http://blog.csdn.net/firefly_2002/article/details/7954458)
  * åœ¨å­˜å‚¨å¤šä¸ªæˆå‘˜ä¿¡æ¯æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç»™structç¬¬ä¸ªæˆå‘˜åˆ†é…å­˜å‚¨ç©ºé—´ï¼Œstructå¯ä»¥å­˜å‚¨å¤šä¸ªæˆå‘˜ä¿¡æ¯ï¼Œè€Œunionæ¯ä¸ªæˆå‘˜ä¼šç”¨åŒä¸€ä¸ªå­˜å‚¨ç©ºé—´ï¼Œåªèƒ½å­˜å‚¨æœ€åä¸€ä¸ªæˆå‘˜çš„ä¿¡æ¯ã€‚
  * éƒ½æ˜¯ç”±å¤šä¸ªä¸åŒçš„æ•°æ®ç±»å‹æˆå‘˜ç»„æˆï¼Œä½†åœ¨ä»»ä½•åŒä¸€æ—¶åˆ»ï¼ŒUnionåªå­˜æ”¾äº†ä¸€ä¸ªè¢«å…ˆé€‰ä¸­çš„æˆå‘˜ï¼Œè€Œç»“æ„ä½“çš„æ‰€æœ‰æˆå‘˜éƒ½å­˜åœ¨ã€‚
  * å¯¹äºUnionçš„ä¸åŒæˆå‘˜èµ‹å€¼ï¼Œå°†ä¼šå¯¹å…¶ä»–æˆå‘˜é‡å†™ï¼ŒåŸæ¥æˆå‘˜çš„å€¼å°±ä¸å­˜åœ¨äº†ï¼Œè€Œå¯¹äºstructçš„ä¸åŒæˆå‘˜èµ‹å€¼æ˜¯äº’ä¸å½±å“çš„ã€‚
* structå’Œclassçš„åŒºåˆ«
  * [Access Control and Constraints of Structures, Classes and Unions](https://msdn.microsoft.com/en-us/library/4a1hcx0y.aspx)

|Structures|Classes|Unions|
| - | - | - |
|class key is struct|class key is class|class key is union|
|Default access is public|	Default access is private|	Default access is public
|No usage constraints|	No usage constraints|	Use only one member at a time
|Default inheritance is public	|Default inheritance is private	|-
|[not type-parameter-key in Template](https://stackoverflow.com/questions/2520130/why-are-structs-not-allowed-in-template-definitions)	|type-parameter-key in Template	|-

* [volatile](https://github.com/haoran119/c-cpp/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BC-C++/README.md#const-type-qualifier)
  * [volatile_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=gPm-SmXKapujjcPjO3COGYDPSvH4VPOMabuV61XG7kM1kMhwX1AnNxF5_VZDiq7fizEaEfpYKLRBVgRt99BxOK)
  	* volatileæ˜¯ä¸€ä¸ªç‰¹å¾ä¿®é¥°ç¬¦ï¼ˆtype specifierï¼‰.volatileçš„ä½œç”¨æ˜¯ä½œä¸ºæŒ‡ä»¤å…³é”®å­—ï¼Œç¡®ä¿æœ¬æ¡æŒ‡ä»¤ä¸ä¼šå› ç¼–è¯‘å™¨çš„ä¼˜åŒ–è€Œçœç•¥ï¼Œä¸”è¦æ±‚æ¯æ¬¡ç›´æ¥è¯»å€¼ã€‚
  	* volatileçš„å˜é‡æ˜¯è¯´è¿™å˜é‡å¯èƒ½ä¼šè¢«æ„æƒ³ä¸åˆ°åœ°æ”¹å˜ï¼Œè¿™æ ·ï¼Œç¼–è¯‘å™¨å°±ä¸ä¼šå»å‡è®¾è¿™ä¸ªå˜é‡çš„å€¼äº†ã€‚
  	* ç®€å•åœ°è¯´å°±æ˜¯é˜²æ­¢ç¼–è¯‘å™¨å¯¹ä»£ç è¿›è¡Œä¼˜åŒ–ã€‚
  	* ç²¾ç¡®åœ°è¯´å°±æ˜¯ï¼Œç¼–è¯‘å™¨åœ¨ç”¨åˆ°è¿™ä¸ªå˜é‡æ—¶å¿…é¡»æ¯æ¬¡éƒ½å°å¿ƒåœ°é‡æ–°è¯»å–è¿™ä¸ªå˜é‡çš„å€¼ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ä¿å­˜åœ¨å¯„å­˜å™¨é‡Œçš„å¤‡ä»½ã€‚

## é¢å‘å¯¹è±¡

* é¢å‘å¯¹è±¡çš„ä¸‰å¤§ç‰¹æ€§ï¼š
  * `å°è£…(Encapsulation)`ï¼šå°†å…·ä½“çš„å®ç°è¿‡ç¨‹å’Œæ•°æ®å°è£…æˆä¸€ä¸ªå‡½æ•°ï¼Œåªèƒ½é€šè¿‡æ¥å£è¿›è¡Œè®¿é—®ï¼Œé™ä½è€¦åˆæ€§ã€‚
  * `ç»§æ‰¿(Inheritance)`ï¼šå­ç±»ç»§æ‰¿çˆ¶ç±»çš„ç‰¹å¾å’Œè¡Œä¸ºï¼Œå­ç±»æœ‰çˆ¶ç±»çš„é private æ–¹æ³•æˆ–æˆå‘˜å˜é‡ï¼Œå­ç±»å¯ä»¥å¯¹çˆ¶ç±»çš„æ–¹æ³•è¿›è¡Œé‡å†™ï¼Œå¢å¼ºäº†ç±»ä¹‹é—´çš„è€¦åˆæ€§ï¼Œä½†æ˜¯å½“çˆ¶ç±»ä¸­çš„æˆå‘˜å˜é‡ã€æˆå‘˜å‡½æ•°æˆ–è€…ç±»æœ¬èº«è¢« final å…³é”®å­—ä¿®é¥°æ—¶ï¼Œä¿®é¥°çš„ç±»ä¸èƒ½ç»§æ‰¿ï¼Œä¿®é¥°çš„æˆå‘˜ä¸èƒ½é‡å†™æˆ–ä¿®æ”¹ã€‚
  * `å¤šæ€(Polymorphism)`ï¼šå¤šæ€å°±æ˜¯ä¸åŒç»§æ‰¿ç±»çš„å¯¹è±¡ï¼Œå¯¹åŒä¸€æ¶ˆæ¯åšå‡ºä¸åŒçš„å“åº”ï¼ŒåŸºç±»çš„æŒ‡é’ˆæŒ‡å‘æˆ–ç»‘å®šåˆ°æ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œä½¿å¾—åŸºç±»æŒ‡é’ˆå‘ˆç°ä¸åŒçš„è¡¨ç°æ–¹å¼ã€‚
* é‡è½½ã€é‡å†™ã€éšè—çš„åŒºåˆ«
  * `é‡è½½(Overload)`ï¼šæ˜¯æŒ‡åŒä¸€å¯è®¿é—®åŒºå†…è¢«å£°æ˜å‡ ä¸ªå…·æœ‰ä¸åŒå‚æ•°åˆ—ï¼ˆå‚æ•°çš„ç±»å‹ã€ä¸ªæ•°ã€é¡ºåºï¼‰çš„åŒåå‡½æ•°ï¼Œæ ¹æ®å‚æ•°åˆ—è¡¨ç¡®å®šè°ƒç”¨å“ªä¸ªå‡½æ•°ï¼Œé‡è½½ä¸å…³å¿ƒå‡½æ•°è¿”å›ç±»å‹ã€‚
  * `éšè—(Overwrite / Hide)`ï¼šæ˜¯æŒ‡æ´¾ç”Ÿç±»çš„å‡½æ•°å±è”½äº†ä¸å…¶åŒåçš„åŸºç±»å‡½æ•°ï¼Œä¸»è¦åªè¦åŒåå‡½æ•°ï¼Œä¸ç®¡å‚æ•°åˆ—è¡¨æ˜¯å¦ç›¸åŒï¼ŒåŸºç±»å‡½æ•°éƒ½ä¼šè¢«éšè—ã€‚
  * `é‡å†™(è¦†ç›–)(Override)`ï¼šæ˜¯æŒ‡æ´¾ç”Ÿç±»ä¸­å­˜åœ¨é‡æ–°å®šä¹‰çš„å‡½æ•°ã€‚å‡½æ•°åã€å‚æ•°åˆ—è¡¨ã€è¿”å›å€¼ç±»å‹éƒ½å¿…é¡»åŒåŸºç±»ä¸­è¢«é‡å†™çš„å‡½æ•°ä¸€è‡´ï¼Œåªæœ‰å‡½æ•°ä½“ä¸åŒã€‚æ´¾ç”Ÿç±»è°ƒç”¨æ—¶ä¼šè°ƒç”¨æ´¾ç”Ÿç±»çš„é‡å†™å‡½æ•°ï¼Œä¸ä¼šè°ƒç”¨è¢«é‡å†™å‡½æ•°ã€‚é‡å†™çš„åŸºç±»ä¸­è¢«é‡å†™çš„å‡½æ•°å¿…é¡»æœ‰ virtual ä¿®é¥°ã€‚
  * é‡å†™å’Œé‡è½½çš„åŒºåˆ«ï¼š
    * èŒƒå›´åŒºåˆ«ï¼šå¯¹äºç±»ä¸­å‡½æ•°çš„é‡è½½æˆ–è€…é‡å†™è€Œè¨€ï¼Œé‡è½½å‘ç”Ÿåœ¨åŒä¸€ä¸ªç±»çš„å†…éƒ¨ï¼Œé‡å†™å‘ç”Ÿåœ¨ä¸åŒçš„ç±»ä¹‹é—´ï¼ˆå­ç±»å’Œçˆ¶ç±»ä¹‹é—´ï¼‰ã€‚
    * å‚æ•°åŒºåˆ«ï¼šé‡è½½çš„å‡½æ•°éœ€è¦ä¸åŸå‡½æ•°æœ‰ç›¸åŒçš„å‡½æ•°åã€ä¸åŒçš„å‚æ•°åˆ—è¡¨ï¼Œä¸å…³æ³¨å‡½æ•°çš„è¿”å›å€¼ç±»å‹ï¼›é‡å†™çš„å‡½æ•°çš„å‡½æ•°åã€å‚æ•°åˆ—è¡¨å’Œè¿”å›å€¼ç±»å‹éƒ½éœ€è¦å’ŒåŸå‡½æ•°ç›¸åŒï¼Œçˆ¶ç±»ä¸­è¢«é‡å†™çš„å‡½æ•°éœ€è¦æœ‰ virtual ä¿®é¥°ã€‚
    * virtual å…³é”®å­—ï¼šé‡å†™çš„å‡½æ•°åŸºç±»ä¸­å¿…é¡»æœ‰ virtualå…³é”®å­—çš„ä¿®é¥°ï¼Œé‡è½½çš„å‡½æ•°å¯ä»¥æœ‰ virtual å…³é”®å­—çš„ä¿®é¥°ä¹Ÿå¯ä»¥æ²¡æœ‰ã€‚
  * éšè—å’Œé‡å†™ï¼Œé‡è½½çš„åŒºåˆ«ï¼š
    * èŒƒå›´åŒºåˆ«ï¼šéšè—ä¸é‡è½½èŒƒå›´ä¸åŒï¼Œéšè—å‘ç”Ÿåœ¨ä¸åŒç±»ä¸­ã€‚
    * å‚æ•°åŒºåˆ«ï¼šéšè—å‡½æ•°å’Œè¢«éšè—å‡½æ•°å‚æ•°åˆ—è¡¨å¯ä»¥ç›¸åŒï¼Œä¹Ÿå¯ä»¥ä¸åŒï¼Œä½†å‡½æ•°åä¸€å®šç›¸åŒï¼›å½“å‚æ•°ä¸åŒæ—¶ï¼Œæ— è®ºåŸºç±»ä¸­çš„å‡½æ•°æ˜¯å¦è¢« virtual ä¿®é¥°ï¼ŒåŸºç±»å‡½æ•°éƒ½æ˜¯è¢«éšè—ï¼Œè€Œä¸æ˜¯é‡å†™ã€‚
* C++è™šæ‹Ÿæœºåˆ¶
  * ç”¨æ¥å®ç°å¤šæ€

### å¤šé‡ç»§æ‰¿

* å¯ä»¥ä¸ºä¸€ä¸ªæ´¾ç”Ÿç±»æŒ‡å®šå¤šä¸ªåŸºç±»ï¼Œè¿™æ ·çš„ç»§æ‰¿ç»“æ„ç§°ä¸º`å¤šé‡ç»§æ‰¿`æˆ–`å¤šç»§æ‰¿`
* Java/C#ä¸­æ²¡æœ‰å¤šç»§æ‰¿ï¼ŒC++ä¸­ä¹Ÿåº”é¿å…ä½¿ç”¨
* å½“ä¸¤ä¸ªçˆ¶ç±»æœ‰åŒæ ·çš„æˆå‘˜æ—¶ä¼šå¸¦æ¥æ¨¡ç³Šæ€§ï¼Œè¿™æ ·å¯¼è‡´äº†åç§°å†²çª(name collision)ï¼Œåœ¨ç¼–è¯‘æ—¶å°†äºˆä»¥æ‹’ç»ï¼Œä¹Ÿç§°ä¹‹ä¸º`è±å½¢ç»§æ‰¿`
* å¯ä»¥åœ¨æ–¹æ³•å‰è¯´æ˜åŸºç±»ï¼Œæˆ–è€…ç”¨è™šç»§æ‰¿æ¥è§£å†³è±å½¢ç»§æ‰¿é—®é¢˜
* [å¤šé‡ç»§æ‰¿ - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF)
	* å¤šé‡ç»§æ‰¿å¯ä»¥å¯¼è‡´æŸäº›ä»¤äººæ··æ·†çš„æƒ…å†µï¼Œæ‰€ä»¥å…³äºå®ƒçš„å¥½å¤„ä¸é£é™©ä¹‹é—´å­°è½»å­°é‡å¸¸å¸¸å—äººäº‰è®ºã€‚Javaä½¿ç”¨äº†ä¸€ä¸ªæŠ˜è¡·çš„åŠæ³•ï¼šJavaå…è®¸ä¸€ä¸ªç±»åˆ«ç»§æ‰¿è‡ªå¤šäºä¸€ä¸ªçˆ¶æ¥å£ï¼ˆå¯ä»¥æŒ‡å®šæŸä¸€ä¸ªç±»åˆ«ï¼Œå®ƒç»§æ‰¿äº†æ‰€æœ‰çˆ¶ç±»çš„ç±»å‹ï¼Œå¹¶å¿…é¡»æ‹¥æœ‰æ‰€æœ‰çˆ¶ç±»æ¥å£çš„å¤–éƒ¨å¯è§æ–¹æ³•çš„å…·ä½“å®ç°ï¼Œå¹¶å…è®¸ç¼–è¯‘å™¨å¼ºåˆ¶ä»¥ä¸Šè¦æ±‚ï¼‰ï¼Œä½†åªå¯ä»¥ä»ä¸€ä¸ªçˆ¶ç±»ç»§æ‰¿å®ç°ï¼ˆæ–¹æ³•ä¸æ•°æ®ï¼‰ã€‚å¾®è½¯çš„.NETç¼–ç¨‹è¯­è¨€ï¼Œä¾‹å¦‚C#å’ŒVisual Basic .NETä¹Ÿä½¿ç”¨äº†è¿™ç§æ¥å£çš„åšæ³•ã€‚
* [Multiple inheritance - Wikipedia](https://en.wikipedia.org/wiki/Multiple_inheritance)
	* Multiple inheritance has been a controversial issue for many years, with opponents pointing to its increased complexity and ambiguity in situations such as the "diamond problem", where it may be ambiguous as to which parent class a particular feature is inherited from if more than one parent class implements same feature. This can be addressed in various ways, including using virtual inheritance. Alternate methods of object composition not based on inheritance such as mixins and traits have also been proposed to address the ambiguity.
	* The "diamond problem" (sometimes referred to as the "Deadly Diamond of Death") is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?
	* For example, in the context of GUI software development, a class Button may inherit from both classes Rectangle (for appearance) and Clickable (for functionality/input handling), and classes Rectangle and Clickable both inherit from the Object class. Now if the equals method is called for a Button object and there is no such method in the Button class but there is an overridden equals method in Rectangle or Clickable (or both), which method should be eventually called?
	* It is called the "diamond problem" because of the shape of the class inheritance diagram in this situation. In this case, class A is at the top, both B and C separately beneath it, and D joins the two together at the bottom to form a diamond shape.
	* Languages have different ways of dealing with these problems of repeated inheritance.
		* C++ by default follows each inheritance path separately, so a D object would actually contain two separate A objects, and uses of A's members have to be properly qualified. If the inheritance from A to B and the inheritance from A to C are both marked "virtual" (for example, "class B : virtual public A"), C++ takes special care to only create one A object, and uses of A's members work correctly. If virtual inheritance and nonvirtual inheritance are mixed, there is a single virtual A, and a nonvirtual A for each nonvirtual inheritance path to A. C++ requires stating explicitly which parent class the feature to be used is invoked from i.e. Worker::Human.Age. C++ does not support explicit repeated inheritance since there would be no way to qualify which superclass to use (i.e. having a class appear more than once in a single derivation list [class Dog : public Animal, Animal]). C++ also allows a single instance of the multiple class to be created via the virtual inheritance mechanism (i.e. Worker::Human and Musician::Human will reference the same object).
		* Java 8 introduces default methods on interfaces. If A,B,C are interfaces, B,C can each provide a different implementation to an abstract method of A, causing the diamond problem. Either class D must reimplement the method (the body of which can simply forward the call to one of the super implementations), or the ambiguity will be rejected as a compile error. Prior to Java 8, Java was not subject to the Diamond problem risk, because it did not support multiple inheritance and interface default methods were not available.
		* Python has the same structure as Perl, but, unlike Perl, includes it in the syntax of the language. The order of inheritance affects the class semantics. Python had to deal with this upon the introduction of new-style classes, all of which have a common ancestor, object. Python creates a list of classes using the C3 linearization (or Method Resolution Order (MRO)) algorithm. That algorithm enforces two constraints: children precede their parents and if a class inherits from multiple classes, they are kept in the order specified in the tuple of base classes (however in this case, some classes high in the inheritance graph may precede classes lower in the graph). Thus, the method resolution order is: D, B, C, A.
	* Nevertheless, even when several interfaces declare the same method signature, as soon as that method is implemented (defined) anywhere in the inheritance chain, it overrides any implementation of that method in the chain above it (in its superclasses). Hence, at any given level in the inheritance chain, there can be at most one implementation of any method. Thus, single-inheritance method implementation does not exhibit the Diamond Problem even with multiple-inheritance of interfaces. With the introduction of default implementation for interfaces in Java 8 and C# 8, it is still possible to generate a Diamond Problem, although this will only appear as a compile-time error.

### è™šç»§æ‰¿

* [è™šç»§æ‰¿ - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E8%99%9A%E7%BB%A7%E6%89%BF)
	* `è™šç»§æ‰¿` æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­çš„ä¸€ç§æŠ€æœ¯ï¼Œæ˜¯æŒ‡ä¸€ä¸ªæŒ‡å®šçš„åŸºç±»ï¼Œåœ¨ç»§æ‰¿ä½“ç³»ç»“æ„ä¸­ï¼Œå°†å…¶æˆå‘˜æ•°æ®å®ä¾‹å…±äº«ç»™ä¹Ÿä»è¿™ä¸ªåŸºç±»å‹ç›´æ¥æˆ–é—´æ¥æ´¾ç”Ÿçš„å…¶å®ƒç±»ã€‚
	* ä¸¾ä¾‹æ¥è¯´ï¼šå‡å¦‚ç±»Aå’Œç±»Bå„è‡ªä»ç±»Xæ´¾ç”Ÿï¼ˆéè™šç»§æ‰¿ä¸”å‡è®¾ç±»XåŒ…å«ä¸€äº›æ•°æ®æˆå‘˜ï¼‰ï¼Œä¸”ç±»CåŒæ—¶å¤šç»§æ‰¿è‡ªç±»Aå’ŒBï¼Œé‚£ä¹ˆCçš„å¯¹è±¡å°±ä¼šæ‹¥æœ‰ä¸¤å¥—Xçš„å®ä¾‹æ•°æ®ï¼ˆå¯åˆ†åˆ«ç‹¬ç«‹è®¿é—®ï¼Œä¸€èˆ¬è¦ç”¨é€‚å½“çš„æ¶ˆæ­§ä¹‰é™å®šç¬¦ï¼‰ã€‚ä½†æ˜¯å¦‚æœç±»Aä¸Bå„è‡ªè™šç»§æ‰¿äº†ç±»Xï¼Œé‚£ä¹ˆCçš„å¯¹è±¡å°±åªåŒ…å«ä¸€å¥—ç±»Xçš„å®ä¾‹æ•°æ®ã€‚å¯¹äºè¿™ä¸€æ¦‚å¿µå…¸å‹å®ç°çš„ç¼–ç¨‹è¯­è¨€æ˜¯C++ã€‚
	* è¿™ä¸€ç‰¹æ€§åœ¨å¤šé‡ç»§æ‰¿åº”ç”¨ä¸­éå¸¸æœ‰ç”¨ï¼Œå¯ä»¥ä½¿å¾—è™šåŸºç±»å¯¹äºç”±å®ƒç›´æ¥æˆ–é—´æ¥æ´¾ç”Ÿçš„ç±»æ¥è¯´ï¼Œæ‹¥æœ‰ä¸€ä¸ªå…±åŒçš„åŸºç±»å¯¹è±¡å®ä¾‹ã€‚é¿å…ç”±äºå¸¦æœ‰æ­§ä¹‰çš„ç»„åˆè€Œäº§ç”Ÿçš„é—®é¢˜ï¼ˆå¦‚â€œè±å½¢ç»§æ‰¿é—®é¢˜â€ï¼‰ã€‚å…¶åŸç†æ˜¯ï¼Œé—´æ¥æ´¾ç”Ÿç±»ï¼ˆCï¼‰ç©¿é€äº†å…¶çˆ¶ç±»ï¼ˆä¸Šé¢ä¾‹å­ä¸­çš„Aä¸Bï¼‰ï¼Œå®è´¨ä¸Šç›´æ¥ç»§æ‰¿äº†è™šåŸºç±»Xã€‚
	* è¿™ä¸€æ¦‚å¿µä¸€èˆ¬ç”¨äºâ€œç»§æ‰¿â€åœ¨è¡¨ç°ä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè€Œéå‡ ä¸ªéƒ¨åˆ†çš„ç»„åˆæ—¶ã€‚åœ¨C++ä¸­ï¼ŒåŸºç±»å¯ä»¥é€šè¿‡ä½¿ç”¨å…³é”®å­—`virtual`æ¥å£°æ˜è™šç»§æ‰¿å…³ç³»ã€‚
	* `è™šåŸºç±»çš„åˆå§‹åŒ–`
		* ç”±äºè™šåŸºç±»æ˜¯å¤šä¸ªæ´¾ç”Ÿç±»å…±äº«çš„åŸºç±»ï¼Œå› æ­¤ç”±è°æ¥åˆå§‹åŒ–è™šåŸºç±»å¿…é¡»æ˜ç¡®ã€‚C++æ ‡å‡†è§„å®šï¼Œç”±æœ€æ´¾ç”Ÿç±»ç›´æ¥åˆå§‹åŒ–è™šåŸºç±»ã€‚å› æ­¤ï¼Œå¯¹é—´æ¥ç»§æ‰¿äº†è™šåŸºç±»çš„ç±»ï¼Œä¹Ÿå¿…é¡»èƒ½ç›´æ¥è®¿é—®å…¶è™šç»§æ‰¿æ¥çš„ç¥–å…ˆç±»ï¼Œä¹Ÿå³åº”çŸ¥é“å…¶è™šç»§æ‰¿æ¥çš„ç¥–å…ˆç±»çš„åœ°å€åç§»å€¼ã€‚
		* ä¾‹å¦‚ï¼Œå¸¸è§çš„â€œè±å½¢â€è™šç»§æ‰¿ä¾‹å­ä¸­ï¼Œä¸¤ä¸ªæ´¾ç”Ÿç±»ã€ä¸€ä¸ªæœ€æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°çš„åˆå§‹åŒ–åˆ—è¡¨ä¸­éƒ½å¯ä»¥ç»™å‡ºè™šåŸºç±»çš„åˆå§‹åŒ–ï¼›ä½†åªç”±æœ€æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°å®é™…æ‰§è¡Œè™šåŸºç±»çš„åˆå§‹åŒ–ã€‚
	* è™šç»§æ‰¿çš„åº”ç”¨ï¼šä¸å¯æ´¾ç”Ÿçš„finallyç±»
		* ä¸€ä¸ªç±»å¦‚æœä¸å¸Œæœ›è¢«ç»§æ‰¿ï¼Œç±»ä¼¼äºJavaä¸­çš„å…·æœ‰finallyæ€§è´¨çš„ç±»ï¼Œè¿™åœ¨C++ä¸­å¯ä»¥ç”¨è™šç»§æ‰¿æ¥å®ç°ï¼š
    ```c++
    template<typename T> class MakeFinally{
        private:
            MakeFinally(){};//åªæœ‰MakeFinallyçš„å‹ç±»æ‰å¯ä»¥æ„é€ MakeFinally
            ~MakeFinally(){};
        friend T;
    };

    class MyClass:public virtual  MakeFinally<MyClass>{};//MyClassæ˜¯ä¸å¯æ´¾ç”Ÿç±»

    //ç”±äºè™šç»§æ‰¿ï¼Œæ‰€ä»¥Dè¦ç›´æ¥è´Ÿè´£æ„é€ MakeFinallyç±»ï¼Œä»è€Œå¯¼è‡´ç¼–è¯‘æŠ¥é”™ï¼Œæ‰€ä»¥Dä½œä¸ºæ´¾ç”Ÿç±»æ˜¯ä¸åˆæ³•çš„ã€‚
    class D: public MyClass{};
    //å¦å¤–ï¼Œå¦‚æœDç±»æ²¡æœ‰å®ä¾‹åŒ–å¯¹è±¡ï¼Œå³æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œå®é™…ä¸ŠDç±»æ˜¯è¢«ç¼–è¯‘å™¨å¿½ç•¥æ‰è€Œä¸æŠ¥é”™

    int main()
    {
        MyClass var1;
        // D var2;  //è¿™ä¸€è¡Œç¼–è¯‘å°†å¯¼è‡´é”™è¯¯ï¼Œå› ä¸ºDç±»çš„é»˜è®¤æ„é€ å‡½æ•°ä¸åˆæ³•
    }
    ```
* [Virtual inheritance - Wikipedia](https://en.wikipedia.org/wiki/Virtual_inheritance)
	* This example to illustrates a case where base class A has a constructor variable msg and an additional ancestor E is derived from grandchild class D.
	* Here, A must be constructed in both D and E. Further, inspection of the variable msg illustrates the how class A becomes a direct base class of its deriving class, as opposed to a base class of any intermediate deriving classed between A and the final deriving class.
    ```c++
    #include <string>
    #include <iostream>

    class A {
        private:
            std::string _msg;
        public:
            A(std::string x): _msg(x) {}
            void test(){ std::cout<<"hello from A: "<<_msg <<"\n"; }
    };

    // B,C inherit A virtually
    class B: virtual public A   { public: B(std::string x):A("b"){}  };
    class C: virtual public A   { public: C(std::string x):A("c"){}  };

    // since B,C inherit A virtually, A must be constructed in each child
    class D: public         B,C { public: D(std::string x):A("d_a"),B("d_b"),C("d_c"){}  };
    class E: public         D   { public: E(std::string x):A("e_a"),D("e_d"){}  };

    // breaks without constructing A
    // class D: public         B,C { public: D(std::string x):B(x),C(x){}  };

    // breaks without constructing A
    //class E: public         D   { public: E(std::string x):D(x){}  };

    int main(int argc, char ** argv)
    {
        D d("d");
        d.test(); // hello from A: d_a

        E e("e");
        e.test(); // hello from A: e_a
    }    
    ```
* `è™šç»§æ‰¿`ç”¨äºè§£å†³`å¤šç»§æ‰¿`æ¡ä»¶ä¸‹çš„`è±å½¢ç»§æ‰¿`é—®é¢˜ï¼ˆæµªè´¹å­˜å‚¨ç©ºé—´ã€å­˜åœ¨äºŒä¹‰æ€§ï¼‰ã€‚
* åº•å±‚å®ç°åŸç†ä¸ç¼–è¯‘å™¨ç›¸å…³ï¼Œä¸€èˆ¬é€šè¿‡`è™šåŸºç±»æŒ‡é’ˆ`å’Œ`è™šåŸºç±»è¡¨`å®ç°ï¼Œæ¯ä¸ªè™šç»§æ‰¿çš„å­ç±»éƒ½æœ‰ä¸€ä¸ªè™šåŸºç±»æŒ‡é’ˆï¼ˆå ç”¨ä¸€ä¸ªæŒ‡é’ˆçš„å­˜å‚¨ç©ºé—´ï¼Œ4å­—èŠ‚ï¼‰å’Œè™šåŸºç±»è¡¨ï¼ˆä¸å ç”¨ç±»å¯¹è±¡çš„å­˜å‚¨ç©ºé—´ï¼‰ï¼ˆéœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œè™šåŸºç±»ä¾æ—§ä¼šåœ¨å­ç±»é‡Œé¢å­˜åœ¨æ‹·è´ï¼Œåªæ˜¯ä»…ä»…æœ€å¤šå­˜åœ¨ä¸€ä»½è€Œå·²ï¼Œå¹¶ä¸æ˜¯ä¸åœ¨å­ç±»é‡Œé¢äº†ï¼‰ï¼›å½“è™šç»§æ‰¿çš„å­ç±»è¢«å½“åšçˆ¶ç±»ç»§æ‰¿æ—¶ï¼Œè™šåŸºç±»æŒ‡é’ˆä¹Ÿä¼šè¢«ç»§æ‰¿ã€‚
* å®é™…ä¸Šï¼Œvbptr æŒ‡çš„æ˜¯`è™šåŸºç±»è¡¨æŒ‡é’ˆï¼ˆvirtual base table pointerï¼‰`ï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘äº†ä¸€ä¸ª`è™šåŸºç±»è¡¨ï¼ˆvirtual tableï¼‰`ï¼Œè™šè¡¨ä¸­è®°å½•äº†è™šåŸºç±»ä¸æœ¬ç±»çš„åç§»åœ°å€ï¼›é€šè¿‡åç§»åœ°å€ï¼Œè¿™æ ·å°±æ‰¾åˆ°äº†è™šåŸºç±»æˆå‘˜ï¼Œè€Œè™šç»§æ‰¿ä¹Ÿä¸ç”¨åƒæ™®é€šå¤šç»§æ‰¿é‚£æ ·ç»´æŒç€å…¬å…±åŸºç±»ï¼ˆè™šåŸºç±»ï¼‰çš„ä¸¤ä»½åŒæ ·çš„æ‹·è´ï¼ŒèŠ‚çœäº†å­˜å‚¨ç©ºé—´ã€‚

### è±å½¢ç»§æ‰¿

* The `diamond problem` (sometimes referred to as the "Deadly Diamond of Death") is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?
* [å…³äºC++ä¸­è±å½¢ç»§æ‰¿çš„è§£é‡Šå’Œå¤„ç†](https://mp.weixin.qq.com/s/OBSTK3kvjvqEpbmj8vXzpQ)
	* æ´¾ç”Ÿç±»ç»§æ‰¿çˆ¶ç±»ï¼ŒåŒæ—¶ä¹Ÿä¼šç»§æ‰¿çˆ¶ç±»ä¸­çš„æ‰€æœ‰æˆå‘˜å‰¯æœ¬ï¼Œä½†å¦‚æœåœ¨ç»§æ‰¿æ—¶ä¸€ä¸ªåŸºç±»åŒæ—¶è¢«ä¸¤ä¸ªå­ç±»ç»§æ‰¿ï¼Œç„¶åä¸€ä¸ªæ–°ç±»åˆåˆ†åˆ«ç”±ä¸Šé¢çš„ä¸¤ä¸ªå­ç±»æ´¾ç”Ÿå‡ºæ¥ã€‚è¿™æ ·ä»æŸç§ç¨‹åº¦æ¥è¯´å°±å½¢æˆäº†C++ä¸­çš„è±å½¢ç»§æ‰¿ï¼Œä¹Ÿå¯ä»¥å«åšé’»çŸ³ç»§æ‰¿
```c++
#include <iostream>
using namespace std;

class A
{
public:
    virtual void fun() { cout << "A::fun()" << endl; }
};

class B : public A
{
public:
    virtual void fun() { cout << "B::fun()" << endl; }
};

class C : public A
{
public:
    virtual void fun() { cout << "C::fun()" << endl; }
};

// Two classes virtually inheriting A
class BB : virtual public A
{
public:
    virtual void fun() { cout << "BB::fun()" << endl; }
};

class CC : virtual public A
{
public:
    virtual void fun() { cout << "CC::fun()" << endl; }
};

class D : public B, public C
{
public:
    void fun() { cout << "D::fun()" << endl; }
};

// class DD : public BB, public CC // Compile error : virtual function 'A::fun' has more than one final overrider in 'DD'
// {
// };

class DDD : public BB, public CC
{
public:
    void fun() { cout << "DDD::fun()" << endl; }
};

int main()
{
    // A *p1 = new D(); // Compile error : ambiguous conversion from derived class 'D' to base class 'A'

    // A *pDD = new DD(); // Compile error : cannot initialize a variable of type 'A *' with an rvalue of type 'DD *'

    A *pDDD = new DDD();
    pDDD->fun();  // DDD::fun() è°ƒç”¨æ´¾ç”Ÿç±»ä¸­çš„è™šå‡½æ•°

    DDD ddd;
    A &a = ddd;
    a.fun();    // DDD::fun() è°ƒç”¨æ´¾ç”Ÿç±»ä¸­çš„è™šå‡½æ•°

    return 0;
}
```

### å¤šæ€

* [å¤šæ€ (è®¡ç®—æœºç§‘å­¦) - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%80%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))
* [Polymorphism (computer science) - Wikipedia](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
	* åœ¨ç¼–ç¨‹è¯­è¨€å’Œç±»å‹è®ºä¸­ï¼Œå¤šæ€ï¼ˆè‹±è¯­ï¼špolymorphismï¼‰æŒ‡ä¸ºä¸åŒæ•°æ®ç±»å‹çš„å®ä½“æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œæˆ–ä½¿ç”¨ä¸€ä¸ªå•ä¸€çš„ç¬¦å·æ¥è¡¨ç¤ºå¤šä¸ªä¸åŒçš„ç±»å‹ã€‚
	* å¤šæ€çš„æœ€å¸¸è§ä¸»è¦ç±»åˆ«æœ‰ï¼š
		* ç‰¹è®¾å¤šæ€(Ad hoc polymorphism)ï¼šä¸ºä¸ªä½“çš„ç‰¹å®šç±»å‹çš„ä»»æ„é›†åˆå®šä¹‰ä¸€ä¸ªå…±åŒæ¥å£ã€‚
		* å‚æ•°å¤šæ€(Parametric polymorphism)ï¼šæŒ‡å®šä¸€ä¸ªæˆ–å¤šä¸ªç±»å‹ä¸é åå­—è€Œæ˜¯é å¯ä»¥æ ‡è¯†ä»»ä½•ç±»å‹çš„æŠ½è±¡ç¬¦å·ã€‚
		* å­ç±»å‹(Subtyping)ï¼ˆä¹Ÿå«åšå­ç±»å‹å¤šæ€æˆ–åŒ…å«å¤šæ€ï¼‰ï¼šä¸€ä¸ªåå­—æŒ‡ç§°å¾ˆå¤šä¸åŒçš„ç±»çš„å®ä¾‹ï¼Œè¿™äº›ç±»æœ‰æŸä¸ªå…±åŒçš„è¶…ç±»ã€‚
	* â€œç‰¹è®¾å¤šæ€â€æ¥æŒ‡ç§°ä¸€ä¸ªå¤šæ€å‡½æ•°å¯ä»¥åº”ç”¨äºæœ‰ä¸åŒç±»å‹çš„å®é™…å‚æ•°ä¸Šï¼Œä½†æ˜¯ä»¥æ¥å®ƒä»¬æ‰€åº”ç”¨åˆ°çš„å®é™…å‚æ•°ç±»å‹è€Œæœ‰ä¸åŒçš„è¡¨ç°ï¼ˆä¹Ÿå«åšä¸ºå‡½æ•°é‡è½½æˆ–è¿ç®—ç¬¦é‡è½½ï¼‰
	* å‚æ•°å¤šæ€å…è®¸å‡½æ•°æˆ–æ•°æ®ç±»å‹è¢«ä¸€èˆ¬æ€§çš„ä¹¦å†™ï¼Œä»è€Œå®ƒå¯ä»¥â€œç»Ÿä¸€â€çš„å¤„ç†å€¼è€Œä¸ç”¨ä¾èµ–äºå®ƒä»¬çš„ç±»å‹ã€‚å‚æ•°å¤šæ€æ˜¯ä½¿è¯­è¨€æ›´åŠ æœ‰è¡¨ç°åŠ›è€Œä»ç»´æŒå®Œå…¨çš„é™æ€ç±»å‹å®‰å…¨çš„ä¸€ç§æ–¹å¼ã€‚è¿™ç§å‡½æ•°å’Œæ•°æ®ç±»å‹è¢«åˆ†åˆ«ç§°ä¸ºâ€œæ³›åŒ–å‡½æ•°â€å’Œâ€œæ³›åŒ–æ•°æ®ç±»å‹â€ä»è€Œå½¢æˆäº†æ³›å‹ç¼–ç¨‹çš„åŸºç¡€ã€‚
	* å­ç±»å‹
		* åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼Œè®¡ç®—æœºç¨‹åºè¿è¡Œæ—¶ï¼Œç›¸åŒçš„æ¶ˆæ¯å¯èƒ½ä¼šé€ç»™å¤šä¸ªä¸åŒçš„ç±»åˆ«ä¹‹å¯¹è±¡ï¼Œè€Œç³»ç»Ÿå¯ä¾æ®å¯¹è±¡æ‰€å±ç±»åˆ«ï¼Œå¼•å‘å¯¹åº”ç±»åˆ«çš„æ–¹æ³•ï¼Œè€Œæœ‰ä¸åŒçš„è¡Œä¸ºã€‚ç®€å•æ¥è¯´ï¼Œæ‰€è°“å¤šæ€æ„æŒ‡ç›¸åŒçš„æ¶ˆæ¯ç»™äºˆä¸åŒçš„å¯¹è±¡ä¼šå¼•å‘ä¸åŒçš„åŠ¨ä½œã€‚æ¯”å¦‚æœ‰åŠ¨ç‰©ä¹‹ç±»åˆ«ï¼Œè€Œä¸”ç”±åŠ¨ç‰©ç»§æ‰¿å‡ºç±»åˆ«çŒ«å’Œç±»åˆ«ç‹—ï¼Œå¹¶å¯¹åŒä¸€æºè‡ªç±»åˆ«åŠ¨ç‰©ï¼ˆçˆ¶ç±»ï¼‰ä¹‹ä¸€æ¶ˆæ¯æœ‰ä¸åŒçš„å“åº”ï¼Œå¦‚ç±»åˆ«åŠ¨ç‰©æœ‰â€œå«â€ä¹‹åŠ¨ä½œï¼Œè€Œç±»åˆ«çŒ«ä¼šâ€œå–µå–µâ€ï¼Œç±»åˆ«ç‹—åˆ™ä¼šâ€œæ±ªæ±ªâ€ï¼Œåˆ™ç§°ä¹‹ä¸ºå¤šæ€ã€‚
		* å¤šæ€å¯åˆ†ä¸ºå˜é‡å¤šæ€ä¸å‡½æ•°å¤šæ€ã€‚å˜é‡å¤šæ€æ˜¯æŒ‡ï¼šåŸºç±»å‹çš„å˜é‡ï¼ˆå¯¹äºC++æ˜¯å¼•ç”¨æˆ–æŒ‡é’ˆï¼‰å¯ä»¥è¢«èµ‹å€¼åŸºç±»å‹å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥è¢«èµ‹å€¼æ´¾ç”Ÿç±»å‹çš„å¯¹è±¡ã€‚å‡½æ•°å¤šæ€æ˜¯æŒ‡ï¼Œç›¸åŒçš„å‡½æ•°è°ƒç”¨ç•Œé¢ï¼ˆå‡½æ•°åä¸å®å‚è¡¨ï¼‰ï¼Œä¼ é€ç»™ä¸€ä¸ªå¯¹è±¡å˜é‡ï¼Œå¯ä»¥æœ‰ä¸åŒçš„è¡Œä¸ºï¼Œè¿™è§†è¯¥å¯¹è±¡å˜é‡æ‰€æŒ‡å‘çš„å¯¹è±¡ç±»å‹è€Œå®šã€‚å¤šæ€ä¹Ÿå¯å®šä¹‰ä¸ºâ€œä¸€ç§å°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”çš„èƒ½åŠ›â€ï¼Œå˜é‡å¤šæ€æ˜¯å‡½æ•°å¤šæ€çš„åŸºç¡€ã€‚
	* ä¾æ®å®ç°æ—¶åšå‡ºçš„é€‰æ‹©ï¼Œå¤šæ€å¯åˆ†ä¸ºï¼š
		* `åŠ¨æ€å¤šæ€ï¼ˆdynamic polymorphismï¼‰`:ç”Ÿæ•ˆäºè¿è¡ŒæœŸã€‚
		* `é™æ€å¤šæ€ï¼ˆstatic polymorphismï¼‰`ï¼šå°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”ï¼Œç”±äºè¿™ç§å…³è”å¤„ç†äºç¼–è¯‘æœŸè€Œéè¿è¡ŒæœŸï¼Œå› æ­¤è¢«ç§°ä¸ºâ€œé™æ€â€ã€‚å¯ä»¥ç”¨æ¥å®ç°ç±»å‹å®‰å…¨ã€è¿è¡Œé«˜æ•ˆçš„åŒè´¨å¯¹è±¡é›†åˆæ“ä½œã€‚C++ STLä¸é‡‡ç”¨åŠ¨æ€å¤šæ€æ¥å®ç°å°±æ˜¯ä¸ªä¾‹å­ã€‚
	* å¯¹äºC++è¯­è¨€ï¼Œå¸¦å˜é‡çš„å®å’Œå‡½æ•°é‡è½½æœºåˆ¶ä¹Ÿå…è®¸å°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”ã€‚ç„¶è€Œï¼Œä¹ æƒ¯ä¸Šå¹¶ä¸å°†è¿™ç§å‡½æ•°å¤šæ€ã€å®å¤šæ€å±•ç°å‡ºæ¥çš„è¡Œä¸ºç§°ä¸ºå¤šæ€ï¼ˆæˆ–é™æ€å¤šæ€ï¼‰ï¼Œå¦åˆ™å°±è¿Cè¯­è¨€ä¹Ÿå…·æœ‰å®å¤šæ€äº†ã€‚è°ˆåŠå¤šæ€æ—¶ï¼Œé»˜è®¤å°±æ˜¯æŒ‡åŠ¨æ€å¤šæ€ï¼Œè€Œé™æ€å¤šæ€åˆ™æ˜¯æŒ‡åŸºäºæ¨¡æ¿çš„å¤šæ€ã€‚
* ä»€ä¹ˆæ˜¯å¤šæ€ï¼Ÿå¤šæ€å¦‚ä½•å®ç°ï¼Ÿ
	* `å¤šæ€`ï¼šå¤šæ€å°±æ˜¯ä¸åŒç»§æ‰¿ç±»çš„å¯¹è±¡ï¼Œå¯¹åŒä¸€æ¶ˆæ¯åšå‡ºä¸åŒçš„å“åº”ï¼ŒåŸºç±»çš„æŒ‡é’ˆæŒ‡å‘æˆ–ç»‘å®šåˆ°æ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œä½¿å¾—åŸºç±»æŒ‡é’ˆå‘ˆç°ä¸åŒçš„è¡¨ç°æ–¹å¼ã€‚åœ¨åŸºç±»çš„å‡½æ•°å‰åŠ ä¸Š`virtual`å…³é”®å­—ï¼Œåœ¨æ´¾ç”Ÿç±»ä¸­é‡å†™è¯¥å‡½æ•°ï¼Œè¿è¡Œæ—¶å°†ä¼šæ ¹æ®å¯¹è±¡çš„å®é™…ç±»å‹æ¥è°ƒç”¨ç›¸åº”çš„å‡½æ•°ã€‚å¦‚æœå¯¹è±¡ç±»å‹æ˜¯æ´¾ç”Ÿç±»ï¼Œå°±è°ƒç”¨æ´¾ç”Ÿç±»çš„å‡½æ•°ï¼›å¦‚æœå¯¹è±¡ç±»å‹æ˜¯åŸºç±»ï¼Œå°±è°ƒç”¨åŸºç±»çš„å‡½æ•°ã€‚
	* å®ç°æ–¹æ³•ï¼šå¤šæ€æ˜¯é€šè¿‡`è™šå‡½æ•°`å®ç°çš„ï¼Œè™šå‡½æ•°çš„åœ°å€ä¿å­˜åœ¨`è™šå‡½æ•°è¡¨`ä¸­ï¼Œè™šå‡½æ•°è¡¨çš„åœ°å€ä¿å­˜åœ¨å«æœ‰è™šå‡½æ•°çš„ç±»çš„å®ä¾‹å¯¹è±¡çš„å†…å­˜ç©ºé—´ä¸­ã€‚
	* å®ç°è¿‡ç¨‹ï¼š
		* åœ¨ç±»ä¸­ç”¨ virtual å…³é”®å­—å£°æ˜çš„å‡½æ•°å«åšè™šå‡½æ•°ï¼›
		* å­˜åœ¨è™šå‡½æ•°çš„ç±»éƒ½æœ‰ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œå½“åˆ›å»ºä¸€ä¸ªè¯¥ç±»çš„å¯¹è±¡æ—¶ï¼Œè¯¥å¯¹è±¡æœ‰ä¸€ä¸ªæŒ‡å‘è™šå‡½æ•°è¡¨çš„è™šè¡¨æŒ‡é’ˆï¼ˆè™šå‡½æ•°è¡¨å’Œç±»å¯¹åº”çš„ï¼Œè™šè¡¨æŒ‡é’ˆæ˜¯å’Œå¯¹è±¡å¯¹åº”ï¼‰ï¼›
		* å½“åŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ï¼ŒåŸºç±»æŒ‡é’ˆè°ƒç”¨è™šå‡½æ•°æ—¶ï¼ŒåŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»çš„è™šè¡¨æŒ‡é’ˆï¼Œç”±äºè¯¥è™šè¡¨æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»è™šå‡½æ•°è¡¨ï¼Œé€šè¿‡éå†è™šè¡¨ï¼Œå¯»æ‰¾ç›¸åº”çš„è™šå‡½æ•°ã€‚
* [C++ç¼–è¯‘æœŸå¤šæ€ä¸è¿è¡ŒæœŸå¤šæ€](https://mp.weixin.qq.com/s/Xyo97HNDaelUy6F8aiMwIA)
	* https://www.cnblogs.com/QG-whz/p/5132745.html
	* åœ¨é¢å‘å¯¹è±¡C++ç¼–ç¨‹ä¸­ï¼Œ`å¤šæ€`æ˜¯OOä¸‰å¤§ç‰¹æ€§ä¹‹ä¸€ï¼Œè¿™ç§å¤šæ€ç§°ä¸º`è¿è¡ŒæœŸå¤šæ€`ï¼Œä¹Ÿç§°ä¸º`åŠ¨æ€å¤šæ€`ï¼›åœ¨æ³›å‹ç¼–ç¨‹ä¸­ï¼Œå¤šæ€åŸºäºtemplate(æ¨¡æ¿)çš„å…·ç°åŒ–ä¸å‡½æ•°çš„é‡è½½è§£æï¼Œè¿™ç§å¤šæ€åœ¨ç¼–è¯‘æœŸè¿›è¡Œï¼Œå› æ­¤ç§°ä¸º`ç¼–è¯‘æœŸå¤šæ€`æˆ–`é™æ€å¤šæ€`ã€‚
	* è¿è¡ŒæœŸå¤šæ€
	    * è¿è¡ŒæœŸå¤šæ€çš„è®¾è®¡æ€æƒ³è¦å½’ç»“åˆ°ç±»ç»§æ‰¿ä½“ç³»çš„è®¾è®¡ä¸Šå»ã€‚å¯¹äºæœ‰ç›¸å…³åŠŸèƒ½çš„å¯¹è±¡é›†åˆï¼Œæˆ‘ä»¬æ€»å¸Œæœ›èƒ½å¤ŸæŠ½è±¡å‡ºå®ƒä»¬å…±æœ‰çš„åŠŸèƒ½é›†åˆï¼Œåœ¨åŸºç±»ä¸­å°†è¿™äº›åŠŸèƒ½å£°æ˜ä¸ºè™šæ¥å£ï¼ˆè™šå‡½æ•°ï¼‰ï¼Œç„¶åç”±å­ç±»ç»§æ‰¿åŸºç±»å»é‡å†™è¿™äº›è™šæ¥å£ï¼Œä»¥å®ç°å­ç±»ç‰¹æœ‰çš„å…·ä½“åŠŸèƒ½ã€‚å…¸å‹çš„æˆ‘ä»¬ä¼šä¸¾ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š
	    * è¿è¡ŒæœŸå¤šæ€é€šè¿‡è™šå‡½æ•°å‘ç”Ÿäºè¿è¡ŒæœŸ
        ```c++
        class Animal
        {
        public :
            virtual void shout() = 0;
        };
        class Dog :public Animal
        {
        public:
            virtual void shout(){ cout << "æ±ªæ±ªï¼"<<endl; }
        };
        class Cat :public Animal
        {
        public:
            virtual void shout(){ cout << "å–µå–µ~"<<endl; }
        };
        class Bird : public Animal
        {
        public:
            virtual void shout(){ cout << "å½å–³!"<<endl; }
        };

        int main()
        {
            Animal * anim1 = new Dog;
            Animal * anim2 = new Cat;
            Animal * anim3 = new Bird;

           //è—‰ç”±æŒ‡é’ˆï¼ˆæˆ–å¼•ç”¨ï¼‰è°ƒç”¨çš„æ¥å£ï¼Œåœ¨è¿è¡ŒæœŸç¡®å®šæŒ‡é’ˆï¼ˆæˆ–å¼•ç”¨ï¼‰æ‰€æŒ‡å¯¹è±¡çš„çœŸæ­£ç±»å‹ï¼Œè°ƒç”¨è¯¥ç±»å‹å¯¹åº”çš„æ¥å£
            anim1->shout();
            anim2->shout();
            anim3->shout();

            //delete å¯¹è±¡
            ...
           return 0;
        }
        ```
    * ç¼–è¯‘æœŸå¤šæ€
        * å¯¹æ¨¡æ¿å‚æ•°è€Œè¨€ï¼Œå¤šæ€æ˜¯é€šè¿‡æ¨¡æ¿å…·ç°åŒ–å’Œå‡½æ•°é‡è½½è§£æå®ç°çš„ã€‚ä»¥ä¸åŒçš„æ¨¡æ¿å‚æ•°å…·ç°åŒ–å¯¼è‡´è°ƒç”¨ä¸åŒçš„å‡½æ•°ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„ç¼–è¯‘æœŸå¤šæ€ã€‚
        * ç›¸æ¯”è¾ƒäºè¿è¡ŒæœŸå¤šæ€ï¼Œå®ç°ç¼–è¯‘æœŸå¤šæ€çš„ç±»ä¹‹é—´å¹¶ä¸éœ€è¦æˆä¸ºä¸€ä¸ªç»§æ‰¿ä½“ç³»ï¼Œå®ƒä»¬ä¹‹é—´å¯ä»¥æ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œä½†çº¦æŸæ˜¯å®ƒä»¬éƒ½æœ‰ç›¸åŒçš„éšå¼æ¥å£ã€‚æˆ‘ä»¬å°†ä¸Šé¢çš„ä¾‹å­æ”¹å†™ä¸º:
        * åœ¨ç¼–è¯‘ä¹‹å‰ï¼Œå‡½æ•°æ¨¡æ¿ä¸­t.shout()è°ƒç”¨çš„æ˜¯å“ªä¸ªæ¥å£å¹¶ä¸ç¡®å®šã€‚åœ¨ç¼–è¯‘æœŸé—´ï¼Œç¼–è¯‘å™¨æ¨æ–­å‡ºæ¨¡æ¿å‚æ•°ï¼Œå› æ­¤ç¡®å®šè°ƒç”¨çš„shoutæ˜¯å“ªä¸ªå…·ä½“ç±»å‹çš„æ¥å£ã€‚ä¸åŒçš„æ¨æ–­ç»“æœè°ƒç”¨ä¸åŒçš„å‡½æ•°ï¼Œè¿™å°±æ˜¯ç¼–è¯‘å™¨å¤šæ€ã€‚è¿™ç±»ä¼¼äºé‡è½½å‡½æ•°åœ¨ç¼–è¯‘å™¨è¿›è¡Œæ¨å¯¼ï¼Œä»¥ç¡®å®šå“ªä¸€ä¸ªå‡½æ•°è¢«è°ƒç”¨ã€‚
        ```c++
        class Animal
        {
        public :
            void shout() { cout << "å‘å‡ºåŠ¨ç‰©çš„å«å£°" << endl; };
        };
        class Dog
        {
        public:
            void shout(){ cout << "æ±ªæ±ªï¼"<<endl; }
        };
        class Cat
        {
        public:
            void shout(){ cout << "å–µå–µ~"<<endl; }
        };
        class Bird
        {
        public:
            void shout(){ cout << "å½å–³!"<<endl; }
        };
        template <typename T>
        void  animalShout(T & t)
        {
            t.shout();
        }
        int main()
        {
            Animal anim;
            Dog dog;
            Cat cat;
            Bird bird;

            animalShout(anim);
            animalShout(dog);
            animalShout(cat);
            animalShout(bird);

            getchar();
        }
        ```
    * è¿è¡ŒæœŸå¤šæ€ä¸ç¼–è¯‘æœŸå¤šæ€ä¼˜ç¼ºç‚¹åˆ†æ
        * è¿è¡ŒæœŸå¤šæ€ä¼˜ç‚¹
            * OOè®¾è®¡ä¸­é‡è¦çš„ç‰¹æ€§ï¼Œå¯¹å®¢è§‚ä¸–ç•Œç›´è§‰è®¤è¯†ã€‚
            * èƒ½å¤Ÿå¤„ç†åŒä¸€ä¸ªç»§æ‰¿ä½“ç³»ä¸‹çš„å¼‚è´¨ç±»é›†åˆã€‚
        * è¿è¡ŒæœŸå¤šæ€ç¼ºç‚¹
            * è¿è¡ŒæœŸé—´è¿›è¡Œè™šå‡½æ•°ç»‘å®šï¼Œæé«˜äº†ç¨‹åºè¿è¡Œå¼€é”€ã€‚
            * åºå¤§çš„ç±»ç»§æ‰¿å±‚æ¬¡ï¼Œå¯¹æ¥å£çš„ä¿®æ”¹æ˜“å½±å“ç±»ç»§æ‰¿å±‚æ¬¡ã€‚
            * ç”±äºè™šå‡½æ•°åœ¨è¿è¡ŒæœŸåœ¨ç¡®å®šï¼Œæ‰€ä»¥ç¼–è¯‘å™¨æ— æ³•å¯¹è™šå‡½æ•°è¿›è¡Œä¼˜åŒ–ã€‚
            * è™šè¡¨æŒ‡é’ˆå¢å¤§äº†å¯¹è±¡ä½“ç§¯ï¼Œç±»ä¹Ÿå¤šäº†ä¸€å¼ è™šå‡½æ•°è¡¨ï¼Œå½“ç„¶ï¼Œè¿™æ˜¯ç†æ‰€åº”å½“å€¼å¾—ä»˜å‡ºçš„èµ„æºæ¶ˆè€—ï¼Œåˆ—ä¸ºç¼ºç‚¹æœ‰ç‚¹å‹‰å¼ºã€‚
        * ç¼–è¯‘æœŸå¤šæ€ä¼˜ç‚¹
            * å®ƒå¸¦æ¥äº†æ³›å‹ç¼–ç¨‹çš„æ¦‚å¿µï¼Œä½¿å¾—C++æ‹¥æœ‰æ³›å‹ç¼–ç¨‹ä¸STLè¿™æ ·çš„å¼ºå¤§æ­¦å™¨ã€‚
            * åœ¨ç¼–è¯‘å™¨å®Œæˆå¤šæ€ï¼Œæé«˜è¿è¡ŒæœŸæ•ˆç‡ã€‚
            * å…·æœ‰å¾ˆå¼ºçš„é€‚é…æ€§ä¸æ¾è€¦åˆæ€§ï¼Œå¯¹äºç‰¹æ®Šç±»å‹å¯ç”±æ¨¡æ¿åç‰¹åŒ–ã€å…¨ç‰¹åŒ–æ¥å¤„ç†ã€‚
        * ç¼–è¯‘æœŸå¤šæ€ç¼ºç‚¹
            * ç¨‹åºå¯è¯»æ€§é™ä½ï¼Œä»£ç è°ƒè¯•å¸¦æ¥å›°éš¾ã€‚
            * æ— æ³•å®ç°æ¨¡æ¿çš„åˆ†ç¦»ç¼–è¯‘ï¼Œå½“å·¥ç¨‹å¾ˆå¤§æ—¶ï¼Œç¼–è¯‘æ—¶é—´ä¸å¯å°è§‘ã€‚
            * æ— æ³•å¤„ç†å¼‚è´¨å¯¹è±¡é›†åˆã€‚
    * å…³äºæ˜¾å¼æ¥å£ä¸éšå¼æ¥å£
        * æ‰€è°“çš„æ˜¾å¼æ¥å£æ˜¯æŒ‡ç±»ç»§æ‰¿å±‚æ¬¡ä¸­å®šä¹‰çš„æ¥å£æˆ–æ˜¯æŸä¸ªå…·ä½“ç±»æä¾›çš„æ¥å£ï¼Œæ€»è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬èƒ½å¤Ÿåœ¨æºä»£ç ä¸­æ‰¾åˆ°è¿™ä¸ªæ¥å£.æ˜¾å¼æ¥å£ä»¥å‡½æ•°ç­¾åä¸ºä¸­å¿ƒï¼Œä¾‹å¦‚
            ```c++
            void AnimalShot(Animal & anim)
            {
                anim.shout();
            }
            ```
        * æˆ‘ä»¬ç§°shoutä¸ºä¸€ä¸ªæ˜¾å¼æ¥å£ã€‚åœ¨è¿è¡ŒæœŸå¤šæ€ä¸­çš„æ¥å£çš†ä¸ºæ˜¾å¼æ¥å£ã€‚
        * è€Œå¯¹æ¨¡æ¿å‚æ•°è€Œè¨€ï¼Œæ¥å£æ˜¯éšå¼çš„ï¼Œå¥ åŸºäºæœ‰æ•ˆè¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼š
            ```c++
            template <typename T>
            void AnimalShot(T & anim)
            {
                anim.shout();
            }
            ```
        * å¯¹äºanimæ¥è¯´ï¼Œå¿…é¡»æ”¯æŒå“ªä¸€ç§æ¥å£ï¼Œè¦ç”±æ¨¡æ¿å‚æ•°æ‰§è¡Œäºanimèº«ä¸Šçš„æ“ä½œæ¥å†³å®šï¼Œåœ¨ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­ï¼ŒTå¿…é¡»æ”¯æŒshout()æ“ä½œï¼Œé‚£ä¹ˆshoutå°±æ˜¯Tçš„ä¸€ä¸ªéšå¼æ¥å£ã€‚

## ç±»ç›¸å…³

* è™šå‡½æ•°
  * [è™šå‡½æ•° - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/%E8%99%9A%E5%87%BD%E6%95%B0)
  * åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡é¢†åŸŸï¼ŒC++ã€Object Pascal ç­‰è¯­è¨€ä¸­æœ‰è™šå‡½æ•°ï¼ˆè‹±è¯­ï¼švirtual functionï¼‰æˆ–è™šæ–¹æ³•ï¼ˆè‹±è¯­ï¼švirtual methodï¼‰çš„æ¦‚å¿µã€‚è¿™ç§å‡½æ•°æˆ–æ–¹æ³•å¯ä»¥è¢«å­ç±»ç»§æ‰¿å’Œè¦†ç›–ï¼Œé€šå¸¸ä½¿ç”¨åŠ¨æ€åˆ†æ´¾å®ç°ã€‚è¿™ä¸€æ¦‚å¿µæ˜¯é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼ˆè¿è¡Œæ—¶ï¼‰å¤šæ€çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚ç®€è¨€ä¹‹ï¼Œè™šå‡½æ•°å¯ä»¥ç»™å‡ºç›®æ ‡å‡½æ•°çš„å®šä¹‰ï¼Œä½†è¯¥ç›®æ ‡çš„å…·ä½“æŒ‡å‘åœ¨ç¼–è¯‘æœŸå¯èƒ½æ— æ³•ç¡®å®šã€‚
  * è™šå‡½æ•°åœ¨è®¾è®¡æ¨¡å¼æ–¹é¢æ‰®æ¼”é‡è¦è§’è‰²ã€‚ä¾‹å¦‚ï¼Œã€Šè®¾è®¡æ¨¡å¼ã€‹ä¸€ä¹¦ä¸­æåˆ°çš„23ç§è®¾è®¡æ¨¡å¼ä¸­ï¼Œä»…5ä¸ªå¯¹è±¡åˆ›å»ºæ¨¡å¼å°±æœ‰4ä¸ªç”¨åˆ°äº†è™šå‡½æ•°ï¼ˆæŠ½è±¡å·¥å‚ã€å·¥å‚æ–¹æ³•ã€ç”Ÿæˆå™¨ã€åŸå‹ï¼‰ï¼Œåªæœ‰å•ä¾‹æ²¡æœ‰ç”¨åˆ°ã€‚
  * è™šå‡½æ•°æ¦‚å¿µçš„å¼•å…¥å¯ä»¥è§£å†³è¿™æ ·çš„é—®é¢˜ï¼š
    * åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼Œæ´¾ç”Ÿç±»ç»§æ‰¿è‡ªåŸºç±»ã€‚ä½¿ç”¨æŒ‡é’ˆæˆ–å¼•ç”¨è®¿é—®æ´¾ç”Ÿç±»å¯¹è±¡æ—¶ï¼ŒæŒ‡é’ˆæˆ–å¼•ç”¨æœ¬èº«æ‰€æŒ‡å‘çš„ç±»å‹æ˜¯åŸºç±»è€Œä¸æ˜¯æ´¾ç”Ÿç±»ã€‚å¦‚æœæ´¾ç”Ÿç±»è¦†ç›–äº†åŸºç±»ä¸­çš„æ–¹æ³•ï¼Œé€šè¿‡ä¸Šè¿°æŒ‡é’ˆæˆ–å¼•ç”¨è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œå¯ä»¥æœ‰ä¸¤ç§ç»“æœï¼š
      * è°ƒç”¨åˆ°åŸºç±»çš„æ–¹æ³•ï¼šç¼–è¯‘å™¨æ ¹æ®æŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹å†³å®šï¼Œç§°ä½œâ€œæ—©ç»‘å®šâ€ï¼›
      * è°ƒç”¨åˆ°æ´¾ç”Ÿç±»çš„æ–¹æ³•ï¼šè¯­è¨€çš„è¿è¡Œæ—¶ç³»ç»Ÿæ ¹æ®å¯¹è±¡çš„å®é™…ç±»å‹å†³å®šï¼Œç§°ä½œâ€œè¿Ÿç»‘å®šâ€ã€‚
    * è™šå‡½æ•°çš„æ•ˆæœå±äºåè€…ã€‚å¦‚æœé—®é¢˜ä¸­åŸºç±»çš„å‡½æ•°æ˜¯â€œè™šâ€çš„ï¼Œåˆ™è°ƒç”¨åˆ°çš„éƒ½æ˜¯æœ€ç»ˆæ´¾ç”Ÿç±»ï¼ˆè‹±è¯­ï¼šmost-derived classï¼‰ä¸­çš„å‡½æ•°å®ç°ï¼Œä¸æŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹æ— å…³ã€‚åä¹‹ï¼Œå¦‚æœå‡½æ•°éâ€œè™šâ€ï¼Œè°ƒç”¨åˆ°çš„å‡½æ•°å°±åœ¨ç¼–è¯‘æœŸæ ¹æ®æŒ‡é’ˆæˆ–è€…å¼•ç”¨æ‰€æŒ‡å‘çš„ç±»å‹å†³å®šã€‚
    * æœ‰äº†è™šå‡½æ•°ï¼Œç¨‹åºç”šè‡³èƒ½å¤Ÿè°ƒç”¨ç¼–è¯‘æœŸè¿˜ä¸å­˜åœ¨çš„å‡½æ•°ã€‚
    * åœ¨ C++ ä¸­ï¼Œåœ¨åŸºç±»çš„æˆå‘˜å‡½æ•°å£°æ˜å‰åŠ ä¸Šå…³é”®å­— virtual å³å¯è®©è¯¥å‡½æ•°æˆä¸º è™šå‡½æ•°ï¼Œæ´¾ç”Ÿç±»ä¸­å¯¹æ­¤å‡½æ•°çš„ä¸åŒå®ç°éƒ½ä¼šç»§æ‰¿è¿™ä¸€ä¿®é¥°ç¬¦ï¼Œå…è®¸åç»­æ´¾ç”Ÿç±»è¦†ç›–ï¼Œè¾¾åˆ°è¿Ÿç»‘å®šçš„æ•ˆæœã€‚å³ä¾¿æ˜¯åŸºç±»ä¸­çš„æˆå‘˜å‡½æ•°è°ƒç”¨è™šå‡½æ•°ï¼Œä¹Ÿä¼šè°ƒç”¨åˆ°æ´¾ç”Ÿç±»ä¸­çš„ç‰ˆæœ¬ã€‚
  ```c++
  # include <iostream>
  # include <vector>

  using namespace std;
  class Animal
  {
  public:
      // void eat() const { cout << "I eat like a generic Animal." << endl; }
      // ~Animal() {}
      virtual void eat() const { cout << "I eat like a generic Animal." << endl; }
      virtual ~Animal() {}
  };

  class Wolf : public Animal
  {
  public:
      void eat() const { cout << "I eat like a wolf!" << endl; }
  };

  class Fish : public Animal
  {
  public:
      void eat() const { cout << "I eat like a fish!" << endl; }
  };

  class GoldFish : public Fish
  {
  public:
      void eat() const { cout << "I eat like a goldfish!" << endl; }
  };


  class OtherAnimal : public Animal
  {
  };

  int main()
  {
      std::vector<Animal*> animals;
      animals.push_back( new Animal() );
      animals.push_back( new Wolf() );
      animals.push_back( new Fish() );
      animals.push_back( new GoldFish() );
      animals.push_back( new OtherAnimal() );

      /*
      ä»¥ä¸‹æ˜¯è™šå‡½æ•° Animal::eat() çš„è¾“å‡ºï¼š
      I eat like a generic Animal.
      I eat like a wolf!
      I eat like a fish!
      I eat like a goldfish!
      I eat like a generic Animal.

      å½“ Animal::eat() ä¸æ˜¯è¢«å®£å‘Šä¸ºè™šå‡½æ•°æ—¶ï¼Œè¾“å‡ºå¦‚ä¸‹æ‰€ç¤ºï¼š
      I eat like a generic Animal.
      I eat like a generic Animal.
      I eat like a generic Animal.
      I eat like a generic Animal.
      I eat like a generic Animal.
      */
      for( std::vector<Animal*>::const_iterator it = animals.begin();
         it != animals.end(); ++it)
      {
          (*it)->eat();
          delete *it;
      }

     return 0;
  }   
  ```
  * åœ¨Javaè¯­è¨€ä¸­, æ‰€æœ‰çš„æ–¹æ³•é»˜è®¤éƒ½æ˜¯"è™šå‡½æ•°". åªæœ‰ä»¥å…³é”®å­— final æ ‡è®°çš„æ–¹æ³•æ‰æ˜¯éè™šå‡½æ•°.
  * åœ¨ C# è¯­è¨€ä¸­, å¯¹åŸºç±»ä¸­çš„ä»»ä½•è™šæ–¹æ³•å¿…é¡»ç”¨ virtual ä¿®é¥°, è€Œæ´¾ç”Ÿç±»ä¸­ç”±åŸºç±»ç»§æ‰¿è€Œæ¥çš„é‡è½½æ–¹æ³•å¿…é¡»ç”¨ override ä¿®é¥°.
  * æŠ½è±¡ç±»å’Œçº¯è™šå‡½æ•°
    * çº¯è™šå‡½æ•°æˆ–çº¯è™šæ–¹æ³•æ˜¯ä¸€ä¸ªéœ€è¦è¢«éæŠ½è±¡çš„æ´¾ç”Ÿç±»è¦†ç›–ï¼ˆoverrideï¼‰çš„è™šå‡½æ•°. åŒ…å«çº¯è™šæ–¹æ³•çš„ç±»è¢«ç§°ä½œæŠ½è±¡ç±»; æŠ½è±¡ç±»ä¸èƒ½è¢«ç›´æ¥å®ä¾‹åŒ–ã€‚ ä¸€ä¸ªæŠ½è±¡åŸºç±»çš„ä¸€ä¸ªå­ç±»åªæœ‰åœ¨æ‰€æœ‰çš„çº¯è™šå‡½æ•°åœ¨è¯¥ç±»(æˆ–å…¶çˆ¶ç±»)å†…ç»™å‡ºå®ç°æ—¶, æ‰èƒ½ç›´æ¥å®ä¾‹åŒ–. çº¯è™šæ–¹æ³•é€šå¸¸åªæœ‰å£°æ˜(ç­¾å)è€Œæ²¡æœ‰å®šä¹‰(å®ç°)ï¼Œä½†æœ‰ç‰¹ä¾‹æƒ…å½¢è¦æ±‚çº¯è™šå‡½æ•°å¿…é¡»ç»™å‡ºå‡½æ•°ä½“å®šä¹‰.
    * è™½ç„¶çº¯è™šæ–¹æ³•é€šå¸¸åœ¨å®šä¹‰å®ƒçš„ç±»ä¸­æ²¡æœ‰å®ç°, åœ¨ C++ è¯­è¨€ä¸­, å…è®¸çº¯è™šå‡½æ•°åœ¨å®šä¹‰å®ƒçš„ç±»ä¸­åŒ…å«å…¶å®ç°, è¿™ä¸ºæ´¾ç”Ÿç±»æä¾›äº†å¤‡ç”¨æˆ–é»˜è®¤çš„è¡Œä¸º. C++çš„è™šåŸºç±»çš„è™šææ„å‡½æ•°å¿…é¡»æä¾›å‡½æ•°ä½“å®šä¹‰ï¼Œå¦åˆ™é“¾æ¥æ—¶ï¼ˆlinkingï¼‰åœ¨ææ„è¯¥æŠ½è±¡ç±»çš„æ´¾ç”Ÿå®ä¾‹å¯¹è±¡çš„è¯­å¥å¤„ä¼šæŠ¥é”™ã€‚
    * åœ¨C++è¯­è¨€ä¸­, çº¯è™šå‡½æ•°ç”¨ä¸€ç§ç‰¹åˆ«çš„è¯­æ³•[=0]å®šä¹‰ï¼ˆä½† VS ä¹Ÿæ”¯æŒ abstract å…³é”®å­—ï¼švirtual ReturnType Function()abstract;ï¼‰
    * çº¯è™šå‡½æ•°çš„å®šä¹‰ä»…æä¾›æ–¹æ³•çš„åŸå‹. è™½ç„¶åœ¨æŠ½è±¡ç±»ä¸­é€šå¸¸ä¸æä¾›çº¯è™šå‡½æ•°çš„å®ç°, ä½†æ˜¯æŠ½è±¡ç±»ä¸­å¯ä»¥åŒ…å«å…¶å®ç°, è€Œä¸”å¯ä»¥ä¸åœ¨å£°æ˜çš„åŒæ—¶ç»™å‡ºå®šä¹‰[2]. æ¯ä¸ªéæŠ½è±¡å­ç±»ä»ç„¶éœ€è¦é‡è½½è¯¥æ–¹æ³•, æŠ½è±¡ç±»ä¸­å®ç°çš„è°ƒç”¨å¯ä»¥é‡‡ç”¨ä»¥ä¸‹è¿™ç§å½¢å¼:
  ```c++
  class Abstract {
  public:
      virtual void pure_virtual() = 0;
  };

  void Abstract::pure_virtual() {
      // do something
   }

   class Child : public Abstract {
       virtual void pure_virtual(); // no longer abstract, this class may be instantiated.
   };

   void Child::pure_virtual() {
       Abstract::pure_virtual(); // the implementation in the abstract class is executed
   }   
  ```
  * [Virtual function - Wikipedia](https://en.wikipedia.org/wiki/Virtual_function)
    * Behavior during construction and destruction
      * Languages differ in their behavior while the constructor or destructor of an object is running. For this reason, calling virtual functions in constructors is generally discouraged.
      * In C++, the "base" function is called. Specifically, the most derived function that is not more derived than the current constructor's class is called. If that function is a pure virtual function, then undefined behavior occurs. This is true even if the class contains an implementation for that pure virtual function. A conforming C++ implementation is not required (and generally not able) to detect indirect calls to pure virtual functions at compile time or link time. Some runtime systems will issue a pure virtual function call error when encountering a call to a pure virtual function at run time.
      * In Java and C#, the derived implementation is called, but some fields are not yet initialized by the derived constructor (although they are initialized to their default zero values). Some design patterns, such as the Abstract Factory Pattern, actively promote this usage in languages supporting this ability.
    * Virtual destructors
      * Object-oriented languages typically manage memory allocation and de-allocation automatically when objects are created and destroyed. However, some object-oriented languages allow a custom destructor method to be implemented, if desired. If the language in question uses automatic memory management, the custom destructor (generally called a finalizer in this context) that is called is certain to be the appropriate one for the object in question. For example, if an object of type Wolf that inherits Animal is created, and both have custom destructors, the one called will be the one declared in Wolf.
      * In manual memory management contexts, the situation can be more complex, particularly in relation to static dispatch. If an object of type Wolf is created but pointed to by an Animal pointer, and it is this Animal pointer type that is deleted, the destructor called may actually be the one defined for Animal and not the one for Wolf, unless the destructor is virtual. This is particularly the case with C++, where the behavior is a common source of programming errors if destructors are not virtual.
  * å¦‚æœä½¿ç”¨è™šå‡½æ•°ï¼Œçˆ¶ç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡å¹¶è°ƒç”¨å¯¹è±¡æ–¹æ³•æ—¶ï¼Œä½¿ç”¨çš„æ˜¯å­ç±»çš„æ–¹æ³•;
  * å¦‚æœæœªä½¿ç”¨è™šå‡½æ•°ï¼Œåˆ™æ˜¯æ™®é€šçš„é‡å†™ï¼Œåˆ™çˆ¶ç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡æ—¶ï¼Œä½¿ç”¨çš„æ˜¯çˆ¶ç±»çš„æ–¹æ³•ï¼ˆä¸æŒ‡é’ˆç±»å‹çœ‹é½ï¼‰
  * å¯ä»¥å°†æ´¾ç”Ÿç±»çš„å¯¹è±¡èµ‹å€¼ç»™åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œåä¹‹ä¸å¯
  * æ™®é€šå‡½æ•°ï¼ˆéç±»æˆå‘˜å‡½æ•°ï¼‰ä¸èƒ½æ˜¯è™šå‡½æ•°
  * é™æ€å‡½æ•°ï¼ˆstaticï¼‰ä¸èƒ½æ˜¯è™šå‡½æ•°
  * æ„é€ å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°ï¼ˆå› ä¸ºåœ¨è°ƒç”¨æ„é€ å‡½æ•°æ—¶ï¼Œè™šè¡¨æŒ‡é’ˆå¹¶æ²¡æœ‰åœ¨å¯¹è±¡çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå¿…é¡»è¦æ„é€ å‡½æ•°è°ƒç”¨å®Œæˆåæ‰ä¼šå½¢æˆè™šè¡¨æŒ‡é’ˆï¼‰
  * å†…è”å‡½æ•°ä¸èƒ½æ˜¯è¡¨ç°å¤šæ€æ€§æ—¶çš„è™šå‡½æ•°ï¼Œè§£é‡Šè§ï¼š[è™šå‡½æ•°ï¼ˆvirtualï¼‰å¯ä»¥æ˜¯å†…è”å‡½æ•°ï¼ˆinlineï¼‰å—ï¼Ÿ](https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97)
* Virtualï¼š
  * è™šå‡½æ•°ï¼šæ´¾ç”Ÿç±»å¯ä»¥è¦†ç›–æ‰çš„å‡½æ•°ï¼Œ
  * çº¯è™šå‡½æ•°ï¼šåªæ˜¯ä¸ªç©ºå‡½æ•°ï¼Œæ²¡æœ‰å‡½æ•°å®ç°ä½“ã€‚
* æŠ½è±¡ç±»ï¼šå«æœ‰çº¯è™šå‡½æ•°çš„ç±»
* æŠ½è±¡ç±»èƒ½è¢«å®ä¾‹åŒ–å—
  * ä¸èƒ½ï¼Œåªèƒ½ç»§æ‰¿æŠ½è±¡ç±»ï¼Œå®ç°æŠ½è±¡ç±»çš„å‡½æ•°
* æ¥å£ç±»ï¼šä»…å«æœ‰çº¯è™šå‡½æ•°çš„æŠ½è±¡ç±»
* è™šææ„å‡½æ•°
  * [è™šææ„å‡½æ•°_ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/è™šææ„å‡½æ•°)
    * è™šææ„å‡½æ•°æ˜¯ä¸ºäº†è§£å†³åŸºç±»çš„æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ï¼Œå¹¶ç”¨åŸºç±»çš„æŒ‡é’ˆåˆ é™¤æ´¾ç”Ÿç±»å¯¹è±¡ã€‚
    * å¦‚æœæŸä¸ªç±»ä¸åŒ…å«è™šå‡½æ•°ï¼Œé‚£ä¸€èˆ¬æ˜¯è¡¨ç¤ºå®ƒå°†ä¸ä½œä¸ºä¸€ä¸ªåŸºç±»æ¥ä½¿ç”¨ã€‚å½“ä¸€ä¸ªç±»ä¸å‡†å¤‡ä½œä¸ºåŸºç±»ä½¿ç”¨æ—¶ï¼Œä½¿ææ„å‡½æ•°ä¸ºè™šä¸€èˆ¬æ˜¯ä¸ªåä¸»æ„ã€‚å› ä¸ºå®ƒä¼šä¸ºç±»å¢åŠ ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œä½¿å¾—å¯¹è±¡çš„ä½“ç§¯ç¿»å€ï¼Œè¿˜æœ‰å¯èƒ½é™ä½å…¶å¯ç§»æ¤æ€§
    * æ‰€ä»¥åŸºæœ¬çš„ä¸€æ¡æ˜¯ï¼šæ— æ•…çš„å£°æ˜è™šææ„å‡½æ•°å’Œæ°¸è¿œä¸å»å£°æ˜ä¸€æ ·æ˜¯é”™è¯¯çš„ã€‚å®é™…ä¸Šï¼Œå¾ˆå¤šäººè¿™æ ·æ€»ç»“ï¼šå½“ä¸”ä»…å½“ç±»é‡ŒåŒ…å«è‡³å°‘ä¸€ä¸ªè™šå‡½æ•°çš„æ—¶å€™æ‰å»å£°æ˜è™šææ„å‡½æ•°ã€‚æŠ½è±¡ç±»æ˜¯å‡†å¤‡è¢«ç”¨åšåŸºç±»çš„ï¼ŒåŸºç±»å¿…é¡»è¦æœ‰ä¸€ä¸ªè™šææ„å‡½æ•°ï¼Œçº¯è™šå‡½æ•°ä¼šäº§ç”ŸæŠ½è±¡ç±»ï¼Œæ‰€ä»¥æ–¹æ³•å¾ˆç®€å•ï¼šåœ¨æƒ³è¦æˆä¸ºæŠ½è±¡ç±»çš„ç±»é‡Œå£°æ˜ä¸€ä¸ªçº¯è™šææ„å‡½æ•°ã€‚
  * ææ„å‡½æ•°å®šä¹‰æˆè™šå‡½æ•°æ˜¯ä¸ºäº†é˜²æ­¢å†…å­˜æ³„æ¼ï¼Œå› ä¸ºå½“åŸºç±»çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨æŒ‡å‘æˆ–ç»‘å®šåˆ°æ´¾ç”Ÿç±»çš„å¯¹è±¡æ—¶ï¼Œå¦‚æœæœªå°†åŸºç±»çš„ææ„å‡½æ•°å®šä¹‰æˆè™šå‡½æ•°ï¼Œä¼šè°ƒç”¨åŸºç±»çš„ææ„å‡½æ•°ï¼Œé‚£ä¹ˆåªèƒ½å°†åŸºç±»çš„æˆå‘˜æ‰€å çš„ç©ºé—´é‡Šæ”¾æ‰ï¼Œæ´¾ç”Ÿç±»ä¸­ç‰¹æœ‰çš„å°±ä¼šæ— æ³•é‡Šæ”¾å†…å­˜ç©ºé—´å¯¼è‡´å†…å­˜æ³„æ¼ã€‚
* ä»€ä¹ˆæ˜¯æ‹·è´æ„é€ å‡½æ•°?
  * å®ƒæ˜¯å•ä¸ªå‚æ•°çš„æ„é€ å‡½æ•°ï¼Œå…¶å‚æ•°æ˜¯ä¸å®ƒåŒå±ä¸€ç±»çš„å¯¹è±¡çš„(å¸¸)å¼•ç”¨ï¼›ç±»å®šä¹‰ä¸­ï¼Œå¦‚æœæœªæä¾›è‡ªå·±çš„æ‹·è´æ„é€ å‡½æ•°ï¼ŒC++æä¾›ä¸€ä¸ªé»˜è®¤æ‹·è´æ„é€ å‡½æ•°ï¼Œè¯¥é»˜è®¤æ‹·è´æ„é€ å‡½æ•°å®Œæˆä¸€ä¸ªæˆå‘˜åˆ°ä¸€ä¸ªæˆå‘˜çš„æ‹·è´
* è¦åœ¨C++é˜²æ­¢å¯¹è±¡è¢«å¤åˆ¶ï¼Œæœ‰ä»€ä¹ˆæ–¹æ³•
  * [Explicitly Defaulted and Deleted Functions | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160)
  * Pre-C++11 å®šä¹‰ä¸€ä¸ªåŸºç±»ï¼Œå°†å…¶ä¸­çš„æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ„é€ å‡½æ•°å£°æ˜ä¸ºç§æœ‰private
  * C++11åˆ™å¯ä»¥å¯¹æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼æ„é€ å‡½æ•°å£°æ˜ä¸ºdelete
  * æ´¾ç”Ÿç±»ä»¥ç§æœ‰privateçš„æ–¹å¼ç»§æ‰¿åŸºç±»
* ä»€ä¹ˆæ˜¯æ·±æµ…æ‹·è´?
  * æµ…æ‹·è´æ˜¯åˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡ç”¨ä¸€ä¸ªç°æˆçš„å¯¹è±¡åˆå§‹åŒ–å®ƒçš„æ—¶å€™åªæ˜¯å¤åˆ¶äº†æˆå‘˜(ç®€å•èµ‹å€¼)è€Œæ²¡æœ‰æ‹·è´åˆ†é…ç»™æˆå‘˜çš„èµ„æº(å¦‚ç»™å…¶æŒ‡é’ˆå˜é‡æˆå‘˜åˆ†é…äº†åŠ¨æ€å†…å­˜); æ·±æ‹·è´æ˜¯å½“ä¸€ä¸ªå¯¹è±¡åˆ›å»ºæ—¶ï¼Œå¦‚æœåˆ†é…äº†èµ„æºï¼Œå°±éœ€è¦å®šä¹‰è‡ªå·±çš„æ‹·è´æ„é€ å‡½æ•°ï¼Œä½¿ä¹‹ä¸ä½†æ‹·è´æˆå‘˜ä¹Ÿæ‹·è´åˆ†é…ç»™å®ƒçš„èµ„æº

## è¯­è¨€ç‰¹æ€§ç›¸å…³
* [namespace in C++ | Set 2 (Extending namespace and Unnamed namespace) - GeeksforGeeks](https://www.geeksforgeeks.org/namespace-in-c-set-2-extending-namespace-and-unnamed-namespace/)
  * Unnamed Namespaces
    * They are directly usable in the same program and are used for declaring unique identifiers.
    * In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
    * The name of the namespace is uniquely generated by the compiler.
    * The unnamed namespaces you have created will only be accessible within the file you created it in.
    * Unnamed namespaces are the replacement for the static declaration of variables.
  * [Namespaces - cppreference.com](https://en.cppreference.com/w/cpp/language/namespace)
* å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ï¼Ÿå·¦å€¼å¼•ç”¨å’Œå³å€¼å¼•ç”¨çš„åŒºåˆ«ï¼Œå¦‚ä½•å°†å·¦å€¼è½¬æ¢æˆå³å€¼ï¼Ÿ
  * å·¦å€¼ï¼šæŒ‡è¡¨è¾¾å¼ç»“æŸåä¾ç„¶å­˜åœ¨çš„æŒä¹…å¯¹è±¡ã€‚
  * å³å€¼ï¼šè¡¨è¾¾å¼ç»“æŸå°±ä¸å†å­˜åœ¨çš„ä¸´æ—¶å¯¹è±¡ã€‚
  * å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ï¼šå·¦å€¼æŒä¹…ï¼Œå³å€¼çŸ­æš‚
  * å³å€¼å¼•ç”¨å’Œå·¦å€¼å¼•ç”¨çš„åŒºåˆ«ï¼š
  * å·¦å€¼å¼•ç”¨ä¸èƒ½ç»‘å®šåˆ°è¦è½¬æ¢çš„è¡¨è¾¾å¼ã€å­—é¢å¸¸é‡æˆ–è¿”å›å³å€¼çš„è¡¨è¾¾å¼ã€‚å³å€¼å¼•ç”¨æ°å¥½ç›¸åï¼Œå¯ä»¥ç»‘å®šåˆ°è¿™ç±»è¡¨è¾¾å¼ï¼Œä½†ä¸èƒ½ç»‘å®šåˆ°ä¸€ä¸ªå·¦å€¼ä¸Šã€‚
  * å³å€¼å¼•ç”¨å¿…é¡»ç»‘å®šåˆ°å³å€¼çš„å¼•ç”¨ï¼Œé€šè¿‡ && è·å¾—ã€‚å³å€¼å¼•ç”¨åªèƒ½ç»‘å®šåˆ°ä¸€ä¸ªå°†è¦é”€æ¯çš„å¯¹è±¡ä¸Šï¼Œå› æ­¤å¯ä»¥è‡ªç”±åœ°ç§»åŠ¨å…¶èµ„æºã€‚
  * std::move å¯ä»¥å°†ä¸€ä¸ªå·¦å€¼å¼ºåˆ¶è½¬åŒ–ä¸ºå³å€¼ï¼Œç»§è€Œå¯ä»¥é€šè¿‡å³å€¼å¼•ç”¨ä½¿ç”¨è¯¥å€¼ï¼Œä»¥ç”¨äºç§»åŠ¨è¯­ä¹‰ã€‚
* std::move()
  * [move - C++ Reference](https://www.cplusplus.com/reference/algorithm/move/)
  * [std::move - cppreference.com](https://en.cppreference.com/w/cpp/utility/move)
    * std::move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object.
    * In particular, std::move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.
  * [c++ - What is std::move(), and when should it be used? - Stack Overflow](https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used)
    * In C++11, in addition to copy constructors, objects can have move constructors.(And in addition to copy assignment operators, they have move assignment operators.)
    * The move constructor is used instead of the copy constructor, if the object has type "rvalue-reference" (Type &&).
    * std::move() is a cast that produces an rvalue-reference to an object, to enable moving from it.
    * It's a new C++ way to avoid copies. For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an moved from state, therefore not copying all the data.  
    * [Rvalue Reference Quick Look](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics)
      * Rvalue references is a small technical extension to the C++ language. Rvalue references allow programmers to avoid logically unnecessary copying and to provide perfect forwarding functions. They are primarily meant to aid in the design of higer performance and more robust libraries.
      * The rvalue reference      
        * An rvalue reference is a compound type very similar to C++'s traditional reference. To better distinguish these two types, we refer to a traditional C++ reference as an lvalue reference. When the term reference is used, it refers to both kinds of reference: lvalue reference and rvalue reference.
        * It turns out that the combination of rvalue references and lvalue references is just what is needed to easily code move semantics. The rvalue reference can also be used to achieve perfect forwarding, a heretofore unsolved problem in C++. From a casual programmer's perspective, what we get from rvalue references is more general and better performing libraries.
      * Move Semantics
        * Eliminating spurious copies
          * Copying can be expensive. 
          * The first task of rvalue references is to allow us to implement move() without verbosity, or rutime overhead.
          * move
            * The move function really does very little work. All move does is accept either an lvalue or rvalue argument, and return it as an rvalue without triggering a copy construction:
  * std::move() å®ç°åŸç†ï¼š
    * åˆ©ç”¨å¼•ç”¨æŠ˜å åŸç†å°†å³å€¼ç»è¿‡ T&& ä¼ é€’ç±»å‹ä¿æŒä¸å˜è¿˜æ˜¯å³å€¼ï¼Œè€Œå·¦å€¼ç»è¿‡ T&& å˜ä¸ºæ™®é€šçš„å·¦å€¼å¼•ç”¨ï¼Œä»¥ä¿è¯æ¨¡æ¿å¯ä»¥ä¼ é€’ä»»æ„å®å‚ï¼Œä¸”ä¿æŒç±»å‹ä¸å˜ï¼›
    * ç„¶åé€šè¿‡ remove_refrence ç§»é™¤å¼•ç”¨ï¼Œå¾—åˆ°å…·ä½“çš„ç±»å‹ Tï¼›
    * æœ€åé€šè¿‡ static_cast<> è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œè¿”å› T&& å³å€¼å¼•ç”¨ã€‚
* [Pointers vs References in C++ - GeeksforGeeks](https://www.geeksforgeeks.org/pointers-vs-references-cpp/)
	* [Pointers](https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/)
		* A pointer is a variable that holds memory address of another variable. A pointer needs to be dereferenced with * operator to access the memory location it points to. 
	* [References](https://www.geeksforgeeks.org/references-in-c/)
		* A reference variable is an alias, that is, another name for an already existing variable. A reference, like a pointer, is also implemented by storing the address of an object. 
		* A reference can be thought of as a constant pointer (not to be confused with a pointer to a constant value!) with automatic indirection, i.e the compiler will apply the * operator for you. 
	* Differences

		Features|Pointers|References
		-|-|-
		Initialization|we can declare and initialize pointer at same step or in multiple line.|we should declare and initialize references at single step.
		Reassignment|Pointer can be re-assigned. This property is useful for implementation of data structures like linked list, tree, etc.|Reference cannot be re-assigned, and must be assigned at initialization.
		Memory Address|Pointer has its own memory address and size on the stack|Reference shares the same memory address (with the original variable) but also takes up some space on the stack
		NULL value|Pointer can be assigned NULL directly|Reference cannot. The constraints associated with references (no NULL, no reassignment) ensure that the underlying operations do not run into exception situation.
		Indirection|You can have pointers to pointers offering extra levels of indirection|References only offer one level of indirection
		Arithmetic operations|Various arithmetic operations can be performed on pointers|There is no such thing called Reference Arithmetic.(but you can take the address of an object pointed by a reference and do pointer arithmetics on it as in &obj + 5).) 

	* When to use What
		* The performances are exactly the same, as references are implemented internally as pointers. But still you can keep some points in your mind to decide when to use what :
			* Use references 
				* In function parameters and return types.
			* Use pointers: 
				* Use pointers if pointer arithmetic or passing NULL-pointer is needed. For example for arrays (Note that array access is implemented using pointer arithmetic).
				* To implement data structures like linked list, tree, etc and their algorithms because to point different cell, we have to use the concept of pointers.
* æŒ‡é’ˆå’Œå¼•ç”¨çš„åˆå§‹åŒ–åŒºåˆ«
  * å¼•ç”¨è¢«åˆ›å»ºçš„åŒæ—¶å¿…é¡»è¢«åˆå§‹åŒ–ï¼ˆæŒ‡é’ˆåˆ™å¯ä»¥åœ¨ä»»ä½•æ—¶å€™è¢«åˆå§‹åŒ–ï¼‰ã€‚
  * ä¸èƒ½æœ‰NULL å¼•ç”¨ï¼Œå¼•ç”¨å¿…é¡»ä¸åˆæ³•çš„å­˜å‚¨å•å…ƒå…³è”ï¼ˆæŒ‡é’ˆåˆ™å¯ä»¥æ˜¯NULLï¼‰ã€‚
  * ä¸€æ—¦å¼•ç”¨è¢«åˆå§‹åŒ–ï¼Œå°±ä¸èƒ½æ”¹å˜å¼•ç”¨çš„å…³ç³»ï¼ˆæŒ‡é’ˆåˆ™å¯ä»¥éšæ—¶æ”¹å˜æ‰€æŒ‡çš„å¯¹è±¡ï¼‰ã€‚
* [Passing By Pointer Vs Passing By Reference in C++ - GeeksforGeeks](https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/)
	* 1) Passing by Pointer: Here, the memory location of the variables is passed to the parameters in the function, and then the operations are performed.
	* 2) Passing by Reference: It allows a function to modify a variable without having to create a copy of it. We have to declare reference variables. The memory location of the passed variable and parameter is the same and therefore, any change to the parameter reflects in the variable as well.
	* Difference Between Reference Variable and Pointer Variable:
		* A reference is the same object, just with a different name and a reference must refer to an object. Since references canâ€™t be NULL, they are safer to use. 
		* A pointer can be re-assigned while a reference cannot, and must be assigned at initialization only.
		* The pointer can be assigned NULL directly, whereas the reference cannot.
		* Pointers can iterate over an array, we can use increment/decrement operators to go to the next/previous item that a pointer is pointing to.
		* A pointer is a variable that holds a memory address. A reference has the same memory address as the item it references.
		* A pointer to a class/struct uses â€˜->â€™ (arrow operator) to access its members whereas a reference uses a â€˜.â€™ (dot operator)
		* A pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly.
	* Which is preferred in Passing by Pointer Vs Passing by Reference in C++? 
		* References are usually preferred over pointers whenever we donâ€™t need â€œreseatingâ€.
		* Overall, Use references when you can, and pointers when you have to. But if we want to write C code that compiles with both C and a C++ compiler, youâ€™ll have to restrict yourself to using pointers.	
* å‡½æ•°æŒ‡é’ˆ,ä»€ä¹ˆæ˜¯å‡½æ•°æŒ‡é’ˆï¼Œæœ‰ä»€ä¹ˆç”¨å¤„
  * å‡½æ•°æŒ‡é’ˆæ˜¯æŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆï¼Œæœ€å¤§çš„ç”¨å¤„æ˜¯åšå›è°ƒå‡½æ•°ï¼Œå¯ä»¥åšæ¥å£å‡½æ•°ï¼Œå°±åƒç³»ç»Ÿä¸­æ–­ä¸­çš„ä¸­æ–­å¤„ç†å‡½æ•°
* è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°ä¸­æœ‰ä¸€æ®µåŠŸèƒ½æ˜¯å¯¹ç›¸å…³æ•°æ®çš„ç»“ç†ï¼Œä½†å…·ä½“çš„å¤„ç†æ–¹å¼æ˜¯ä¸å®šçš„ã€‚
  * å°†ä¸å®šçš„å¤„ç†æ–¹å¼è®¾å®šæˆä¸€ä¸ªå¤–éƒ¨ä¼ æ¥å‡½æ•°æŒ‡é’ˆã€‚(å¯ä»¥è®¾è®¡æˆè¿™æ · func(int a,int bï¼ŒæŸç§å‡½æ•°æŒ‡é’ˆ) )
* å¦‚ä½•å¯¹æ¶ˆæ¯å®ç°åŒæ­¥å“åº”
  * ä½¿ç”¨CALLBACKï¼Œå›è°ƒå‡½æ•°
  * [CALLBACK_ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/CALLBACK/813549?fr=aladdin)
* å‡½æ•°å¯¹è±¡åŠŸèƒ½
  * å¯ä»¥ç”¨ä½œç±»ä¼¼Cé‡Œçš„å›è°ƒå‡½æ•°ï¼Œä¹Ÿå¯ä»¥ç”¨ä½œå‡½æ•°åŠŸèƒ½çš„ç»„åˆ
* C++æ¨¡æ¿
  * ç®€åŒ–å¯¹ç±»ä¼¼å‡½æ•°çš„è®¾è®¡ï¼Œæ¯”å¦‚è¦è®¾è®¡ä¸¤ä¸ªå‡½æ•° abs(int a), abs(float a),å°±å¯ä»¥ç”¨æ¨¡æ¿å»è®¾è®¡ä¸€ä¸ªå‡½æ•°å°±å¯ä»¥äº†

### [STL](https://github.com/huihut/interview#-stl)

* [STL å®¹å™¨](https://github.com/huihut/interview#stl-%E5%AE%B9%E5%99%A8)

å®¹å™¨ | åº•å±‚æ•°æ®ç»“æ„ | æ—¶é—´å¤æ‚åº¦ | æœ‰æ— åº | å¯ä¸å¯é‡å¤ | å…¶ä»–
---|---|---|---|---|---
[array](https://github.com/huihut/interview/tree/master/STL#array)|æ•°ç»„|éšæœºè¯»æ”¹ O(1)|æ— åº|å¯é‡å¤|æ”¯æŒéšæœºè®¿é—®
[vector](https://github.com/huihut/interview/tree/master/STL#vector)|æ•°ç»„|éšæœºè¯»æ”¹ã€å°¾éƒ¨æ’å…¥ã€å°¾éƒ¨åˆ é™¤ O(1)<br/>å¤´éƒ¨æ’å…¥ã€å¤´éƒ¨åˆ é™¤ O(n)|æ— åº|å¯é‡å¤|æ”¯æŒéšæœºè®¿é—®; [Iterators/References may become invalid after insertion or erasure](https://en.cppreference.com/w/cpp/container); May have a default size
[deque](https://github.com/huihut/interview/tree/master/STL#deque)|åŒç«¯é˜Ÿåˆ—|å¤´å°¾æ’å…¥ã€å¤´å°¾åˆ é™¤ O(1)|æ— åº|å¯é‡å¤|ä¸€ä¸ªä¸­å¤®æ§åˆ¶å™¨ + å¤šä¸ªç¼“å†²åŒºï¼Œæ”¯æŒé¦–å°¾å¿«é€Ÿå¢åˆ ï¼Œæ”¯æŒéšæœºè®¿é—®
[forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list)|å•å‘é“¾è¡¨|æ’å…¥ã€åˆ é™¤ O(1)|æ— åº|å¯é‡å¤|ä¸æ”¯æŒéšæœºè®¿é—®
[list](https://github.com/huihut/interview/tree/master/STL#list)|åŒå‘é“¾è¡¨|æ’å…¥ã€åˆ é™¤ O(1)|æ— åº|å¯é‡å¤|ä¸æ”¯æŒéšæœºè®¿é—®; Iterators/References remain valid after insertion or erasure except the corresponding element is deleted.
[stack](https://github.com/huihut/interview/tree/master/STL#stack)|deque / list|é¡¶éƒ¨æ’å…¥ã€é¡¶éƒ¨åˆ é™¤ O(1)|æ— åº|å¯é‡å¤|deque æˆ– list å°é—­å¤´ç«¯å¼€å£ï¼Œä¸ç”¨ vector çš„åŸå› åº”è¯¥æ˜¯å®¹é‡å¤§å°æœ‰é™åˆ¶ï¼Œæ‰©å®¹è€—æ—¶
[queue](https://github.com/huihut/interview/tree/master/STL#queue)|deque / list|å°¾éƒ¨æ’å…¥ã€å¤´éƒ¨åˆ é™¤ O(1)|æ— åº|å¯é‡å¤|deque æˆ– list å°é—­å¤´ç«¯å¼€å£ï¼Œä¸ç”¨ vector çš„åŸå› åº”è¯¥æ˜¯å®¹é‡å¤§å°æœ‰é™åˆ¶ï¼Œæ‰©å®¹è€—æ—¶
[priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue)|vector + max-heap|æ’å…¥ã€åˆ é™¤ O(log<sub>2</sub>n)|æœ‰åº|å¯é‡å¤|vectorå®¹å™¨+heapå¤„ç†è§„åˆ™
[set](https://github.com/huihut/interview/tree/master/STL#set)|[çº¢é»‘æ ‘](https://github.com/huihut/interview#%E7%BA%A2%E9%BB%91%E6%A0%91)|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)|æœ‰åº|ä¸å¯é‡å¤|
[multiset](https://github.com/huihut/interview/tree/master/STL#multiset)|çº¢é»‘æ ‘|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)|æœ‰åº|å¯é‡å¤|
[map](https://github.com/huihut/interview/tree/master/STL#map)|çº¢é»‘æ ‘|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)|æœ‰åº|ä¸å¯é‡å¤|
[multimap](https://github.com/huihut/interview/tree/master/STL#multimap)|çº¢é»‘æ ‘|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(log<sub>2</sub>n)|æœ‰åº|å¯é‡å¤|
[unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set)|å“ˆå¸Œè¡¨|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)|æ— åº|ä¸å¯é‡å¤|
[unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset)|å“ˆå¸Œè¡¨|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)|æ— åº|å¯é‡å¤|
[unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map)|å“ˆå¸Œè¡¨|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)|æ— åº|ä¸å¯é‡å¤|
[unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap)|å“ˆå¸Œè¡¨|æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ O(1) æœ€å·® O(n)|æ— åº|å¯é‡å¤|

* [STL ç®—æ³•](https://github.com/huihut/interview#stl-%E7%AE%97%E6%B3%95)

ç®—æ³• | åº•å±‚ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | å¯ä¸å¯é‡å¤
---|---|---|---
[find](http://www.cplusplus.com/reference/algorithm/find/)|é¡ºåºæŸ¥æ‰¾|O(n)|å¯é‡å¤
[sort](https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808)|[å†…çœæ’åº](https://en.wikipedia.org/wiki/Introsort)|O(n*log<sub>2</sub>n)|å¯é‡å¤

* [ç®—æ³•ï¼ˆalgorithmsï¼‰](https://github.com/huihut/interview/tree/master/STL#%E7%AE%97%E6%B3%95algorithms)
```cpp
// ç®€å•æŸ¥æ‰¾ç®—æ³•ï¼Œè¦æ±‚è¾“å…¥è¿­ä»£å™¨ï¼ˆinput iteratorï¼‰
find(beg, end, val); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ä¸€ä¸ªç­‰äº val çš„å…ƒç´ ï¼Œæœªæ‰¾åˆ°è¿”å› end
find_if(beg, end, unaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬ä¸€ä¸ªæ»¡è¶³ unaryPred çš„å…ƒç´ ï¼Œæœªæ‰¾åˆ°è¿”å› end
find_if_not(beg, end, unaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬ä¸€ä¸ªä»¤ unaryPred ä¸º false çš„å…ƒç´ ï¼Œæœªæ‰¾åˆ°è¿”å› end
count(beg, end, val); // è¿”å›ä¸€ä¸ªè®¡æ•°å™¨ï¼ŒæŒ‡å‡º val å‡ºç°äº†å¤šå°‘æ¬¡
count_if(beg, end, unaryPred); // ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªå…ƒç´ æ»¡è¶³ unaryPred
all_of(beg, end, unaryPred); // è¿”å›ä¸€ä¸ª bool å€¼ï¼Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³ unaryPred
any_of(beg, end, unaryPred); // è¿”å›ä¸€ä¸ª bool å€¼ï¼Œåˆ¤æ–­æ˜¯å¦ä»»æ„ï¼ˆå­˜åœ¨ï¼‰ä¸€ä¸ªå…ƒç´ æ»¡è¶³ unaryPred
none_of(beg, end, unaryPred); // è¿”å›ä¸€ä¸ª bool å€¼ï¼Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½ä¸æ»¡è¶³ unaryPred

// æŸ¥æ‰¾é‡å¤å€¼çš„ç®—æ³•ï¼Œä¼ å…¥å‘å‰è¿­ä»£å™¨ï¼ˆforward iteratorï¼‰
adjacent_find(beg, end); // è¿”å›æŒ‡å‘ç¬¬ä¸€å¯¹ç›¸é‚»é‡å¤å…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ— ç›¸é‚»å…ƒç´ åˆ™è¿”å› end
adjacent_find(beg, end, binaryPred); // è¿”å›æŒ‡å‘ç¬¬ä¸€å¯¹ç›¸é‚»é‡å¤å…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ— ç›¸é‚»å…ƒç´ åˆ™è¿”å› end
search_n(beg, end, count, val); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä»æ­¤ä½ç½®å¼€å§‹æœ‰ count ä¸ªç›¸ç­‰å…ƒç´ ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
search_n(beg, end, count, val, binaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä»æ­¤ä½ç½®å¼€å§‹æœ‰ count ä¸ªç›¸ç­‰å…ƒç´ ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end

// æŸ¥æ‰¾å­åºåˆ—ç®—æ³•ï¼Œé™¤ find_first_ofï¼ˆå‰ä¸¤ä¸ªè¾“å…¥è¿­ä»£å™¨ï¼Œåä¸¤ä¸ªå‰å‘è¿­ä»£å™¨ï¼‰ å¤–ï¼Œéƒ½è¦æ±‚ä¸¤ä¸ªå‰å‘è¿­ä»£å™¨
search(beg1, end1, beg2, end2); // è¿”å›ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ï¼ˆå­åºåˆ—ï¼‰åœ¨çˆ¹ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å› end1
search(beg1, end1, beg2, end2, binaryPred); // è¿”å›ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ï¼ˆå­åºåˆ—ï¼‰åœ¨çˆ¹ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å› end1
find_first_of(beg1, end1, beg2, end2); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸­ä»»æ„å…ƒç´ åœ¨ç¬¬ä¸€ä¸ªèŒƒå›´ä¸­é¦–æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å›end1
find_first_of(beg1, end1, beg2, end2, binaryPred); // è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸­ä»»æ„å…ƒç´ åœ¨ç¬¬ä¸€ä¸ªèŒƒå›´ä¸­é¦–æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæœªæ‰¾åˆ°åˆ™è¿”å›end1
find_end(beg1, end1, beg2, end2); // ç±»ä¼¼ searchï¼Œä½†è¿”å›çš„æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚å¦‚æœç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­æœªæ‰¾åˆ°å®ƒï¼Œåˆ™è¿”å› end1
find_end(beg1, end1, beg2, end2, binaryPred); // ç±»ä¼¼ searchï¼Œä½†è¿”å›çš„æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚å¦‚æœç¬¬äºŒä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸ºç©ºï¼Œæˆ–è€…åœ¨ç¬¬ä¸€ä¸ªè¾“å…¥èŒƒå›´ä¸­æœªæ‰¾åˆ°å®ƒï¼Œåˆ™è¿”å› end1

// å…¶ä»–åªè¯»ç®—æ³•ï¼Œä¼ å…¥è¾“å…¥è¿­ä»£å™¨
for_each(beg, end, unaryOp); // å¯¹è¾“å…¥åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨å¯è°ƒç”¨å¯¹è±¡ unaryOpï¼ŒunaryOp çš„è¿”å›å€¼è¢«å¿½ç•¥
mismatch(beg1, end1, beg2); // æ¯”è¾ƒä¸¤ä¸ªåºåˆ—ä¸­çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨çš„ pairï¼Œè¡¨ç¤ºä¸¤ä¸ªåºåˆ—ä¸­ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„å…ƒç´ 
mismatch(beg1, end1, beg2, binaryPred); // æ¯”è¾ƒä¸¤ä¸ªåºåˆ—ä¸­çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨çš„ pairï¼Œè¡¨ç¤ºä¸¤ä¸ªåºåˆ—ä¸­ç¬¬ä¸€ä¸ªä¸åŒ¹é…çš„å…ƒç´ 
equal(beg1, end1, beg2); // æ¯”è¾ƒæ¯ä¸ªå…ƒç´ ï¼Œç¡®å®šä¸¤ä¸ªåºåˆ—æ˜¯å¦ç›¸ç­‰ã€‚
equal(beg1, end1, beg2, binaryPred); // æ¯”è¾ƒæ¯ä¸ªå…ƒç´ ï¼Œç¡®å®šä¸¤ä¸ªåºåˆ—æ˜¯å¦ç›¸ç­‰ã€‚

// äºŒåˆ†æœç´¢ç®—æ³•ï¼Œä¼ å…¥å‰å‘è¿­ä»£å™¨æˆ–éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆrandom-access iteratorï¼‰ï¼Œè¦æ±‚åºåˆ—ä¸­çš„å…ƒç´ å·²ç»æ˜¯æœ‰åºçš„ã€‚é€šè¿‡å°äºè¿ç®—ç¬¦ï¼ˆ<ï¼‰æˆ– comp æ¯”è¾ƒæ“ä½œå®ç°æ¯”è¾ƒã€‚
lower_bound(beg, end, val); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå€¼ val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
lower_bound(beg, end, val, comp); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå€¼ val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
upper_bound(beg, end, val); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­ç¬¬ä¸€ä¸ªå¤§äº val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
upper_bound(beg, end, val, comp); // è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ— [beg, end) ä¸­ç¬¬ä¸€ä¸ªå¤§äº val çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œä¸å­˜åœ¨åˆ™è¿”å› end
equal_range(beg, end, val); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ first æˆå‘˜æ˜¯ lower_bound è¿”å›çš„è¿­ä»£å™¨ï¼Œå…¶ second æˆå‘˜æ˜¯ upper_bound è¿”å›çš„è¿­ä»£å™¨
binary_search(beg, end, val); // è¿”å›ä¸€ä¸ª bool å€¼ï¼ŒæŒ‡å‡ºåºåˆ—ä¸­æ˜¯å¦åŒ…å«ç­‰äº val çš„å…ƒç´ ã€‚å¯¹äºä¸¤ä¸ªå€¼ x å’Œ yï¼Œå½“ x ä¸å°äº y ä¸” y ä¹Ÿä¸å°äº x æ—¶ï¼Œè®¤ä¸ºå®ƒä»¬ç›¸ç­‰ã€‚

// åªå†™ä¸è¯»ç®—æ³•ï¼Œè¦æ±‚è¾“å‡ºè¿­ä»£å™¨ï¼ˆoutput iteratorï¼‰
fill(beg, end, val); // å°† val èµ‹äºˆæ¯ä¸ªå…ƒç´ ï¼Œè¿”å› void
fill_n(beg, cnt, val); // å°† val èµ‹äºˆ cnt ä¸ªå…ƒç´ ï¼Œè¿”å›æŒ‡å‘å†™å…¥åˆ°è¾“å‡ºåºåˆ—æœ€æœ‰ä¸€ä¸ªå…ƒç´ ä¹‹åä½ç½®çš„è¿­ä»£å™¨
genetate(beg, end, Gen); // æ¯æ¬¡è°ƒç”¨ Gen() ç”Ÿæˆä¸åŒçš„å€¼èµ‹äºˆæ¯ä¸ªåºåˆ—ï¼Œè¿”å› void
genetate_n(beg, cnt, Gen); // æ¯æ¬¡è°ƒç”¨ Gen() ç”Ÿæˆä¸åŒçš„å€¼èµ‹äºˆ cnt ä¸ªåºåˆ—ï¼Œè¿”å›æŒ‡å‘å†™å…¥åˆ°è¾“å‡ºåºåˆ—æœ€æœ‰ä¸€ä¸ªå…ƒç´ ä¹‹åä½ç½®çš„è¿­ä»£å™¨

// ä½¿ç”¨è¾“å…¥è¿­ä»£å™¨çš„å†™ç®—æ³•ï¼Œè¯»å–ä¸€ä¸ªè¾“å…¥åºåˆ—ï¼Œå°†å€¼å†™å…¥åˆ°ä¸€ä¸ªè¾“å‡ºåºåˆ—ï¼ˆdestï¼‰ä¸­
copy(beg, end, dest); // ä»è¾“å…¥èŒƒå›´å°†å…ƒç´ æ‹·è´æ‰€æœ‰å…ƒç´ åˆ° dest æŒ‡å®šå®šçš„ç›®çš„åºåˆ—
copy_if(beg, end, dest, unaryPred); // ä»è¾“å…¥èŒƒå›´å°†å…ƒç´ æ‹·è´æ»¡è¶³ unaryPred çš„å…ƒç´ åˆ° dest æŒ‡å®šå®šçš„ç›®çš„åºåˆ—
copy_n(beg, n, dest); // ä»è¾“å…¥èŒƒå›´å°†å…ƒç´ æ‹·è´å‰ n ä¸ªå…ƒç´ åˆ° dest æŒ‡å®šå®šçš„ç›®çš„åºåˆ—
move(beg, end, dest); // å¯¹è¾“å…¥åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨ std::moveï¼Œå°†å…¶ç§»åŠ¨åˆ°è¿­ä»£å™¨ dest å¼€å§‹å§‹çš„åºåˆ—ä¸­
transform(beg, end, dest, unaryOp); // è°ƒç”¨ç»™å®šæ“ä½œï¼ˆä¸€å…ƒæ“ä½œï¼‰ï¼Œå¹¶å°†ç»“æœå†™åˆ°destä¸­
transform(beg, end, beg2, dest, binaryOp); // è°ƒç”¨ç»™å®šæ“ä½œï¼ˆäºŒå…ƒæ“ä½œï¼‰ï¼Œå¹¶å°†ç»“æœå†™åˆ°destä¸­
replace_copy(beg, end, dest, old_val, new_val); // å°†æ¯ä¸ªå…ƒç´ æ‹·è´åˆ° destï¼Œå°†ç­‰äº old_val çš„çš„å…ƒç´ æ›¿æ¢ä¸º new_val
replace_copy_if(beg, end, dest, unaryPred, new_val); // å°†æ¯ä¸ªå…ƒç´ æ‹·è´åˆ° destï¼Œå°†æ»¡è¶³ unaryPred çš„çš„å…ƒç´ æ›¿æ¢ä¸º new_val
merge(beg1, end1, beg2, end2, dest); // ä¸¤ä¸ªè¾“å…¥åºåˆ—å¿…é¡»éƒ½æ˜¯æœ‰åºçš„ï¼Œç”¨ < è¿ç®—ç¬¦å°†åˆå¹¶åçš„åºåˆ—å†™å…¥åˆ° dest ä¸­
merge(beg1, end1, beg2, end2, dest, comp); // ä¸¤ä¸ªè¾“å…¥åºåˆ—å¿…é¡»éƒ½æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨ç»™å®šçš„æ¯”è¾ƒæ“ä½œï¼ˆcompï¼‰å°†åˆå¹¶åçš„åºåˆ—å†™å…¥åˆ° dest ä¸­

// ä½¿ç”¨å‰å‘è¿­ä»£å™¨çš„å†™ç®—æ³•ï¼Œè¦æ±‚å‰å‘è¿­ä»£å™¨
iter_swap(iter1, iter2); // äº¤æ¢ iter1 å’Œ iter2 æ‰€è¡¨ç¤ºçš„å…ƒç´ ï¼Œè¿”å› void
swap_ranges(beg1, end1, beg2); // å°†è¾“å…¥èŒƒå›´ä¸­æ‰€æœ‰å…ƒç´ ä¸ beg2 å¼€å§‹çš„ç¬¬äºŒä¸ªåºåˆ—ä¸­æ‰€æœ‰å…ƒç´ è¿›è¡Œäº¤æ¢ã€‚è¿”å›é€’å¢åçš„çš„ beg2ï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªäº¤æ¢å…ƒç´ ä¹‹åçš„ä½ç½®ã€‚
replace(beg, end, old_val, new_val); // ç”¨ new_val æ›¿æ¢ç­‰äº old_val çš„æ¯ä¸ªåŒ¹é…å…ƒç´ 
replace_if(beg, end, unaryPred, new_val); // ç”¨ new_val æ›¿æ¢æ»¡è¶³ unaryPred çš„æ¯ä¸ªåŒ¹é…å…ƒç´ 

// ä½¿ç”¨åŒå‘è¿­ä»£å™¨çš„å†™ç®—æ³•ï¼Œè¦æ±‚åŒå‘é€‰ä»£å™¨ï¼ˆbidirectional iteratorï¼‰
copy_backward(beg, end, dest); // ä»è¾“å…¥èŒƒå›´ä¸­æ‹·è´å…ƒç´ åˆ°æŒ‡å®šç›®çš„ä½ç½®ã€‚å¦‚æœèŒƒå›´ä¸ºç©º,åˆ™è¿”å›å€¼ä¸º destï¼›å¦åˆ™ï¼Œè¿”å›å€¼è¡¨ç¤ºä» *beg ä¸­æ‹·è´æˆ–ç§»åŠ¨çš„å…ƒç´ ã€‚
move_backward(beg, end, dest);  // ä»è¾“å…¥èŒƒå›´ä¸­ç§»åŠ¨å…ƒç´ åˆ°æŒ‡å®šç›®çš„ä½ç½®ã€‚å¦‚æœèŒƒå›´ä¸ºç©º,åˆ™è¿”å›å€¼ä¸º destï¼›å¦åˆ™,è¿”å›å€¼è¡¨ç¤ºä» *beg ä¸­æ‹·è´æˆ–ç§»åŠ¨çš„å…ƒç´ ã€‚
inplace_merge(beg, mid, end); // å°†åŒä¸€ä¸ªåºåˆ—ä¸­çš„ä¸¤ä¸ªæœ‰åºå­åºåˆ—åˆå¹¶ä¸ºå•ä¸€çš„æœ‰åºåºåˆ—ã€‚beg åˆ° mid é—´çš„å­åºåˆ—å’Œ mid åˆ° end é—´çš„å­åºåˆ—è¢«åˆå¹¶ï¼Œå¹¶è¢«å†™å…¥åˆ°åŸåºåˆ—ä¸­ã€‚ä½¿ç”¨ < æ¯”è¾ƒå…ƒç´ ã€‚
inplace_merge(beg, mid, end, comp); // å°†åŒä¸€ä¸ªåºåˆ—ä¸­çš„ä¸¤ä¸ªæœ‰åºå­åºåˆ—åˆå¹¶ä¸ºå•ä¸€çš„æœ‰åºåºåˆ—ã€‚beg åˆ° mid é—´çš„å­åºåˆ—å’Œ mid åˆ° end é—´çš„å­åºåˆ—è¢«åˆå¹¶ï¼Œå¹¶è¢«å†™å…¥åˆ°åŸåºåˆ—ä¸­ã€‚ä½¿ç”¨ç»™å®šçš„ comp æ“ä½œã€‚

// åˆ’åˆ†ç®—æ³•ï¼Œè¦æ±‚åŒå‘é€‰ä»£å™¨ï¼ˆbidirectional iteratorï¼‰
is_partitioned(beg, end, unaryPred); // å¦‚æœæ‰€æœ‰æ»¡è¶³è°“è¯ unaryPred çš„å…ƒç´ éƒ½åœ¨ä¸æ»¡è¶³ unarypred çš„å…ƒç´ ä¹‹å‰ï¼Œåˆ™è¿”å› trueã€‚è‹¥åºåˆ—ä¸ºç©ºï¼Œä¹Ÿè¿”å› true
partition_copy(beg, end, dest1, dest2, unaryPred); // å°†æ»¡è¶³ unaryPred çš„å…ƒç´ æ‹·è´åˆ°åˆ° dest1ï¼Œå¹¶å°†ä¸æ»¡è¶³ unaryPred çš„å…ƒç´ æ‹·è´åˆ°åˆ° dest2ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ pairï¼Œå…¶ first æˆå‘˜è¡¨ç¤ºæ‹·è´åˆ° dest1 çš„çš„å…ƒç´ çš„æœ«å°¾ï¼Œsecond è¡¨ç¤ºæ‹·è´åˆ° dest2 çš„å…ƒç´ çš„æœ«å°¾ã€‚
partitioned_point(beg, end, unaryPred); // è¾“å…¥åºåˆ—å¿…é¡»æ˜¯å·²ç»ç”¨ unaryPred åˆ’åˆ†è¿‡çš„ã€‚è¿”å›æ»¡è¶³  unaryPred çš„èŒƒå›´çš„å°¾åè¿­ä»£å™¨ã€‚å¦‚æœè¿”å›çš„è¿­ä»£å™¨ä¸æ˜¯ endï¼Œåˆ™å®ƒæŒ‡å‘çš„å…ƒç´ åŠå…¶åçš„å…ƒç´ å¿…é¡»éƒ½ä¸æ»¡è¶³ unaryPred
stable_partition(beg, end, unaryPred); // ä½¿ç”¨ unaryPred åˆ’åˆ†è¾“å…¥åºåˆ—ã€‚æ»¡è¶³ unaryPred çš„å…ƒç´ æ”¾ç½®åœ¨åºåˆ—å¼€å§‹ï¼Œä¸æ»¡è¶³çš„å…ƒç´ æ”¾åœ¨åºåˆ—å°¾éƒ¨ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªæ»¡è¶³ unaryPred çš„å…ƒç´ ä¹‹åçš„ä½ç½®å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½ä¸æ»¡è¶³ unaryPredï¼Œåˆ™è¿”å› beg
partition(beg, end, unaryPred); // ä½¿ç”¨ unaryPred åˆ’åˆ†è¾“å…¥åºåˆ—ã€‚æ»¡è¶³ unaryPred çš„å…ƒç´ æ”¾ç½®åœ¨åºåˆ—å¼€å§‹ï¼Œä¸æ»¡è¶³çš„å…ƒç´ æ”¾åœ¨åºåˆ—å°¾éƒ¨ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªæ»¡è¶³ unaryPred çš„å…ƒç´ ä¹‹åçš„ä½ç½®å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½ä¸æ»¡è¶³ unaryPredï¼Œåˆ™è¿”å› beg

// æ’åºç®—æ³•ï¼Œè¦æ±‚éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆrandom-access iteratorï¼‰
sort(beg, end); // æ’åºæ•´ä¸ªèŒƒå›´
stable_sort(beg, end); // æ’åºæ•´ä¸ªèŒƒå›´ï¼ˆç¨³å®šæ’åºï¼‰
sort(beg, end, comp); // æ’åºæ•´ä¸ªèŒƒå›´
stable_sort(beg, end, comp); // æ’åºæ•´ä¸ªèŒƒå›´ï¼ˆç¨³å®šæ’åºï¼‰
is_sorted(beg, end); // è¿”å›ä¸€ä¸ª bool å€¼ï¼ŒæŒ‡å‡ºæ•´ä¸ªè¾“å…¥åºåˆ—æ˜¯å¦æœ‰åº
is_sorted(beg, end, comp); // è¿”å›ä¸€ä¸ª bool å€¼ï¼ŒæŒ‡å‡ºæ•´ä¸ªè¾“å…¥åºåˆ—æ˜¯å¦æœ‰åº
is_sorted_until(beg, end); // åœ¨è¾“å…¥åºåˆ—ä¸­æŸ»æ‰¾æœ€é•¿åˆå§‹æœ‰åºå­åºåˆ—ï¼Œå¹¶è¿”å›å­åºåˆ—çš„å°¾åè¿­ä»£å™¨
is_sorted_until(beg, end, comp); // åœ¨è¾“å…¥åºåˆ—ä¸­æŸ»æ‰¾æœ€é•¿åˆå§‹æœ‰åºå­åºåˆ—ï¼Œå¹¶è¿”å›å­åºåˆ—çš„å°¾åè¿­ä»£å™¨
partial_sort(beg, mid, end); // æ’åº mid-beg ä¸ªå…ƒç´ ã€‚å³ï¼Œå¦‚æœ mid-beg ç­‰äº 42ï¼Œåˆ™æ­¤å‡½æ•°å°†å€¼æœ€å°çš„ 42 ä¸ªå…ƒç´ æœ‰åºæ”¾åœ¨åºåˆ—å‰ 42 ä¸ªä½ç½®
partial_sort(beg, mid, end, comp); // æ’åº mid-beg ä¸ªå…ƒç´ ã€‚å³ï¼Œå¦‚æœ mid-beg ç­‰äº 42ï¼Œåˆ™æ­¤å‡½æ•°å°†å€¼æœ€å°çš„ 42 ä¸ªå…ƒç´ æœ‰åºæ”¾åœ¨åºåˆ—å‰ 42 ä¸ªä½ç½®
partial_sort_copy(beg, end, destBeg, destEnd); // æ’åºè¾“å…¥èŒƒå›´ä¸­çš„å…ƒç´ ï¼Œå¹¶å°†è¶³å¤Ÿå¤šçš„å·²æ’åºå…ƒç´ æ”¾åˆ° destBeg å’Œ destEnd æ‰€æŒ‡ç¤ºçš„åºåˆ—ä¸­
partial_sort_copy(beg, end, destBeg, destEnd, comp); // æ’åºè¾“å…¥èŒƒå›´ä¸­çš„å…ƒç´ ï¼Œå¹¶å°†è¶³å¤Ÿå¤šçš„å·²æ’åºå…ƒç´ æ”¾åˆ° destBeg å’Œ destEnd æ‰€æŒ‡ç¤ºçš„åºåˆ—ä¸­
nth_element(beg, nth, end); // nth æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ n å¤§çš„å…ƒç´ ã€‚nth ä¹‹å‰çš„å…ƒç´ éƒ½å°äºç­‰äºå®ƒï¼Œè€Œä¹‹åçš„å…ƒç´ éƒ½å¤§äºç­‰äºå®ƒ
nth_element(beg, nth, end, comp); // nth æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ n å¤§çš„å…ƒç´ ã€‚nth ä¹‹å‰çš„å…ƒç´ éƒ½å°äºç­‰äºå®ƒï¼Œè€Œä¹‹åçš„å…ƒç´ éƒ½å¤§äºç­‰äºå®ƒ

// ä½¿ç”¨å‰å‘è¿­ä»£å™¨çš„é‡æ’ç®—æ³•ã€‚æ™®é€šç‰ˆæœ¬åœ¨è¾“å…¥åºåˆ—è‡ªèº«å†…éƒ¨é‡æ‹å…ƒç´ ï¼Œ_copy ç‰ˆæœ¬å®Œæˆé‡æ‹åå†™å…¥åˆ°æŒ‡å®šç›®çš„åºåˆ—ä¸­ï¼Œè€Œä¸æ”¹å˜è¾“å…¥åºåˆ—
remove(beg, end, val); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤ ==val çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
remove_if(beg, end, unaryPred); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤æ»¡è¶³ unaryPred çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
remove_copy(beg, end, dest, val); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤ ==val çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
remove_copy_if(beg, end, dest, unaryPred); // é€šè¿‡ç”¨ä¿ç•™çš„å…ƒç´ è¦†ç›–è¦åˆ é™¤çš„å…ƒç´ å®ç°åˆ é™¤æ»¡è¶³ unaryPred çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªåˆ é™¤å…ƒç´ çš„å°¾åä½ç½®çš„è¿­ä»£å™¨
unique(beg, end); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ == ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
unique (beg, end, binaryPred); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ binaryPred ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
unique_copy(beg, end, dest); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ == ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
unique_copy_if(beg, end, dest, binaryPred); // é€šè¿‡å¯¹è¦†ç›–ç›¸é‚»çš„é‡å¤å…ƒç´ ï¼ˆç”¨ binaryPred ç¡®å®šæ˜¯å¦ç›¸åŒï¼‰å®ç°é‡æ’åºåˆ—ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘ä¸é‡å¤å…ƒç´ çš„å°¾åä½ç½®
rotate(beg, mid, end); // å›´ç»• mid æŒ‡å‘çš„å…ƒç´ è¿›è¡Œå…ƒç´ è½¬åŠ¨ã€‚å…ƒç´  mid æˆä¸ºä¸ºé¦–å…ƒç´ ï¼Œéšåæ˜¯ mid+1 åˆ°åˆ° end ä¹‹å‰çš„å…ƒç´ ï¼Œå†æ¥ç€æ˜¯ beg åˆ° mid ä¹‹å‰çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘åŸæ¥åœ¨ beg ä½ç½®çš„å…ƒç´ 
rotate_copy(beg, mid, end, dest); // å›´ç»• mid æŒ‡å‘çš„å…ƒç´ è¿›è¡Œå…ƒç´ è½¬åŠ¨ã€‚å…ƒç´  mid æˆä¸ºä¸ºé¦–å…ƒç´ ï¼Œéšåæ˜¯ mid+1 åˆ°åˆ° end ä¹‹å‰çš„å…ƒç´ ï¼Œå†æ¥ç€æ˜¯ beg åˆ° mid ä¹‹å‰çš„å…ƒç´ ã€‚è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘åŸæ¥åœ¨ beg ä½ç½®çš„å…ƒç´ 

// ä½¿ç”¨åŒå‘è¿­ä»£å™¨çš„é‡æ’ç®—æ³•
reverse(beg, end); // ç¿»è½¬åºåˆ—ä¸­çš„å…ƒç´ ï¼Œè¿”å› void
reverse_copy(beg, end, dest);; // ç¿»è½¬åºåˆ—ä¸­çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æ‹·è´åˆ°ç›®çš„åºåˆ—çš„å…ƒç´ çš„å°¾åä½ç½®

// ä½¿ç”¨éšæœºè®¿é—®è¿­ä»£å™¨çš„é‡æ’ç®—æ³•
random_shuffle(beg, end); // æ··æ´—è¾“å…¥åºåˆ—ä¸­çš„å…ƒç´ ï¼Œè¿”å› void
random_shuffle(beg, end, rand); // æ··æ´—è¾“å…¥åºåˆ—ä¸­çš„å…ƒç´ ï¼Œrand æ¥å—ä¸€ä¸ªæ­£æ•´æ•°çš„éšæœºå¯¹è±¡ï¼Œè¿”å› void
shuffle(beg, end, Uniform_rand); // æ··æ´—è¾“å…¥åºåˆ—ä¸­çš„å…ƒç´ ï¼ŒUniform_rand å¿…é¡»æ»¡è¶³å‡åŒ€åˆ†å¸ƒéšæœºæ•°ç”Ÿæˆå™¨çš„è¦æ±‚ï¼Œè¿”å› void

// æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä½¿ç”¨ < è¿ç®—ç¬¦æˆ–ç»™å®šçš„æ¯”è¾ƒæ“ä½œ comp è¿›è¡Œæ¯”è¾ƒ
min(val1, va12); // è¿”å› val1 å’Œ val2 ä¸­çš„æœ€å°å€¼ï¼Œä¸¤ä¸ªå®å‚çš„ç±»å‹å¿…é¡»å®Œå…¨ä¸€è‡´ã€‚å‚æ•°å’Œè¿”å›ç±»å‹éƒ½æ˜¯ constçš„å¼•å¼•ç”¨ï¼Œæ„å‘³ç€å¯¹è±¡ä¸ä¼šè¢«æ‹·è´ã€‚ä¸‹ç•¥
min(val1, val2, comp);
min(init_list);
min(init_list, comp);
max(val1, val2);
max(val1, val2, comp);
max(init_list);
max(init_list, comp);
minmax(val1, val2); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ first æˆå‘˜ä¸ºæä¾›çš„å€¼ä¸­çš„è¾ƒå°è€…ï¼Œsecond æˆå‘˜ä¸ºè¾ƒå¤§è€…ã€‚ä¸‹ç•¥
minmax(vall, val2, comp);
minmax(init_list);
minmax(init_list, comp);
min_element(beg, end); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å°å…ƒç´ çš„è¿­ä»£å™¨
min_element(beg, end, comp); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å°å…ƒç´ çš„è¿­ä»£å™¨
max_element(beg, end); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å¤§å…ƒç´ çš„è¿­ä»£å™¨
max_element(beg, end, comp); // è¿”å›æŒ‡å‘è¾“å…¥åºåˆ—ä¸­æœ€å¤§å…ƒç´ çš„è¿­ä»£å™¨
minmax_element(beg, end); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ä¸­ first æˆå‘˜ä¸ºæœ€å°å…ƒç´ ï¼Œsecond æˆå‘˜ä¸ºæœ€å¤§å…ƒç´ 
minmax_element(beg, end, comp); // è¿”å›ä¸€ä¸ª pairï¼Œå…¶ä¸­ first æˆå‘˜ä¸ºæœ€å°å…ƒç´ ï¼Œsecond æˆå‘˜ä¸ºæœ€å¤§å…ƒç´ 

// å­—å…¸åºæ¯”è¾ƒï¼Œæ ¹æ®ç¬¬ä¸€å¯¹ä¸ç›¸ç­‰çš„å…ƒç´ çš„ç›¸å¯¹å¤§å°æ¥è¿”å›ç»“æœã€‚å¦‚æœç¬¬ä¸€ä¸ªåºåˆ—åœ¨å­—å…¸åºä¸­å°äºç¬¬äºŒä¸ªåºåˆ—ï¼Œåˆ™è¿”å› trueã€‚å¦åˆ™ï¼Œè¿”å› fa1seã€‚å¦‚æœä¸ªåºåˆ—æ¯”å¦ä¸€ä¸ªçŸ­ï¼Œä¸”æ‰€æœ‰å…ƒç´ éƒ½ä¸è¾ƒé•¿åºåˆ—çš„å¯¹åº”å…ƒç´ ç›¸ç­‰ï¼Œåˆ™è¾ƒçŸ­åºåˆ—åœ¨å­—å…¸åºä¸­æ›´å°ã€‚å¦‚æœåºåˆ—é•¿åº¦ç›¸ç­‰ï¼Œä¸”å¯¹åº”å…ƒç´ éƒ½ç›¸ç­‰ï¼Œåˆ™åœ¨å­—å…¸åºä¸­ä»»ä½•ä¸€ä¸ªéƒ½ä¸å¤§äºå¦å¤–ä¸€ä¸ªã€‚
lexicographical_compare(beg1, end1, beg2, end2);
lexicographical_compare(beg1, end1, beg2, end2, comp);
```

* [C++ä¹‹æ—…-vector](https://mp.weixin.qq.com/s/Pizq2-UcJi7rJLTwwxtRlw)
* Is Vector allocated on stack or heap ?
	* Heap
	* [c++ - When vectors are allocated, do they use memory on the heap or the stack? - Stack Overflow](https://stackoverflow.com/questions/8036474/when-vectors-are-allocated-do-they-use-memory-on-the-heap-or-the-stack#:~:text=So%20no%20matter%20how%20you,always%20allocated%20on%20the%20heap%20.)
		* vector\<Type> vect;
			* will allocate the vector, i.e. the header info, on the stack, but the elements on the free store ("heap").
		* vector\<Type> *vect = new vector\<Type>;
			* allocates everything on the free store.
		* vector\<Type*> vect;
			* will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).
* [Difference Between Vector and List - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-vector-and-list/)
	* Vector: Vector is a type of dynamic array which has the ability to resize automatically after insertion or deletion of elements. The elements in vector are placed in contiguous storage so that they can be accessed and traversed using iterators. Element is inserted at the end of the vector.
	* List: List is a double linked sequence that supports both forward and backward traversal. The time taken in the insertion and deletion in the beginning, end and middle is constant. It has the non-contiguous memory and there is no pre-allocated memory.

| Vector | List | 
| - | - | 
| It has contiguous memory.	| While it has non-contiguous memory. | 
| It is synchronized. | While it is not synchronized. | 
| Vector may have a default size. | List does not have default size. | 
| In vector, each element only requires the space for itself only. | In list, each element requires extra space for the node which holds the element, including pointers to the next and previous elements in the list. | 
| Insertion at the end requires constant time but insertion elsewhere is costly. | Insertion is cheap no matter where in the list it occurs. | 
| Vector is thread safe. | List is not thread safe. | 
| Deletion at the end of the vector needs constant time but for the rest it is O(n). | Deletion is cheap no matter where in the list it occurs. | 
| Random access of elements is possible. | Random access of elements is not possible. | 
| Iterators become invalid if elements are added to or removed from the vector. | Iterators are valid if elements are added to or removed from the list. | 

* class std::string
  * [string - C++ Reference](https://www.cplusplus.com/reference/string/string/)
  * [C++ä¹‹æ—…-string](https://mp.weixin.qq.com/s/P2nd-9fmhpn20bB45hBioQ)
* Object Slicing
  * [Object slicing - Wikipedia](https://en.wikipedia.org/wiki/Object_slicing)
  * In C++ programming, object slicing occurs when an object of a subclass type is copied to an object of superclass type: the superclass copy will not have any of the member variables defined in the subclass. These variables have, in effect, been "sliced off".) More subtly, object slicing can also occur when an object of a subclass type is copied to an object of the same type by the superclass's assignment operator, in which case some of the target object's member variables will retain their original values instead of being copied from the source object.
  * This issue is not inherently unique to C++, but it does not occur naturally in most other object-oriented languages â€” even C++'s relatives such as D, Java, and C# â€” because copying of objects is not a basic operation in those languages. (Instead, those languages prefer to manipulate objects via implicit references, such that only copying the reference is a basic operation.) In C++, by contrast, objects are copied automatically whenever a function takes an object argument by value or returns an object by value. Additionally, due to the lack of garbage collection in C++, programs will frequently copy an object whenever the ownership and lifetime of a single shared object would be unclear; for example, inserting an object into a standard-library collection, such as a std::vector, actually involves inserting a copy into the collection.
  * [c++å¯¹è±¡åˆ‡å‰² - CSDNåšå®¢](https://blog.csdn.net/weiwangchao_/article/details/4702241)
* å¼‚å¸¸,å¼‚å¸¸çš„åŠŸèƒ½
  * ä¿è¯å¼‚å¸¸çš„å¥å£®æ€§ï¼Œç»“æ„åŒ–å¤„ç†å‡ºé”™ä¿¡æ¯
* Exception safety
	* [Exception safety - Wikipedia](https://en.wikipedia.org/wiki/Exception_safety)
		* The C++ standard library provides several levels of exception safety (in decreasing order of safety):[6]
			* No-throw guarantee, also known as failure transparency: Operations are guaranteed to succeed and satisfy all requirements even in exceptional situations. If an exception occurs, it will be handled internally and not observed by clients.
			* Strong exception safety, also known as commit or rollback semantics: Operations can fail, but failed operations are guaranteed to have no side effects, leaving the original values intact.[7]
			* Basic exception safety: Partial execution of failed operations can result in side effects, but all invariants are preserved. Any stored data will contain valid values which may differ from the original values. Resource leaks (including memory leaks) are commonly ruled out by an invariant stating that all resources are accounted for and managed.
			* No exception safety: No guarantees are made.
	* [How to: Design for exception safety | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/how-to-design-for-exception-safety?view=msvc-170#:~:text=A%20basic%20axiom%20of%20C%2B%2B,on%20all%20destructors%20it%20defines.)
		* Typically, exception safety is discussed in terms of the three exception guarantees that a function can provide: the no-fail guarantee, the strong guarantee, and the basic guarantee.
		* No-fail guarantee
			* The no-fail (or, "no-throw") guarantee is the strongest guarantee that a function can provide. It states that the function will not throw an exception or allow one to propagate. However, you cannot reliably provide such a guarantee unless (a) you know that all the functions that this function calls are also no-fail, or (b) you know that any exceptions that are thrown are caught before they reach this function, or (c) you know how to catch and correctly handle all exceptions that might reach this function.
			* Both the strong guarantee and the basic guarantee rely on the assumption that the destructors are no-fail. All containers and types in the Standard Library guarantee that their destructors do not throw. There is also a converse requirement: The Standard Library requires that user-defined types that are given to itâ€”for example, as template argumentsâ€”must have non-throwing destructors.
		* Strong guarantee
			* The strong guarantee states that if a function goes out of scope because of an exception, it will not leak memory and program state will not be modified. A function that provides a strong guarantee is essentially a transaction that has commit or rollback semantics: either it completely succeeds or it has no effect.
		* Basic guarantee
			* The basic guarantee is the weakest of the three. However, it might be the best choice when a strong guarantee is too expensive in memory consumption or in performance. The basic guarantee states that if an exception occurs, no memory is leaked and the object is still in a usable state even though the data might have been modified.

### Modern C++

* [B.1 â€” Introduction to C++11 â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/b-1-introduction-to-c11/)
* [B.2 â€” Introduction to C++14 â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/b-2-introduction-to-c14/)
* [B.3 â€” Introduction to C++17 â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/b-3-introduction-to-c17/)
* [B.4 â€” Introduction to C++20 â€“ Learn C++](https://www.learncpp.com/cpp-tutorial/introduction-to-c20/)
* [æ¯ä¸ªå¼€å‘è€…éƒ½åº”è¯¥äº†è§£çš„ä¸€äº›C++ç‰¹æ€§](https://mp.weixin.qq.com/s/Hpn7KqYlBKz0JdryiozqyQ)
  * https://www.freecodecamp.org/news/some-awesome-modern-c-features-that-every-developer-should-know-5e3bf6f79a3c/
  * C++ æ˜¯ä¸€ç§å¼ºå¤§çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½†ä¹Ÿå› ä¸ºå…¶å¤æ‚æ€§ä¸€ç›´è®©ç”¨æˆ·æœ›è€Œå´æ­¥ã€‚åæ¥ï¼ŒC++ å†³å®šåšå‡ºæ”¹å˜ï¼Œç„¶åå‘å±•è‡³ä»Šï¼Œæˆäº†ç¼–ç¨‹ç¤¾åŒºæœ€å—æ¬¢è¿çš„è¯­è¨€ä¹‹ä¸€ã€‚C++ æœ‰ä¸€äº›æ–°ç‰¹æ€§éå¸¸å¥½ç”¨ï¼Œæœ¬æ–‡å¯¹æ­¤è¿›è¡Œäº†ä»‹ç»ï¼Œæ¯”å¦‚ autoã€lambdaã€constexprã€tupleã€æ™ºèƒ½æŒ‡é’ˆç­‰ã€‚
  * auto æ¦‚å¿µ
  * lambda è¡¨è¾¾å¼
  * if æˆ– switch è¯­å¥é‡Œçš„åˆå§‹çŠ¶æ€
  * ç¼–è¯‘æ—¶æ‰§è¡Œ constexpr
  * tuple
  * ç±»æ¨¡ç‰ˆå‚æ•°æ¨æ–­
  * æ™ºèƒ½æŒ‡é’ˆ
* [C++ ä¸­çš„å„ç§ç‰¹æ€§](https://mp.weixin.qq.com/s?__biz=MzA4MjI3NzQ1Nw==&mid=2247502245&idx=1&sn=9e472ebac369ffc5219ebd9e5cf67b9f&chksm=9f8aac9ba8fd258db6d136449963bbe2669fb65183a58822824314995faad442f5e5211444cc&scene=178&cur_album_id=1511180677537464321#rd)
	* https://blog.csdn.net/a15920804211/article/details/90691525
* [C++ 11 æ–°ç‰¹æ€§æ¢³ç†](https://mp.weixin.qq.com/s/c6BCvqbmwU6jCOhjL7qQPQ)
  * https://www.jianshu.com/p/78c700c8d72d
  * åœ¨é¢è¯•ä¸­ï¼Œç»å¸¸è¢«é—®çš„ä¸€ä¸ªé—®é¢˜å°±æ˜¯ï¼šä½ äº†è§£C++11å“ªäº›æ–°ç‰¹æ€§ï¼Ÿä¸€èˆ¬è€Œè¨€ï¼Œå›ç­”ä»¥ä¸‹å››ä¸ªæ–¹é¢å°±å¤Ÿäº†ï¼š
    * â€œè¯­æ³•ç³–â€ï¼šnullptr, autoè‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼ŒèŒƒå›´forå¾ªç¯ï¼Œåˆå§‹åŒ–åˆ—è¡¨, lambdaè¡¨è¾¾å¼ç­‰
    * å³å€¼å¼•ç”¨å’Œç§»åŠ¨è¯­ä¹‰
    * æ™ºèƒ½æŒ‡é’ˆ
    * C++11å¤šçº¿ç¨‹ç¼–ç¨‹ï¼šthreadåº“åŠå…¶ç›¸é…å¥—çš„åŒæ­¥åŸè¯­mutex, lock_guard, condition_variable, ä»¥åŠå¼‚æ­¥std::furture
* [ã€C++é¢è¯•çŸ¥è¯†ã€‘C++11æ–°ç‰¹æ€§](https://mp.weixin.qq.com/s/jZRnb8WxNoJvdbiHrSuFlQ)
	* https://blog.csdn.net/a15920804211/article/details/90691525
* [C++17 åœ¨ä¸šåŠ¡ä»£ç ä¸­æœ€å¥½ç”¨çš„åä¸ªç‰¹æ€§](https://mp.weixin.qq.com/s/jlM1NWRNpoOvW2qrBtxflQ)
	* è‡ªä»æ­¥å…¥ç°ä»£ C++æ—¶ä»£å¼€å§‹ï¼ŒC++è¯­è¨€æ ‡å‡†å½¢æˆäº†ä¸‰å¹´ä¸€ä¸ªç‰ˆæœ¬çš„æƒ¯ä¾‹ï¼šC++11 æ ‡å¿—ç€ç°ä»£ C++çš„å¼€ç«¯ï¼ŒC++14 åœ¨ 11 çš„åŸºç¡€ä¸ŠæŸ¥ç¼ºè¡¥æ¼ï¼Œå¹¶æœªåŠ å…¥è®¸å¤šæ–°ç‰¹æ€§ï¼Œè€Œ C++17 ä½œä¸º C++11 åçš„ç¬¬ä¸€ä¸ªå¤§ç‰ˆæœ¬ï¼Œæ ‡å¿—ç€ç°ä»£ C++é€æ¸èµ°å‘æˆç†Ÿã€‚WXG ç¼–è¯‘å™¨å‡çº§åˆ° gcc7.5 å·²æœ‰ä¸€æ®µæ—¶é—´ï¼Œç¬”è€…æ‰€åœ¨é¡¹ç›®ç»„ä¹Ÿå·²ç»å°†å…¨éƒ¨ä»£ç å‡çº§åˆ° C++17ã€‚åœ¨ä½¿ç”¨äº† C++17 ä¸€å¹´å¤šä¹‹åï¼Œç¬”è€…æ€»ç»“äº† C++17 åœ¨ä¸šåŠ¡ä»£ç ä¸­æœ€å¥½ç”¨çš„åä¸ªç‰¹æ€§ã€‚
	* ç¬”è€…å°†è¿™äº›ç‰¹æ€§å¤§ä½“ä¸Šåˆ†ä¸ºä¸‰ç±»ï¼šè¯­æ³•ç³–ã€æ€§èƒ½æå‡å’Œç±»å‹ç³»ç»Ÿã€‚
	* è¯­æ³•ç³–
		* ç»“æ„åŒ–ç»‘å®š
		* std::tuple çš„éšå¼æ¨å¯¼
		* if constexpr
		* if åˆå§‹åŒ–è¯­å¥
	* æ€§èƒ½æå‡
		* std::shared_mutex
		* std::string_view
		* std::map/unordered_map try_emplace
	* ç±»å‹ç³»ç»Ÿ
		* std::any
		* std::optional
		* std::variant
		* æ€»ç»“ä¸€ä¸‹ï¼Œc++17 æ–°å¢çš„ä¸‰ç§ç±»å‹ç»™ c++å¸¦æ¥äº†æ›´ç°ä»£æ›´å®‰å…¨çš„ç±»å‹ç³»ç»Ÿï¼Œå®ƒä»¬å¯¹åº”çš„ä½¿ç”¨åœºæ™¯æ˜¯ï¼š
			* std::anyé€‚ç”¨äºä¹‹å‰ä½¿ç”¨void*ä½œä¸ºé€šç”¨ç±»å‹çš„åœºæ™¯ã€‚
			* std::optionalé€‚ç”¨äºä¹‹å‰ä½¿ç”¨nullpträ»£è¡¨å¤±è´¥çŠ¶æ€çš„åœºæ™¯ã€‚
			* std::varianté€‚ç”¨äºä¹‹å‰ä½¿ç”¨unionçš„åœºæ™¯ã€‚
	* æ€»ç»“
		* ä»¥ä¸Šæ˜¯ç¬”è€…åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æœ€å¸¸ç”¨çš„ c++17 ç‰¹æ€§ï¼Œé™¤äº†æœ¬æ–‡æè¿°çš„åä¸ªç‰¹æ€§å¤–ï¼Œc++17 è¿˜æ·»åŠ äº†å¦‚lambda å€¼æ•è·*this, é’³å¤¹å‡½æ•° std::clamp(), å¼ºåˆ¶æ£€æŸ¥è¿”å›å€¼[[nodiscard]]ç­‰éå¸¸æ˜“ç”¨çš„ç‰¹æ€§ï¼Œæœ¬æ–‡ç¯‡å¹…æœ‰é™ä¸åšèµ˜è¿°ï¼Œæ¬¢è¿æœ‰å…´è¶£çš„è¯»è€…è‡ªè¡Œæ¢ç´¢ã€‚
* [è§£è¯»C++å³å°†è¿æ¥çš„é‡å¤§æ›´æ–°ï¼ˆä¸€ï¼‰ï¼šC++20çš„å››å¤§æ–°ç‰¹æ€§](https://mp.weixin.qq.com/s/QpqvZ3a7nFdHGjIBiKX67g)
  * https://www.modernescpp.com/index.php/thebigfour
* [Google â€œæˆ˜è´¥â€åï¼ŒC++20 ç”¨å¾®è½¯çš„ææ¡ˆè¿›å…¥åç¨‹æ—¶ä»£ï¼](https://mp.weixin.qq.com/s/SlTObQQeDXvLLXuoxbO1yg)

## Idioms

* [Curiously Recurring Template Pattern](https://github.com/haoran119/c-cpp/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BC-C++/README.md#curiously-recurring-template-pattern---cppreferencecom)
	* The Curiously Recurring Template Pattern is an idiom in which a class X derives from a class template Y, taking a template parameter Z, where Y is instantiated with Z=X.
	* CRTP may be used to implement "compile-time polymorphism", when a base class exposes an interface, and derived classes implement such interface.
* [DRY - Don't repeat yourself - Wikipedia](https://en.wikipedia.org/wiki/Don't_repeat_yourself)
  * "Don't repeat yourself" (DRY, or sometimes "do not repeat yourself") is a principle of software development aimed at reducing repetition of software patterns,[1] replacing it with abstractions or using data normalization to avoid redundancy.
  * The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system". The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer.[2] They apply it quite broadly to include "database schemas, test plans, the build system, even documentation".[3] When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync. Besides using methods and subroutines in their code, Thomas and Hunt rely on code generators, automatic build systems, and scripting languages to observe the DRY principle across layers.
* [PImpl - cppreference.com](https://en.cppreference.com/w/cpp/language/pimpl)
	* "Pointer to implementation" or "pImpl" is a C++ programming technique[1] that removes implementation details of a class from its object representation by placing them in a separate class, accessed through an opaque pointer
	* This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.
* [Race condition](https://en.wikipedia.org/wiki/Race_condition)
	* A race condition or race hazard is the condition of an electronics, software, or other system where the system's substantive behavior is dependent on the sequence or timing of other uncontrollable events. It becomes a bug when one or more of the possible behaviors is undesirable.
	* [multithreading - What is a race condition? - Stack Overflow](https://stackoverflow.com/questions/34510/what-is-a-race-condition)
		* A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.
* [RAII - cppreference.com](https://en.cppreference.com/w/cpp/language/raii)
	* Resource Acquisition Is Initialization or RAII, is a C++ programming technique[1][2] which binds the life cycle of a resource that must be acquired before use (allocated heap memory, thread of execution, open socket, open file, locked mutex, disk space, database connectionâ€”anything that exists in limited supply) to the lifetime of an object.
	* RAII can be summarized as follows:
		* encapsulate each resource into a class, where
			* the constructor acquires the resource and establishes all class invariants or throws an exception if that cannot be done,
			* the destructor releases the resource and never throws exceptions;
		* always use the resource via an instance of a RAII-class that either
			* has automatic storage duration or temporary lifetime itself, or
			* has lifetime that is bounded by the lifetime of an automatic or temporary object
	* Move semantics make it possible to safely transfer resource ownership between objects, across scopes, and in and out of threads, while maintaining resource safety.
	* Classes with open()/close(), lock()/unlock(), or init()/copyFrom()/destroy() member functions are typical examples of non-RAII classes
  * [RAII - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/wiki/RAII)
    * RAIIå…¨ç§°ä¸ºResource Acquisition Is Initializationï¼Œå®ƒæ˜¯åœ¨ä¸€äº›é¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„ä¸€ç§æƒ¯ç”¨æ³•ã€‚RAIIæºäºC++ï¼Œåœ¨Javaï¼ŒC#ï¼ŒDï¼ŒAdaï¼ŒValaå’ŒRustä¸­ä¹Ÿæœ‰åº”ç”¨ã€‚1984-1989å¹´æœŸé—´ï¼Œæ¯”é›…å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹é²æ™®å’Œå®‰å¾·é²Â·æŸ¯å°¼å¸Œåœ¨è®¾è®¡C++å¼‚å¸¸æ—¶ï¼Œä¸ºè§£å†³èµ„æºç®¡ç†æ—¶çš„å¼‚å¸¸å®‰å…¨æ€§è€Œä½¿ç”¨äº†è¯¥ç”¨æ³•ï¼Œåæ¥æ¯”é›…å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹é²æ™®å°†å…¶ç§°ä¸ºRAIIã€‚
    * RAIIè¦æ±‚ï¼Œèµ„æºçš„æœ‰æ•ˆæœŸä¸æŒæœ‰èµ„æºçš„å¯¹è±¡çš„ç”Ÿå‘½æœŸä¸¥æ ¼ç»‘å®šï¼Œå³ç”±å¯¹è±¡çš„æ„é€ å‡½æ•°å®Œæˆèµ„æºçš„åˆ†é…(è·å–)ï¼ŒåŒæ—¶ç”±ææ„å‡½æ•°å®Œæˆèµ„æºçš„é‡Šæ”¾ã€‚åœ¨è¿™ç§è¦æ±‚ä¸‹ï¼Œåªè¦å¯¹è±¡èƒ½æ­£ç¡®åœ°ææ„ï¼Œå°±ä¸ä¼šå‡ºç°èµ„æºæ³„éœ²é—®é¢˜ã€‚
  * [RAII_ç™¾åº¦ç™¾ç§‘](http://baike.baidu.com/link?url=cZ_EqWVrbxk9AIOFJ-9IrYDMRVaeEtubQlI-JKvquwrTkm9clZshXDLN9WM1Kth0W98ADgTckgMMEAwmQ3gZDq)
    * RAIIï¼Œä¹Ÿç§°ä¸ºâ€œèµ„æºè·å–å°±æ˜¯åˆå§‹åŒ–â€ï¼Œæ˜¯c++ç­‰ç¼–ç¨‹è¯­è¨€å¸¸ç”¨çš„ç®¡ç†èµ„æºã€é¿å…å†…å­˜æ³„éœ²çš„æ–¹æ³•ã€‚å®ƒä¿è¯åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œä½¿ç”¨å¯¹è±¡æ—¶å…ˆæ„é€ å¯¹è±¡ï¼Œæœ€åææ„å¯¹è±¡ã€‚
    * [å¯¹è±¡æ‰€æœ‰èµ„æº (RAII)](https://msdn.microsoft.com/zh-cn/library/hh438480.aspx)
* RTTI
  * RTTIäº‹æŒ‡è¿è¡Œæ—¶ç±»å‹è¯†åˆ«ï¼ˆRun-time type identificationï¼‰åœ¨åªæœ‰ä¸€ä¸ªæŒ‡å‘åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨æ—¶ç¡®å®šä¸€ä¸ªå¯¹è±¡çš„å‡†ç¡®ç±»å‹ã€‚
* [SOLID - Wikipedia](https://en.wikipedia.org/wiki/SOLID)
  * In software engineering, SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible, and maintainable. The principles are a subset of many principles promoted by American software engineer and instructor Robert C. Martin,[1][2][3] first introduced in his 2000 paper Design Principles and Design Patterns.[2][4]
  * The SOLID concepts are
    * The Single-responsibility principle: "There should never be more than one reason for a class to change."[5] In other words, every class should have only one responsibility.[6]
    * The Openâ€“closed principle: "Software entities ... should be open for extension, but closed for modification."[7]
    * The Liskov substitution principle: "Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it."[8] See also design by contract.[8]
    * The Interface segregation principle: "Many client-specific interfaces are better than one general-purpose interface."[9][4]
    * The Dependency inversion principle: "Depend upon abstractions, [not] concretions."[10][4]
* [The rule of three/five/zero - cppreference.com](https://en.cppreference.com/w/cpp/language/rule_of_three)
	* Rule of three
		* If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three.
		* Because C++ copies and copy-assigns objects of user-defined types in various situations (passing/returning by value, manipulating a container, etc), these special member functions will be called, if accessible, and if they are not user-defined, they are implicitly-defined by the compiler.
		* The implicitly-defined special member functions are typically incorrect if the class manages a resource whose handle is an object of non-class type (raw pointer, POSIX file descriptor, etc), whose destructor does nothing and copy constructor/assignment operator performs a "shallow copy" (copy the value of the handle, without duplicating the underlying resource).
		* Classes that manage non-copyable resources through copyable handles may have to declare copy assignment and copy constructor private and not provide their definitions or define them as deleted. This is another application of the rule of three: deleting one and leaving the other to be implicitly-defined will most likely result in errors.
	* Rule of five
		* Because the presence of a user-defined (or = default or = delete declared) destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the move constructor and the move assignment operator, any class for which move semantics are desirable, has to declare all five special member functions
		* Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.
	* Rule of zero
		* Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively with ownership (which follows from the Single Responsibility Principle). Other classes should not have custom destructors, copy/move constructors or copy/move assignment operators[1].
		* This rule also appears in the C++ Core Guidelines as [C.20: If you can avoid defining default operations, do](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c20-if-you-can-avoid-defining-default-operations-do).
		* When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted[2].
		* however, this makes the class prone to slicing, which is why polymorphic classes often define copy as deleted (see [C.67: A polymorphic class should suppress copying](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c67-a-polymorphic-class-should-suppress-public-copymove) in C++ Core Guidelines), which leads to the following generic wording for the Rule of Five:
		* [C.21: If you define or =delete any default operation, define or =delete them all](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c21-if-you-define-or-delete-any-copy-move-or-destructor-function-define-or-delete-them-all)
	* [Rule of three (C++ programming) - Wikipedia](https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming))
* [Zero-overhead principle - cppreference.com](https://en.cppreference.com/w/cpp/language/Zero-overhead_principle)
	* The zero-overhead principle is a C++ design principle that states:
		* You don't pay for what you don't use.
		* What you do use is just as efficient as what you could reasonably write by hand.
	* In general, this means that no feature should be added to C++ that would impose any overhead, whether in time or space, greater than a programmer would introduce without using the feature.
	* The only two features in the language that do not follow the zero-overhead principle are [runtime type identification](https://en.cppreference.com/w/cpp/language/typeid) and [exceptions](https://en.cppreference.com/w/cpp/language/exceptions), and are why most compilers include a switch to turn them off.

## CODE

* [c-cpp/é¢è¯•æ€»ç»“ä¹‹C-C++ at main Â· haoran119/c-cpp](https://github.com/haoran119/c-cpp/tree/main/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8BC-C%2B%2B)
* [C/C++ 10 å¤§å¸¸è§åŸºç¡€ç®—æ³•](https://mp.weixin.qq.com/s/tGGNGpaRcWwKiNoQyo-TXw)
* ç”¨Cè¯­è¨€ï¼Œå°†ä¸€ä¸ªæ•°å­—ä¹˜ä»¥7å€çš„æ•ˆç‡æœ€å¿«çš„æ–¹æ³•æ˜¯ä»€ä¹ˆï¼Ÿ 
  * å…ˆå·¦ç§»ä¸‰ä½ï¼ˆ*8ï¼‰ç„¶åå†å‡å»åŸå€¼ï¼šX << 3 â€“ X

### åˆ¤æ–­è¾“å‡ºç»“æœ

#### Const

```c++
/*
What's wrong, and how to fix?

Const variable aaa should be initialized when being defined.
To fix it, we could take any one action as below.
1) Initialize aaa in construct function
2) Assign a value in this statement const int aaa;
3) Remove keyword const
*/

class TryConst
{
public:
    TryConst () {}
private:
    const int aaa;
};
```

#### Static

```c++
/*
What's wrong, and how to fix?

Static variable could not be initialized inside the class.
To fix it, we could initialize it outside the class, e.g. int aa = 0.
*/

class TryStatic
{
public:
    TryStatic () : aa (0) {}
private:
    static int aa;
};

// int TryStatic::aa = 1;
```

#### String

```c++
#include <iostream>
using namespace std;

void compare_str()
{
    string s1 = "Abc";
    string s2 = "A";

    s1 = s1 + s2;
    s2 = s2 + s1;

    cout << s1 << endl;  // AbcA
    cout << s2 << endl;  // AAbcA
    cout << s1.length() << endl; // 4
    cout << s2.length() << endl; // 5
    cout << (s1.compare(s2) > 0) << endl; // 1
}

int main()
{
    compare_str();

    return 0;
}
```
```c++
#include <iostream>
using namespace std;

void f(string x, string& y)
{
    x += "x";
    y += "y";

    cout << x << " " << y << " ";
}

int main()
{
    string x = "x";
    string y = "y";

    f(x, y);
    cout << x << " " << y << "\n";

    return 0;
}

// xx yy x yy
```

#### Pointer

* [ä¸€é“Cè¯­è¨€æŒ‡é’ˆçš„é¢˜ç›®](https://mp.weixin.qq.com/s/KqbMSR_rYD7ziWt-YsrYRQ)
```c++
#include <iostream>
using namespace std;

int foo(int &p)
{
    ++ p;

    return p ++;
}

int main()
{
    int a = 1, b, d;
    int * const c = &d;
    b = foo(a);
    *c = 10;

    cout << a << endl;  // 3
    cout << b << endl;  // 2
    cout << *c << endl; // 10
    cout << d << endl;  // 10

    return 0;
}
```

#### Class

```c++
/*
What's wrong, and how to fix?

~P2 would not be executed, which would cause memory leak.
To fix it, define ~P1() as virtual ~P1().
*/

class P1
{
public:
    P1 () { p = new char [10]; }
    ~P1 () { delete [] p; }
private:
    char * p;
};
class P2 : public P1
{
public:
    P2 () { q = new char [20]; }
    ~P2 () { delete [] q; }
private:
    char * q;
};

int main(int argc, char* argv[])
{
    P1 * pp = new P2;
    ...
    delete pp;
    return 0;
}
```
```c++
/*
What's wrong, and how to fix?

When multiple access, the Next function will make the current pointer behave unexpected. 
E.g. A is calling doSomething(), and B issues Next(). When A issues Next(), 
actually the current node is not current->next but current->next->next.
To fix it, add a parameter for Next() => Next(Thing *currentNode) 
so that it could make sure that the next node would not be changed by others.
*/

#include <iostream>
using namespace std;

class Thing {
public:
    void    doSomething() { cout << __func__ << endl; }
    Thing*    next;
};

class Things {
public:
    Things(Thing *myThing) : head(myThing), current(myThing) {}

    Thing*  First() {
        return head;
    }

    Thing*  Next() {
        current = current->next;
        return current;
    }

    bool OK() {
        if (current != nullptr)
            return true;
        else
            return false;
    }

private:
    Thing *head, *current;
};

int main()
{
    Thing*   myThing = new Thing;
    Things myThings(myThing);

    // This is how we do with class Things
    /*
        doSomething
        */
    for (Thing *ptr = myThings.First(); myThings.OK(); myThings.Next()) {
        ptr->doSomething();
    }

    return 0;
}
```
```c++
/*
What will be printed, and why?

In 32-bit environment, size of TestSize2 = 12.
12 = TestSize2 virtual table pointer(4) + TestSize2::b(4) + TestSize1::a(4)
*/

class TestSize1
{
public:
    TestSize1 () : a (0) {}
    virtual void F () = 0;
private:
    int a;
};
class TestSize2 : public TestSize1
{
public:
    TestSize2 () : b (1) {}
    virtual void F () { b = 3; }
private:
    int b;
};
int main(int argc, char* argv[])
{
    printf ("size of TestSize2 = %d", sizeof (TestSize2));
    return 0;
}
```
```c++
/*
What will be printed, and why?

data=1.
Because class B inherits class A, it would call constructor of A and B when constructing b. 
When calling the constructor of A, A::SetData() was called, so data was set to 1.
*/

class A
{
public:
    A () : data (0) { SetData (); printf ("data=%d", data); }
    virtual void SetData () { data = 1; }
protected:
    int data;
};

class B : public A
{
public:
    B () {}
    virtual void SetData () { data = 2; }
};

int main(int argc, char* argv[])
{
    B b;
    return 0;
}
```
```c++
#include <iostream>

class A
{
public:
    A() { std::cout << "A()\n"; }
    ~A() { std::cout << "~A()\n"; }
};

class B : public A
{
public:
    B() { std::cout << "B()\n"; }
    ~B() { std::cout << "~B()\n"; }
};

int main()
{
    B b;    // A() B()
    A* p = new B;   // A() B()
    delete p;   // ~A()

    return 0;
}   // ~B() ~A()
```

#### STL

```c++
#include <iostream>
using namespace std;

int main()
{
    int a[] = {4, 5, 6};

    cout << *a << endl; // 4

    return 0;
}
```
```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v = {1, 2, 3};
    auto it = v.begin();
    cout << *it << endl;    // 1
    v.push_back(4);
    cout << *it << endl;    // undefined behavior

    return 0;
}
```
```c++
#include <iostream>
#include <set>
using namespace std;

int main()
{
    set<int> s;
    s.insert(3);
    s.insert(3);
    s.insert(2);

    // 2 3
    for (auto it = s.begin(); it != s.end(); ++ it) {
        cout << *it << endl;
    }

    return 0;
}
```
